<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Borland C++ :: Boost Libraries Documentation</title>
    <link rel="canonical" href="https://antora.cppalliance.org/develop/libs/contributor-manual/dev/borland_cpp.html">
    <meta name="generator" content="Antora 3.1.2">
    <link rel="stylesheet" href="../../_/css/site.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">
    <script>var uiRootPath = '../../_'</script>

<script>

function updateTheme() {
  if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
    document.documentElement.classList.add('dark')
    document.getElementById("theme-button").checked = true;
  } else {
    document.documentElement.classList.remove('dark')
    document.getElementById("theme-button").checked = false;
  }
};

function onThemeButton() {
  if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
    localStorage.theme = 'light';
  } else {
    localStorage.theme = 'dark';
  }
  updateTheme();
}

window.addEventListener('load', function() {
    updateTheme();
}, false);

</script>
  </head>
  <body class="article">
<header>
  <nav class="navbar">
    <div class="navbar-brand">
      <button class="site-logo"></button>
      <a class="site-name" href="https://antora.cppalliance.org/develop/libs">Boost</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-tabs">
        <a class="navbar-item" href="#">News</a>
        <a class="navbar-item" href="#">Learn</a>
        <a class="navbar-item" href="#">Community</a>
        <a class="navbar-item" href="#">Libraries</a>
        <a class="navbar-item" href="#">Releases</a>
        <div id="theme">
          <input type="checkbox" id="theme-button" onclick="onThemeButton()"/>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="contributor-manual" data-version="">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" title="Toggle expand/collapse all"></button>
    <h3 class="title"><a href="../index.html">Contributor Manual</a></h3>
    <ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../intro.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Development</span>
<ul class="nav-list">
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="borland_cpp.html">Borland C++</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="bugs.html">Bugs</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="design_faq.html">Boost Website Design FAQ</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="exemplar.html">Website Exemplars</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="header.html">Boost Header policy</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="index.html">Boost Development</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="int_const_guidelines.html">Coding Guidelines for Integral Constant Expressions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="library_metadata.html">Library Metadata</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="report-apr-2006.html">Review Wizard Status Report for April 2006</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="report-dec-2009.html">Review Wizard Status Report for December 2009</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="report-jan-2006.html">Review Wizard Status Report for January 2006</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="report-jun-2009.html">Review Wizard Status Report for June 2009</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="report-may-2008.html">Review Wizard Status Report for May 2008</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="report-nov-2007.html">Review Wizard Status Report for November 2007</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="report-nov-2008.html">Review Wizard Status Report for November 2008</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="report-sep-2007.html">Review Wizard Status Report for September 2007</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="requirements.html">Boost Library Requirements and Guidelines</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reuse.html">Boost Library Reuse</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="running_regression_tests.html">Running Boost Regression Tests</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="separate_compilation.html">Guidelines for Authors of Boost Libraries Containing Separate Source</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="submissions.html">Boost Library Submission Process</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="test.html">Boost Test Policies and Protocols</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="testing.html">Testing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="website_updating.html">Boost C++ Libraries - Updating Website</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
    </div>
  </aside>
</div>
   
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Contributor Manual</a></li>
    <li>Development</li>
    <li><a href="borland_cpp.html">Borland C++</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/cppalliance/contributor-manual/edit/develop/antora/modules/ROOT/pages/dev/borland_cpp.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Borland C++</h1>
<div class="sect1">
<h2 id="portability-hints-borland-c-5-5-1"><a class="anchor" href="#portability-hints-borland-c-5-5-1"></a>Portability Hints: Borland C++ 5.5.1</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It is a general aim for boost libraries to be [portable](/development/requirements.html#Portability). The
 primary means for achieving this goal is to adhere to ISO
 Standard C. However, ISO C is a broad and complex standard
 and most compilers are not fully conformant to ISO C++ yet. In
 order to achieve portability in the light of this restriction,
 it seems advisable to get acquainted with those language
 features that some compilers do not fully implement yet.</p>
</div>
<div class="paragraph">
<p>This page gives portability hints on some language features
 of the Borland C version 5.5.1 compiler. Furthermore, the
 appendix presents additional problems with Borland C version
 5.5. Borland C++ 5.5.1 is a freely available command-line
 compiler for Win32 available at <a href="http://www.borland.com/" class="bare">http://www.borland.com/</a>.</p>
</div>
<div class="paragraph">
<p>Each entry in the following list describes a particular
 issue, complete with sample source code to demonstrate the
 effect. Most sample code herein has been verified to compile
 with gcc 2.95.2 and Comeau C++ 4.2.44.</p>
</div>
<div class="sect2">
<h3 id="preprocessor-symbol"><a class="anchor" href="#preprocessor-symbol"></a>Preprocessor symbol</h3>
<div class="paragraph">
<p>The preprocessor symbol <code><em>BORLANDC</em></code> is defined
 for all Borland C++ compilers. Its value is the version number
 of the compiler interpreted as a hexadecimal number. The
 following table lists some known values.</p>
</div>
<div class="paragraph">
<p>| Compiler | <code><em>BORLANDC</em></code> value |
| --- | --- |
| Borland C Builder 4 | 0x0540 |
| Borland C Builder 5 | 0x0550 |
| Borland C 5.5 | 0x0550 |
| Borland C 5.5.1 | 0x0551 |
| Borland C++ Builder 6 | 0x0560 |</p>
</div>
</div>
<div class="sect2">
<h3 id="core-language"><a class="anchor" href="#core-language"></a>Core Language</h3>
<div class="sect3">
<h4 id="using-directive-mixing-using-declarations"><a class="anchor" href="#using-directive-mixing-using-declarations"></a>[using-directive] Mixing <code>using</code>-declarations</h4>
<div class="literalblock">
<div class="content">
<pre>and `using`-directives</pre>
</div>
</div>
<div class="paragraph">
<p>Mixing <code>using</code>-directives (which refer to whole
 namespaces) and namespace-level <code>using</code>-declarations
 (which refer to individual identifiers within foreign
 namespaces) causes ambiguities where there are none. The
 following code fragment illustrates this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">namespace N {
  int x();
}

using N::x;
using namespace N;

int main()
{
  &amp;x;     // Ambiguous overload
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-template-using-declarations-for-class"><a class="anchor" href="#using-template-using-declarations-for-class"></a>[using template] <code>using</code>-declarations for class</h4>
<div class="literalblock">
<div class="content">
<pre>templates</pre>
</div>
</div>
<div class="paragraph">
<p>Identifiers for class templates can be used as arguments to
 <code>using</code>-declarations as any other identifier.
 However, the following code fails to compile with Borland
 C++:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">template&lt;class T&gt;
class X { };

namespace N
{
  // "cannot use template 'X&lt;T&gt;' without specifying specialization parameters"
  using ::X;
};</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="template-const-arg-deduction-of-constant-arguments-to"><a class="anchor" href="#template-const-arg-deduction-of-constant-arguments-to"></a>[template const arg] Deduction of constant arguments to</h4>
<div class="literalblock">
<div class="content">
<pre>function templates</pre>
</div>
</div>
<div class="paragraph">
<p>Template function type deduction should omit top-level
 constness. However, this code fragment instantiates "f&lt;const
 int&gt;(int)":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">template&lt;class T&gt;
void f(T x)
{
        x = 1;  // works
        (void) &amp;x;
        T y = 17;
        y = 20;  // "Cannot modify a const object in function f&lt;const int&gt;(int)"
        (void) &amp;y;
}

int main()
{
        const int i = 17;
        f(i);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="function-address-resolving-addresses-of-overloaded"><a class="anchor" href="#function-address-resolving-addresses-of-overloaded"></a>[function address] Resolving addresses of overloaded</h4>
<div class="literalblock">
<div class="content">
<pre>functions</pre>
</div>
</div>
<div class="paragraph">
<p>Addresses of overloaded functions are not in all contexts
 properly resolved (std:13.4 [over.over]); here is a small
 example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">template&lt;class Arg&gt;
void f( void(\*g)(Arg) );

void h(int);
void h(double);

template&lt;class T&gt;
void h2(T);

int main()
{
  void (\*p)(int) = h;            // this works (std:13.4-1.1)
  void (\*p2)(unsigned char) = h2;    // this works as well (std:13.4-1.1)
  f&lt;int&gt;(h2);  // this also works (std:13.4-1.3)

  // "Cannot generate template specialization from h(int)",
  // "Could not find a match for f&lt;Arg&gt;(void (\*)(int))"
  f&lt;double&gt;(h);   // should work (std:13.4-1.3)

  f( (void(\*)(double))h);  // C-style cast works (std:13.4-1.6 with 5.4)

  // "Overloaded 'h' ambiguous in this context"
  f(static\_cast&lt;void(\*)(double)&gt;(h)); // should work (std:13.4-1.6 with 5.2.9)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Workaround:</strong> Always use C-style casts when
 determining addresses of (potentially) overloaded
 functions.</p>
</div>
</div>
<div class="sect3">
<h4 id="string-conversion-converting-const-char-to"><a class="anchor" href="#string-conversion-converting-const-char-to"></a>[string conversion] Converting <code>const char *</code> to</h4>
<div class="literalblock">
<div class="content">
<pre>`std::string`</pre>
</div>
</div>
<div class="paragraph">
<p>Implicitly converting <code>const char *</code> parameters
 to <code>std::string</code> arguments fails if template
 functions are explicitly instantiated (it works in the usual
 cases, though):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">#include &lt;string&gt;

template&lt;class T&gt;
void f(const std::string &amp; s)
{}

int main()
{
  f&lt;double&gt;("hello");  // "Could not find a match for f&lt;T&gt;(char \*)"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Workaround:</strong> Avoid explicit template
 function instantiations (they have significant problems with
 Microsoft Visual C++) and pass default-constructed unused dummy
 arguments with the appropriate type. Alternatively, if you wish
 to keep to the explicit instantiation, you could use an
 explicit conversion to <code>std::string</code> or declare the
 template function as taking a <code>const char *</code>
 parameter.</p>
</div>
</div>
<div class="sect3">
<h4 id="template-value-defaults-dependent-default-arguments-for"><a class="anchor" href="#template-value-defaults-dependent-default-arguments-for"></a>[template value defaults] Dependent default arguments for</h4>
<div class="literalblock">
<div class="content">
<pre>template value parameters</pre>
</div>
</div>
<div class="paragraph">
<p>Template value parameters which default to an expression
 dependent on previous template parameters don&#8217;t work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">template&lt;class T&gt;
struct A
{
  static const bool value = true;
};

// "Templates must be classes or functions", "Declaration syntax error"
template&lt;class T, bool v = A&lt;T&gt;::value&gt;
struct B {};

int main()
{
  B&lt;int&gt; x;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Workaround:</strong> If the relevant non-type
 template parameter is an implementation detail, use inheritance
 and a fully qualified identifier (for example,
 ::N::A&lt;T&gt;::value).</p>
</div>
</div>
<div class="sect3">
<h4 id="function-partial-ordering-partial-ordering-of-function"><a class="anchor" href="#function-partial-ordering-partial-ordering-of-function"></a>[function partial ordering] Partial ordering of function</h4>
<div class="literalblock">
<div class="content">
<pre>templates</pre>
</div>
</div>
<div class="paragraph">
<p>Partial ordering of function templates, as described in
 std:14.5.5.2 [temp.func.order], does not work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">#include &lt;iostream&gt;

template&lt;class T&gt; struct A {};

template&lt;class T1&gt;
void f(const A&lt;T1&gt; &amp;)
{
  std::cout &lt;&lt; "f(const A&lt;T1&gt;&amp;)\n";
}

template&lt;class T&gt;
void f(T)
{
  std::cout &lt;&lt; "f(T)\n";
}

int main()
{
  A&lt;double&gt; a;
  f(a);   // output: f(T)  (wrong)
  f(1);   // output: f(T)  (correct)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Workaround:</strong> Declare all such functions
 uniformly as either taking a value or a reference
 parameter.</p>
</div>
</div>
<div class="sect3">
<h4 id="instantiate-memfun-ptr-instantiation-with-member-function"><a class="anchor" href="#instantiate-memfun-ptr-instantiation-with-member-function"></a>[instantiate memfun ptr] Instantiation with member function</h4>
<div class="literalblock">
<div class="content">
<pre>pointer</pre>
</div>
</div>
<div class="paragraph">
<p>When directly instantiating a template with some member
 function pointer, which is itself dependent on some template
 parameter, the compiler cannot cope:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">template&lt;class U&gt; class C { };
template&lt;class T&gt;
class A
{
  static const int v = C&lt;void (T::\*)()&gt;::value;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Workaround:</strong> Use an intermediate
 <code>typedef</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">template&lt;class U&gt; class C { };
template&lt;class T&gt;
class A
{
  typedef void (T::\*my\_type)();
  static const int v = C&lt;my\_type&gt;::value;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>(Extracted from e-mail exchange of David Abrahams, Fernando
 Cacciola, and Peter Dimov; not actually tested.)</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="library"><a class="anchor" href="#library"></a>Library</h3>
<div class="sect3">
<h4 id="cmath-abs-function-double-stdabsdouble"><a class="anchor" href="#cmath-abs-function-double-stdabsdouble"></a>[cmath.abs] Function <code>double std::abs(double)</code></h4>
<div class="literalblock">
<div class="content">
<pre>missing</pre>
</div>
</div>
<div class="paragraph">
<p>The function <code>double std::abs(double)</code> should be
 defined (std:26.5-5 [lib.c.math]), but it is not:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">#include &lt;cmath&gt;

int main()
{
  double (\*p)(double) = std::abs;  // error
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>int std::abs(int)</code> will be used
 without warning if you write <code>std::abs(5.1)</code>.</p>
</div>
<div class="paragraph">
<p>Similar remarks apply to seemingly all of the other standard
 math functions, where Borland C++ fails to provide
 <code>float</code> and <code>long double</code> overloads.</p>
</div>
<div class="paragraph">
<p><strong>Workaround:</strong> Use <code>std::fabs</code>
 instead if type genericity is not required.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="appendix-additional-issues-with-borland-c-version-5-5"><a class="anchor" href="#appendix-additional-issues-with-borland-c-version-5-5"></a>Appendix: Additional issues with Borland C++ version 5.5</h3>
<div class="paragraph">
<p>These issues are documented mainly for historic reasons. If
 you are still using Borland C++ version 5.5, you are strongly
 encouraged to obtain an upgrade to version 5.5.1, which fixes
 the issues described in this section.</p>
</div>
<div class="sect3">
<h4 id="inline-friend-inline-friend-functions-in-template"><a class="anchor" href="#inline-friend-inline-friend-functions-in-template"></a>[inline friend] Inline friend functions in template</h4>
<div class="literalblock">
<div class="content">
<pre>classes</pre>
</div>
</div>
<div class="paragraph">
<p>If a friend function of some class has not been declared
 before the friend function declaration, the function is
 declared at the namespace scope surrounding the class
 definition. Together with class templates and inline
 definitions of friend functions, the code in the following
 fragment should declare (and define) a non-template function
 "bool N::f(int,int)", which is a friend of class
 N::A&lt;int&gt;. However, Borland C++ v5.5 expects the function
 f to be declared beforehand:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">namespace N {
template&lt;class T&gt;
class A
{
  // "f is not a member of 'N' in function main()"
  friend bool f(T x, T y) { return x &lt; y; }
};
}

int main()
{
  N::A&lt;int&gt; a;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This technique is extensively used in boost/operators.hpp.
 Giving in to the wish of the compiler doesn&#8217;t work in this
 case, because then the "instantiate one template, get lots of
 helper functions at namespace scope" approach doesn&#8217;t work
 anymore. Defining BOOST\_NO\_OPERATORS\_IN\_NAMESPACE (a define
 BOOST\_NO\_INLINE\_FRIENDS\_IN\_CLASS\_TEMPLATES would match this
 case better) works around this problem and leads to another
 one, see [using-template].</p>
</div>
<div class="paragraph">
<p>html)</p>
</div>
<div class="paragraph">
<p>Footer
© 2023 GitHub, Inc.
Footer navigation
Terms
Privacy
Security
Status
Docs
Contact GitHub
Pricing
API
Training
Blog
About
website2022/borland_cpp.html at master · boostorg/website2022</p>
</div>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script id="site-script" src="../../_/js/site.js" data-ui-root-path="../../_"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
  </body>
</html>
