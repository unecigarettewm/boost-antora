<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Reference :: Boost Libraries Documentation</title>
    <link rel="canonical" href="https://antora.cppalliance.org/unordered/unordered/ref.html">
    <meta name="generator" content="Antora 3.1.2">
    <link rel="stylesheet" href="../../_/css/site.css">
    <script>var uiRootPath = '../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <button class="site-logo"></button>
      <a class="site-name" href="https://antora.cppalliance.org">Boost</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-tabs">
        <a class="navbar-item" href="#">News</a>
        <a class="navbar-item" href="#">Learn</a>
        <a class="navbar-item" href="#">Community</a>
        <a class="navbar-item" href="#">Libraries</a>
        <a class="navbar-item" href="#">Releases</a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="unordered" data-version="">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" title="Toggle expand/collapse all"></button>
    <h3 class="title"><a href="../index.html">Boost.Unordered</a></h3>
    <ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="intro.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="buckets.html">The Data Structure</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="hash_equality.html">Equality Predicates and Hash Functions</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="comparison.html">Comparison with Associative Containers</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="compliance.html">Standard Compliance</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="benchmarks.html">Benchmarks</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="rationale.html">Implementation Rationale</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Reference</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="hash_traits.html"><code>hash_traits</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="unordered_flat_map.html"><code>unordered_flat_map</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="unordered_flat_set.html"><code>unordered_flat_set</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="unordered_map.html"><code>unordered_map</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="unordered_multimap.html"><code>unordered_multimap</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="unordered_multiset.html"><code>unordered_multiset</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="unordered_node_map.html"><code>unordered_node_map</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="unordered_node_set.html"><code>unordered_node_set</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="unordered_set.html"><code>unordered_set</code></a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="changes.html">Change Log</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="bibliography.html">Bibliography</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="copyright.html">Copyright and License</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
    </div>
  </aside>
</div>
   
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Boost.Unordered</a></li>
    <li><a href="ref.html">Reference</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/vinniefalco/unordered/edit/develop/antora/modules/ROOT/pages/unordered/ref.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Reference</h1>
<div class="sect1">
<h2 id="unordered_map"><a class="anchor" href="#unordered_map"></a>Class template unordered_map</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>boost::unordered_map</code> â€” An unordered associative container that associates unique keys with another value.</p>
</div>
<div class="sect2">
<h3 id="unordered_map_synopsis"><a class="anchor" href="#unordered_map_synopsis"></a>Synopsis</h3>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/unordered_map.hpp&gt;

namespace boost {
  template&lt;class Key,
           class T,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
  class unordered_map {
  public:
    // types
    using key_type             = Key;
    using mapped_type          = T;
    using value_type           = std::pair&lt;const Key, T&gt;;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename boost::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename boost::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = <em>implementation-defined</em>;
    using difference_type      = <em>implementation-defined</em>;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;
    using local_iterator       = <em>implementation-defined</em>;
    using const_local_iterator = <em>implementation-defined</em>;
    using node_type            = <em>implementation-defined</em>;
    using insert_return_type   = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_map_default_constructor">unordered_map</a>();
    explicit <a href="#unordered_map_bucket_count_constructor">unordered_map</a>(size_type n,
                           const hasher&amp; hf = hasher(),
                           const key_equal&amp; eql = key_equal(),
                           const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_map_iterator_range_constructor">unordered_map</a>(InputIterator f, InputIterator l,
                    size_type n = <em>implementation-defined</em>,
                    const hasher&amp; hf = hasher(),
                    const key_equal&amp; eql = key_equal(),
                    const allocator_type&amp; a = allocator_type());
    <a href="#unordered_map_copy_constructor">unordered_map</a>(const unordered_map&amp; other);
    <a href="#unordered_map_move_constructor">unordered_map</a>(unordered_map&amp;&amp; other);
    template&lt;class InputIterator&gt;
      <a href="#unordered_map_iterator_range_constructor_with_allocator">unordered_map</a>(InputIterator f, InputIterator l, const allocator_type&amp; a);
    explicit <a href="#unordered_map_allocator_constructor">unordered_map</a>(const Allocator&amp; a);
    <a href="#unordered_map_copy_constructor_with_allocator">unordered_map</a>(const unordered_map&amp; other, const Allocator&amp; a);
    <a href="#unordered_map_move_constructor_with_allocator">unordered_map</a>(unordered_map&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_map_initializer_list_constructor">unordered_map</a>(std::initializer_list&lt;value_type&gt; il,
                  size_type n = <em>implementation-defined</em>
                  const hasher&amp; hf = hasher(),
                  const key_equal&amp; eql = key_equal(),
                  const allocator_type&amp; a = allocator_type());
    <a href="#unordered_map_bucket_count_constructor_with_allocator">unordered_map</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_map_bucket_count_constructor_with_hasher_and_allocator">unordered_map</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_map_iterator_range_constructor_with_bucket_count_and_allocator">unordered_map</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_map_iterator_range_constructor_with_bucket_count_and_hasher">unordered_map</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                    const allocator_type&amp; a);
    <a href="#unordered_map_initializer_list_constructor_with_allocator">unordered_map</a>(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);
    <a href="#unordered_map_initializer_list_constructor_with_bucket_count_and_allocator">unordered_map</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a);
    <a href="#unordered_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_map</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                  const allocator_type&amp; a);
    <a href="#unordered_map_destructor">~unordered_map</a>();
    unordered_map&amp; <a href="#unordered_map_copy_assignment">operator=</a>(const unordered_map&amp; other);
    unordered_map&amp; <a href="#unordered_map_move_assignment">operator=</a>(unordered_map&amp;&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Pred&gt;);
    unordered_map&amp; <a href="#unordered_map_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt;);
    allocator_type <a href="#unordered_map_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_map_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_map_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_map_end">end</a>() noexcept;
    const_iterator <a href="#unordered_map_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_map_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_map_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_map_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_map_size">size</a>() const noexcept;
    size_type <a href="#unordered_map_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_map_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_map_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_map_copy_insert">insert</a>(const value_type&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_map_move_insert">insert</a>(value_type&amp;&amp; obj);
    template&lt;class P&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_map_emplace_insert">insert</a>(P&amp;&amp; obj);
    iterator       <a href="#unordered_map_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator       <a href="#unordered_map_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    template&lt;class P&gt; iterator <a href="#unordered_map_emplace_insert_with_hint">insert</a>(const_iterator hint, P&amp;&amp; obj);
    template&lt;class InputIterator&gt; void <a href="#unordered_map_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_map_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt;);

    template&lt;class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_map_try_emplace">try_emplace</a>(const key_type&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_map_try_emplace">try_emplace</a>(key_type&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class K, class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_map_try_emplace">try_emplace</a>(K&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      iterator <a href="#unordered_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, const key_type&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      iterator <a href="#unordered_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, key_type&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class K, class... Args&gt;
      iterator <a href="#unordered_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, K&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_map_insert_or_assign">insert_or_assign</a>(const key_type&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_map_insert_or_assign">insert_or_assign</a>(key_type&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class K, class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_map_insert_or_assign">insert_or_assign</a>(K&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      iterator <a href="#unordered_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, const key_type&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      iterator <a href="#unordered_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, key_type&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class K, class M&gt;
      iterator <a href="#unordered_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, K&amp;&amp; k, M&amp;&amp; obj);

    node_type <a href="#unordered_map_extract_by_iterator">extract</a>(const_iterator position);
    node_type <a href="#unordered_map_extract_by_key">extract</a>(const key_type&amp; k);
    template&lt;class K&gt; node_type <a href="#unordered_map_extract_by_key">extract</a>(K&amp;&amp; k);
    insert_return_type <a href="#unordered_map_insert_with_node_handle">insert</a>(node_type&amp;&amp; nh);
    iterator           <a href="#unordered_map_insert_with_hint_and_node_handle">insert</a>(const_iterator hint, node_type&amp;&amp; nh);

    iterator  <a href="#unordered_map_erase_by_position">erase</a>(iterator position);
    iterator  <a href="#unordered_map_erase_by_position">erase</a>(const_iterator position);
    size_type <a href="#unordered_map_erase_by_key">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_map_erase_by_key">erase</a>(K&amp;&amp; k);
    iterator  <a href="#unordered_map_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_map_quick_erase">quick_erase</a>(const_iterator position);
    void      <a href="#unordered_map_erase_return_void">erase_return_void</a>(const_iterator position);
    void      <a href="#unordered_map_swap">swap</a>(unordered_map&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Pred&gt;);
    void      <a href="#unordered_map_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_map_merge">merge</a>(unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_map_merge">merge</a>(unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_map_merge">merge</a>(unordered_multimap&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_map_merge">merge</a>(unordered_multimap&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_map_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_map_key_eq">key_eq</a>() const;

    // map operations
    iterator         <a href="#unordered_map_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_map_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_map_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_map_find">find</a>(const K&amp; k) const;
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      iterator       <a href="#unordered_map_find">find</a>(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                          CompatiblePredicate const&amp; eq);
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      const_iterator <a href="#unordered_map_find">find</a>(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                          CompatiblePredicate const&amp; eq) const;
    size_type        <a href="#unordered_map_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_map_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_map_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_map_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_map_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_map_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_map_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_map_equal_range">equal_range</a>(const K&amp; k) const;

    // element access
    mapped_type&amp; <a href="#unordered_map_operator">operator[]</a>(const key_type&amp; k);
    mapped_type&amp; <a href="#unordered_map_operator">operator[]</a>(key_type&amp;&amp; k);
    template&lt;class K&gt; mapped_type&amp; <a href="#unordered_map_operator">operator[]</a>(K&amp;&amp; k);
    mapped_type&amp; <a href="#unordered_map_at">at</a>(const key_type&amp; k);
    const mapped_type&amp; <a href="#unordered_map_at">at</a>(const key_type&amp; k) const;
    template&lt;class K&gt; mapped_type&amp; <a href="#unordered_map_at">at</a>(const K&amp; k);
    template&lt;class K&gt; const mapped_type&amp; <a href="#unordered_map_at">at</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_map_bucket_count">bucket_count</a>() const noexcept;
    size_type <a href="#unordered_map_max_bucket_count">max_bucket_count</a>() const noexcept;
    size_type <a href="#unordered_map_bucket_size">bucket_size</a>(size_type n) const;
    size_type <a href="#unordered_map_bucket">bucket</a>(const key_type&amp; k) const;
    template&lt;class K&gt; size_type <a href="#unordered_map_bucket">bucket</a>(const K&amp; k) const;
    local_iterator <a href="#unordered_map_begin_2">begin</a>(size_type n);
    const_local_iterator <a href="#unordered_map_begin_2">begin</a>(size_type n) const;
    local_iterator <a href="#unordered_map_end_2">end</a>(size_type n);
    const_local_iterator <a href="#unordered_map_end_2">end</a>(size_type n) const;
    const_local_iterator <a href="#unordered_map_cbegin_2">cbegin</a>(size_type n) const;
    const_local_iterator <a href="#unordered_map_cend_2">cend</a>(size_type n) const;

    // hash policy
    float <a href="#unordered_map_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_map_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_map_set_max_load_factor">max_load_factor</a>(float z);
    void <a href="#unordered_map_rehash">rehash</a>(size_type n);
    void <a href="#unordered_map_reserve">reserve</a>(size_type n);
  };

  // Deduction Guides
  template&lt;class InputIterator,
           class Hash = boost::hash&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
           class Pred = std::equal_to&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
           class Allocator = std::allocator&lt;<a href="#unordered_map_iter_to_alloc_type"><em>iter-to-alloc-type</em></a>&lt;InputIterator&gt;&gt;&gt;
    unordered_map(InputIterator, InputIterator, typename <a href="#unordered_map_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_map_deduction_guides"><em>see below</em></a>,
                  Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_map&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;, Hash, Pred,
                       Allocator&gt;;

  template&lt;class Key, class T, class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
    unordered_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;,
                  typename <a href="#unordered_map_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_map_deduction_guides"><em>see below</em></a>, Hash = Hash(),
                  Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_map&lt;Key, T, Hash, Pred, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_map(InputIterator, InputIterator, typename <a href="#unordered_map_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_map&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;,
                       boost::hash&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
                       std::equal_to&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_map(InputIterator, InputIterator, Allocator)
      -&gt; unordered_map&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;,
                       boost::hash&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
                       std::equal_to&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Hash, class Allocator&gt;
    unordered_map(InputIterator, InputIterator, typename <a href="#unordered_map_deduction_guides"><em>see below</em></a>::size_type, Hash, Allocator)
      -&gt; unordered_map&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;, Hash,
                       std::equal_to&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Allocator&gt;
    unordered_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, typename <a href="#unordered_map_deduction_guides"><em>see below</em></a>::size_type,
                  Allocator)
      -&gt; unordered_map&lt;Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Allocator&gt;
    unordered_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, Allocator)
      -&gt; unordered_map&lt;Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Hash, class Allocator&gt;
    unordered_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, typename <a href="#unordered_map_deduction_guides"><em>see below</em></a>::size_type, Hash,
                  Allocator)
      -&gt; unordered_map&lt;Key, T, Hash, std::equal_to&lt;Key&gt;, Allocator&gt;;

  // Equality Comparisons
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_map_operator_2">operator==</a>(const unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_map_operator_3">operator!=</a>(const unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  // swap
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    void <a href="#unordered_map_swap_2">swap</a>(unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
              unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
    typename unordered_map&lt;K, T, H, P, A&gt;::size_type
       <a href="#unordered_map_erase_if">erase_if</a>(unordered_map&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_map_description"><a class="anchor" href="#unordered_map_description"></a>Description</h3>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Key</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container (i.e. <code>allocator_traits</code> can destroy it).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>T</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>T</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container (i.e. <code>allocator_traits</code> can destroy it).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that implements an equivalence relation on values of type <code>Key</code>. A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type bool.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket.</p>
</div>
<div class="paragraph">
<p>The number of buckets can be automatically increased by a call to insert, or as the result of calling rehash.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_map_typedefs"><a class="anchor" href="#unordered_map_typedefs"></a>Typedefs</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef typename allocator_type::pointer pointer;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>value_type*</code> if <code>allocator_type::pointer</code> is not defined.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef typename allocator_type::const_pointer const_pointer;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>boost::pointer_to_other&lt;pointer, value_type&gt;::type</code> if <code>allocator_type::const_pointer</code> is not defined.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> size_type;</code></pre>
</div>
</div>
<div class="paragraph">
<p>An unsigned integral type.</p>
</div>
<div class="paragraph">
<p><code>size_type</code> can represent any non-negative value of <code>difference_type</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> difference_type;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A signed integral type.</p>
</div>
<div class="paragraph">
<p>Is identical to the difference type of <code>iterator</code> and <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> iterator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> const_iterator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> local_iterator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator with the same value type, difference type and pointer and reference type as iterator.</p>
</div>
<div class="paragraph">
<p>A <code>local_iterator</code> object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> const_local_iterator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator with the same value type, difference type and pointer and reference type as const_iterator.</p>
</div>
<div class="paragraph">
<p>A const_local_iterator object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> node_type;</code></pre>
</div>
</div>
<div class="paragraph">
<p>See node_handle_map for details.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> insert_return_type;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Structure returned by inserting node_type.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_map_constructors"><a class="anchor" href="#unordered_map_constructors"></a>Constructors</h3>
<div class="sect3">
<h4 id="unordered_map_default_constructor"><a class="anchor" href="#unordered_map_default_constructor"></a>Default Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_map();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate, <code>allocator_type()</code> as the allocator
and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_bucket_count_constructor"><a class="anchor" href="#unordered_map_bucket_count_constructor"></a>Bucket Count Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">explicit unordered_map(size_type n,
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum
load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_iterator_range_constructor"><a class="anchor" href="#unordered_map_iterator_range_constructor"></a>Iterator Range Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
  unordered_map(InputIterator f, InputIterator l,
                size_type n = <em>implementation-defined</em>,
                const hasher&amp; hf = hasher(),
                const key_equal&amp; eql = key_equal(),
                const allocator_type&amp; a = allocator_type());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_copy_constructor"><a class="anchor" href="#unordered_map_copy_constructor"></a>Copy Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_map(unordered_map const&amp; other);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_move_constructor"><a class="anchor" href="#unordered_map_move_constructor"></a>Move Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_map(unordered_map&amp;&amp; other);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move-constructible.<br></p>
<div class="paragraph">
<p>On compilers without rvalue reference support the emulation does not support moving without calling <code>boost::move</code> if <code>value_type</code> is not copyable.
So, for example, you can&#8217;t return the container from a function.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_iterator_range_constructor_with_allocator"><a class="anchor" href="#unordered_map_iterator_range_constructor_with_allocator"></a>Iterator Range Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
  unordered_map(InputIterator f, InputIterator l, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_allocator_constructor"><a class="anchor" href="#unordered_map_allocator_constructor"></a>Allocator Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">explicit unordered_map(Allocator const&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_copy_constructor_with_allocator"><a class="anchor" href="#unordered_map_copy_constructor_with_allocator"></a>Copy Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_map(unordered_map const&amp; other, Allocator const&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an container, copying <code>other</code>'s contained elements, hash function, predicate, maximum load factor, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_move_constructor_with_allocator"><a class="anchor" href="#unordered_map_move_constructor_with_allocator"></a>Move Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_map(unordered_map&amp;&amp; other, Allocator const&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Construct a container moving <code>other</code>'s contained elements, and having the hash function, predicate and maximum load factor, but using allocate <code>a</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move insertable.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_initializer_list_constructor"><a class="anchor" href="#unordered_map_initializer_list_constructor"></a>Initializer List Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_map(std::initializer_list&lt;value_type&gt; il,
              size_type n = <em>implementation-defined</em>
              const hasher&amp; hf = hasher(),
              const key_equal&amp; eql = key_equal(),
              const allocator_type&amp; a = allocator_type());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_bucket_count_constructor_with_allocator"><a class="anchor" href="#unordered_map_bucket_count_constructor_with_allocator"></a>Bucket Count Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_map(size_type n, allocator_type const&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_bucket_count_constructor_with_hasher_and_allocator"><a class="anchor" href="#unordered_map_bucket_count_constructor_with_hasher_and_allocator"></a>Bucket Count Constructor with Hasher and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_map(size_type n, hasher const&amp; hf, allocator_type const&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_iterator_range_constructor_with_bucket_count_and_allocator"><a class="anchor" href="#unordered_map_iterator_range_constructor_with_bucket_count_and_allocator"></a>Iterator Range Constructor with Bucket Count and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
  unordered_map(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_iterator_range_constructor_with_bucket_count_and_hasher"><a class="anchor" href="#unordered_map_iterator_range_constructor_with_bucket_count_and_hasher"></a>Iterator Range Constructor with Bucket Count and Hasher</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">    template&lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                    const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_initializer_list_constructor_with_allocator"><a class="anchor" href="#unordered_map_initializer_list_constructor_with_allocator"></a>initializer_list Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_map(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_initializer_list_constructor_with_bucket_count_and_allocator"><a class="anchor" href="#unordered_map_initializer_list_constructor_with_bucket_count_and_allocator"></a>initializer_list Constructor with Bucket Count and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_map(std::initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="anchor" href="#unordered_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"></a>initializer_list Constructor with Bucket Count and Hasher and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_map(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
              const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_map_destructor"><a class="anchor" href="#unordered_map_destructor"></a>Destructor</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">~unordered_map();</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_map_assignment"><a class="anchor" href="#unordered_map_assignment"></a>Assignment</h3>
<div class="sect3">
<h4 id="unordered_map_copy_assignment"><a class="anchor" href="#unordered_map_copy_assignment"></a>Copy Assignment</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_map&amp; operator=(unordered_map const&amp; other);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the copied elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_move_assignment"><a class="anchor" href="#unordered_map_move_assignment"></a>Move Assignment</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_map&amp; operator=(unordered_map&amp;&amp; other)
  noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
           boost::is_nothrow_move_assignable_v&lt;Hash&gt; &amp;&amp;
           boost::is_nothrow_move_assignable_v&lt;Pred&gt;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the moved elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>On compilers without rvalue references, this is emulated using Boost.Move. Note that on some compilers the copy assignment operator may be used in some circumstances.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move constructible.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_initializer_list_assignment"><a class="anchor" href="#unordered_map_initializer_list_assignment"></a>Initializer List Assignment</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_map&amp; operator=(std::initializer_list&lt;value_type&gt; il);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All existing elements are either overwritten by the new elements or destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a> into the container and <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable" target="_blank" rel="noopener">CopyAssignable</a>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_map_iterators"><a class="anchor" href="#unordered_map_iterators"></a>Iterators</h3>
<div class="sect3">
<h4 id="unordered_map_begin"><a class="anchor" href="#unordered_map_begin"></a>begin</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator begin() noexcept;
const_iterator begin() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_end"><a class="anchor" href="#unordered_map_end"></a>end</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator end() noexcept;
const_iterator end() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_cbegin"><a class="anchor" href="#unordered_map_cbegin"></a>cbegin</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">const_iterator cbegin() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_cend"><a class="anchor" href="#unordered_map_cend"></a>cend</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">const_iterator cend() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_map_size_and_capacity"><a class="anchor" href="#unordered_map_size_and_capacity"></a>Size and Capacity</h3>
<div class="sect3">
<h4 id="unordered_map_empty"><a class="anchor" href="#unordered_map_empty"></a>empty</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">[[nodiscard]] bool empty() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_size"><a class="anchor" href="#unordered_map_size"></a>size</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type size() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_max_size"><a class="anchor" href="#unordered_map_max_size"></a>max_size</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type max_size() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_map_modifiers"><a class="anchor" href="#unordered_map_modifiers"></a>Modifiers</h3>
<div class="sect3">
<h4 id="unordered_map_emplace"><a class="anchor" href="#unordered_map_emplace"></a>emplace</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class... Args&gt; std::pair&lt;iterator, bool&gt; emplace(Args&amp;&amp;... args);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to <code>10</code> arguments, with no support for rvalue references or move semantics.<br></p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_emplace_hint"><a class="anchor" href="#unordered_map_emplace_hint"></a>emplace_hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">    template&lt;class... Args&gt; iterator emplace_hint(const_iterator position, Args&amp;&amp;... args);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>position</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to 10 arguments, with no support for rvalue references or move semantics.<br></p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_copy_insert"><a class="anchor" href="#unordered_map_copy_insert"></a>Copy Insert</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::pair&lt;iterator, bool&gt; insert(const value_type&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_move_insert"><a class="anchor" href="#unordered_map_move_insert"></a>Move Insert</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::pair&lt;iterator, bool&gt; insert(value_type&amp;&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_emplace_insert"><a class="anchor" href="#unordered_map_emplace_insert"></a>Emplace Insert</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class P&gt; std::pair&lt;iterator, bool&gt; insert(P&amp;&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element into the container by performing <code>emplace(std::forward&lt;P&gt;(value))</code>.</p>
</div>
<div class="paragraph">
<p>Only participates in overload resolution if <code>std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value</code> is <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_copy_insert_with_hint"><a class="anchor" href="#unordered_map_copy_insert_with_hint"></a>Copy Insert with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(const_iterator hint, const value_type&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_move_insert_with_hint"><a class="anchor" href="#unordered_map_move_insert_with_hint"></a>Move Insert with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(const_iterator hint, value_type&amp;&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_emplace_insert_with_hint"><a class="anchor" href="#unordered_map_emplace_insert_with_hint"></a>Emplace Insert with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class P&gt; iterator insert(const_iterator hint, P&amp;&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element into the container by performing <code>emplace_hint(hint, std::forward&lt;P&gt;(value))</code>.</p>
</div>
<div class="paragraph">
<p>Only participates in overload resolution if <code>std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value</code> is <code>true</code>.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_insert_iterator_range"><a class="anchor" href="#unordered_map_insert_iterator_range"></a>Insert Iterator Range</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt; void insert(InputIterator first, InputIterator last);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_insert_initializer_list"><a class="anchor" href="#unordered_map_insert_initializer_list"></a>Insert Initializer List</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void insert(std::initializer_list&lt;value_type&gt;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_try_emplace"><a class="anchor" href="#unordered_map_try_emplace"></a>try_emplace</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class... Args&gt;
  std::pair&lt;iterator, bool&gt; try_emplace(const key_type&amp; k, Args&amp;&amp;... args);
template&lt;class... Args&gt;
  std::pair&lt;iterator, bool&gt; try_emplace(key_type&amp;&amp; k, Args&amp;&amp;... args);
template &lt;class K, class... Args&gt;
  std::pair&lt;iterator, bool&gt; try_emplace(K&amp;&amp; k, Args&amp;&amp;... args)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new node into the container if there is no existing element with key <code>k</code> contained within it.</p>
</div>
<div class="paragraph">
<p>If there is an existing element with key <code>k</code> this function does nothing.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This function is similiar to <a href="#unordered_map_emplace">emplace</a> except the <code>value_type</code> is constructed using:<br></p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">// first two overloads
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward&lt;Key&gt;(k)),
           std::forward_as_tuple(boost::forward&lt;Args&gt;(args)...))

// third overload
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward&lt;K&gt;(k)),
           std::forward_as_tuple(boost::forward&lt;Args&gt;(args)...))</code></pre>
</div>
</div>
<div class="paragraph">
<p>instead of <a href="#unordered_map_emplace">emplace</a> which simply forwards all arguments to <code>value_type</code>'s constructor.</p>
</div>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.</p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
<div class="paragraph">
<p>The <code>template &lt;class K, class&#8230;&#8203; Args&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to <code>10</code> arguments, with no support for rvalue references or move semantics.</p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_try_emplace_with_hint"><a class="anchor" href="#unordered_map_try_emplace_with_hint"></a>try_emplace with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class... Args&gt;
  iterator try_emplace(const_iterator hint, const key_type&amp; k, Args&amp;&amp;... args);
template&lt;class... Args&gt;
  iterator try_emplace(const_iterator hint, key_type&amp;&amp; k, Args&amp;&amp;... args);
template&lt;class K, class... Args&gt;
  iterator try_emplace(const_iterator hint, K&amp;&amp; k, Args&amp;&amp;... args);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new node into the container if there is no existing element with key <code>k</code> contained within it.</p>
</div>
<div class="paragraph">
<p>If there is an existing element with key <code>k</code> this function does nothing.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This function is similiar to <a href="#unordered_map_emplace_hint">emplace_hint</a> except the <code>value_type</code> is constructed using:<br></p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">// first two overloads
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward&lt;Key&gt;(k)),
           std::forward_as_tuple(boost::forward&lt;Args&gt;(args)...))

// third overload
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward&lt;K&gt;(k)),
           std::forward_as_tuple(boost::forward&lt;Args&gt;(args)...))</code></pre>
</div>
</div>
<div class="paragraph">
<p>instead of <a href="#unordered_map_emplace_hint">emplace_hint</a> which simply forwards all arguments to <code>value_type</code>'s constructor.</p>
</div>
<div class="paragraph">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.</p>
</div>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.</p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
<div class="paragraph">
<p>The <code>template &lt;class K, class&#8230;&#8203; Args&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to <code>10</code> arguments, with no support for rvalue references or move semantics.</p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_insert_or_assign"><a class="anchor" href="#unordered_map_insert_or_assign"></a>insert_or_assign</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class M&gt;
  std::pair&lt;iterator, bool&gt; insert_or_assign(const key_type&amp; k, M&amp;&amp; obj);
template&lt;class M&gt;
  std::pair&lt;iterator, bool&gt; insert_or_assign(key_type&amp;&amp; k, M&amp;&amp; obj);
template&lt;class K, class M&gt;
  std::pair&lt;iterator, bool&gt; insert_or_assign(K&amp;&amp; k, M&amp;&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the container or updates an existing one by assigning to the contained value.</p>
</div>
<div class="paragraph">
<p>If there is an element with key <code>k</code>, then it is updated by assigning <code>boost::forward&lt;M&gt;(obj)</code>.</p>
</div>
<div class="paragraph">
<p>If there is no such element, it is added to the container as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">// first two overloads
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward&lt;Key&gt;(k)),
           std::forward_as_tuple(boost::forward&lt;M&gt;(obj)))

// third overload
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward&lt;K&gt;(k)),
           std::forward_as_tuple(boost::forward&lt;M&gt;(obj)))</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>The <code>template&lt;class K, class M&gt;</code> only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_insert_or_assign_with_hint"><a class="anchor" href="#unordered_map_insert_or_assign_with_hint"></a>insert_or_assign with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class M&gt;
  iterator insert_or_assign(const_iterator hint, const key_type&amp; k, M&amp;&amp; obj);
template&lt;class M&gt;
  iterator insert_or_assign(const_iterator hint, key_type&amp;&amp; k, M&amp;&amp; obj);
template&lt;class K, class M&gt;
  iterator insert_or_assign(const_iterator hint, K&amp;&amp; k, M&amp;&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the container or updates an existing one by assigning to the contained value.</p>
</div>
<div class="paragraph">
<p>If there is an element with key <code>k</code>, then it is updated by assigning <code>boost::forward&lt;M&gt;(obj)</code>.</p>
</div>
<div class="paragraph">
<p>If there is no such element, it is added to the container as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">// first two overloads
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward&lt;Key&gt;(k)),
           std::forward_as_tuple(boost::forward&lt;M&gt;(obj)))

// third overload
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward&lt;K&gt;(k)),
           std::forward_as_tuple(boost::forward&lt;M&gt;(obj)))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>The <code>template&lt;class K, class M&gt;</code> only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_extract_by_iterator"><a class="anchor" href="#unordered_map_extract_by_iterator"></a>Extract by Iterator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">node_type extract(const_iterator position);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_multimap</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_extract_by_key"><a class="anchor" href="#unordered_map_extract_by_key"></a>Extract by Key</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">node_type extract(const key_type&amp; k);
template&lt;class K&gt; node_type extract(K&amp;&amp; k);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes an element with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element if found, otherwise an empty <code>node_type</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_multimap</code>.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K&gt;</code>  overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_insert_with_node_handle"><a class="anchor" href="#unordered_map_insert_with_node_handle"></a>Insert with <code>node_handle</code></h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">insert_return_type insert(node_type&amp;&amp; nh);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code> if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty, returns an <code>insert_return_type</code> with: <code>inserted</code> equal to <code>false</code>, <code>position</code> equal to <code>end()</code> and <code>node</code> empty.<br></p>
<div class="paragraph">
<p>Otherwise if there was already an element with an equivalent key, returns an <code>insert_return_type</code> with: <code>inserted</code> equal to <code>false</code>, <code>position</code> pointing to a matching element and <code>node</code> contains the node from <code>nh</code>.<br></p>
</div>
<div class="paragraph">
<p>Otherwise if the insertion succeeded, returns an <code>insert_return_type</code> with: <code>inserted</code> equal to <code>true</code>, <code>position</code> pointing to the newly inserted element and <code>node</code> empty.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_multimap</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_insert_with_hint_and_node_handle"><a class="anchor" href="#unordered_map_insert_with_hint_and_node_handle"></a>Insert with Hint and <code>node_handle</code></h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(const_iterator hint, node_type&amp;&amp; nh);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code> if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p>If there is already an element in the container with an equivalent key has no effect on <code>nh</code> (i.e. <code>nh</code> still contains the node.)</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty returns <code>end()</code>.<br></p>
<div class="paragraph">
<p>If there was already an element in the container with an equivalent key returns an iterator pointing to that.<br></p>
</div>
<div class="paragraph">
<p>Otherwise returns an iterator pointing to the newly inserted element.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to hasher the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_multimap</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_erase_by_position"><a class="anchor" href="#unordered_map_erase_by_position"></a>Erase by Position</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator erase(iterator position);
iterator erase(const_iterator position);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following <code>position</code> before the erasure.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In older versions this could be inefficient because it had to search through several buckets to find the position of the returned iterator. The data structure has been changed so that this is no longer the case, and the alternative erase methods have been deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_erase_by_key"><a class="anchor" href="#unordered_map_erase_by_key"></a>Erase by Key</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type erase(const key_type&amp; k);
template&lt;class K&gt; size_type erase(K&amp;&amp; k);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_erase_range"><a class="anchor" href="#unordered_map_erase_range"></a>Erase Range</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator erase(const_iterator first, const_iterator last);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_quick_erase"><a class="anchor" href="#unordered_map_quick_erase"></a>quick_erase</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void quick_erase(const_iterator position);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_erase_return_void"><a class="anchor" href="#unordered_map_erase_return_void"></a>erase_return_void</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void erase_return_void(const_iterator position);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_swap"><a class="anchor" href="#unordered_map_swap"></a>swap</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void swap(unordered_map&amp; other)
  noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
           boost::is_nothrow_swappable_v&lt;Hash&gt; &amp;&amp;
           boost::is_nothrow_swappable_v&lt;Pred&gt;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_clear"><a class="anchor" href="#unordered_map_clear"></a>clear</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void clear();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Never throws an exception.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_merge"><a class="anchor" href="#unordered_map_merge"></a>merge</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class H2, class P2&gt;
  void merge(unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
template&lt;class H2, class P2&gt;
  void merge(unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);
template&lt;class H2, class P2&gt;
  void merge(unordered_multimap&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
template&lt;class H2, class P2&gt;
  void merge(unordered_multimap&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Attempt to "merge" two containers by iterating <code>source</code> and extracting any node in <code>source</code> that is not contained
in <code>*this</code> and then inserting it into <code>*this</code>.</p>
</div>
<div class="paragraph">
<p>Because <code>source</code> can have a different hash function and key equality predicate, the key of each node in
<code>source</code> is rehashed using <code>this-&gt;hash_function()</code> and then, if required, compared using <code>this-&gt;key_eq()</code>.</p>
</div>
<div class="paragraph">
<p>The behavior of this function is undefined if <code>this-&gt;get_allocator() != source.get_allocator()</code>.</p>
</div>
<div class="paragraph">
<p>This function does not copy or move any elements and instead simply relocates the nodes from <code>source</code>
into <code>*this</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Pointers and references to transferred elements remain valid.</p>
</li>
<li>
<p>Invalidates iterators to transferred elements.</p>
</li>
<li>
<p>Invalidates iterators belonging to <code>*this</code>.</p>
</li>
<li>
<p>Iterators to non-transferred elements in <code>source</code> remain valid.</p>
</li>
</ul>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_map_observers"><a class="anchor" href="#unordered_map_observers"></a>Observers</h3>
<div class="sect3">
<h4 id="unordered_map_get_allocator"><a class="anchor" href="#unordered_map_get_allocator"></a>get_allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">allocator_type get_allocator() const;</code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_hash_function"><a class="anchor" href="#unordered_map_hash_function"></a>hash_function</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">hasher hash_function() const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_key_eq"><a class="anchor" href="#unordered_map_key_eq"></a>key_eq</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">key_equal key_eq() const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_map_lookup"><a class="anchor" href="#unordered_map_lookup"></a>Lookup</h3>
<div class="sect3">
<h4 id="unordered_map_find"><a class="anchor" href="#unordered_map_find"></a>find</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator         find(const key_type&amp; k);
const_iterator   find(const key_type&amp; k) const;
template&lt;class K&gt;
  iterator       find(const K&amp; k);
template&lt;class K&gt;
  const_iterator find(const K&amp; k) const;
template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
  iterator       find(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                      CompatiblePredicate const&amp; eq);
template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
  const_iterator find(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                      CompatiblePredicate const&amp; eq) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>b.end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The templated overloads containing <code>CompatibleKey</code>, <code>CompatibleHash</code> and <code>CompatiblePredicate</code> are non-standard extensions which allow you to use a compatible hash function and equality predicate for a key of a different type in order to avoid an expensive type cast. In general, its use is not encouraged and instead the <code>K</code> member function templates should be used.<br></p>
<div class="paragraph">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_count"><a class="anchor" href="#unordered_map_count"></a>count</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type        count(const key_type&amp; k) const;
template&lt;class K&gt;
  size_type      count(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_contains"><a class="anchor" href="#unordered_map_contains"></a>contains</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">bool             contains(const key_type&amp; k) const;
template&lt;class K&gt;
  bool           contains(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_equal_range"><a class="anchor" href="#unordered_map_equal_range"></a>equal_range</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::pair&lt;iterator, iterator&gt;               equal_range(const key_type&amp; k);
std::pair&lt;const_iterator, const_iterator&gt;   equal_range(const key_type&amp; k) const;
template&lt;class K&gt;
  std::pair&lt;iterator, iterator&gt;             equal_range(const K&amp; k);
template&lt;class K&gt;
  std::pair&lt;const_iterator, const_iterator&gt; equal_range(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_operator"><a class="anchor" href="#unordered_map_operator"></a>operator[]</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">mapped_type&amp; operator[](const key_type&amp; k);
mapped_type&amp; operator[](key_type&amp;&amp; k);
template&lt;class K&gt; mapped_type&amp; operator[](K&amp;&amp; k);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>If the container does not already contain an elements with a key equivalent to <code>k</code>, inserts the value <code>std::pair&lt;key_type const, mapped_type&gt;(k, mapped_type())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A reference to <code>x.second</code> where <code>x</code> is the element already in the container, or the newly inserted element with a key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_at"><a class="anchor" href="#unordered_map_at"></a>at</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">mapped_type&amp; at(const key_type&amp; k);
const mapped_type&amp; at(const key_type&amp; k) const;
template&lt;class K&gt; mapped_type&amp; at(const K&amp; k);
template&lt;class K&gt; const mapped_type&amp; at(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A reference to <code>x.second</code> where <code>x</code> is the (unique) element whose key is equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>An exception object of type <code>std::out_of_range</code> if no such element is present.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_map_bucket_interface"><a class="anchor" href="#unordered_map_bucket_interface"></a>Bucket Interface</h3>
<div class="sect3">
<h4 id="unordered_map_bucket_count"><a class="anchor" href="#unordered_map_bucket_count"></a>bucket_count</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type bucket_count() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_max_bucket_count"><a class="anchor" href="#unordered_map_max_bucket_count"></a>max_bucket_count</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type max_bucket_count() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An upper bound on the number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_bucket_size"><a class="anchor" href="#unordered_map_bucket_size"></a>bucket_size</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type bucket_size(size_type n) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n &lt; bucket_count()</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements in bucket <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_bucket"><a class="anchor" href="#unordered_map_bucket"></a>bucket</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type bucket(const key_type&amp; k) const;
template&lt;class K&gt; size_type bucket(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The index of the bucket which would contain an element with key <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p>The return value is less than <code>bucket_count()</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_begin_2"><a class="anchor" href="#unordered_map_begin_2"></a>begin</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">local_iterator begin(size_type n);
const_local_iterator begin(size_type n) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_end_2"><a class="anchor" href="#unordered_map_end_2"></a>end</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">local_iterator end(size_type n);
const_local_iterator end(size_type n) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_cbegin_2"><a class="anchor" href="#unordered_map_cbegin_2"></a>cbegin</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">const_local_iterator cbegin(size_type n) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_cend_2"><a class="anchor" href="#unordered_map_cend_2"></a>cend</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">const_local_iterator cend(size_type n) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_map_hash_policy"><a class="anchor" href="#unordered_map_hash_policy"></a>Hash Policy</h3>
<div class="sect3">
<h4 id="unordered_map_load_factor"><a class="anchor" href="#unordered_map_load_factor"></a>load_factor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">float load_factor() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The average number of elements per bucket.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_max_load_factor"><a class="anchor" href="#unordered_map_max_load_factor"></a>max_load_factor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">float max_load_factor() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the current maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_set_max_load_factor"><a class="anchor" href="#unordered_map_set_max_load_factor"></a>Set max_load_factor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void max_load_factor(float z);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Changes the container&#8217;s maximum load factor, using <code>z</code> as a hint.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_rehash"><a class="anchor" href="#unordered_map_rehash"></a>rehash</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void rehash(size_type n);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes the number of buckets so that there are at least <code>n</code> buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the <code>bucket_count()</code> associated with the container.</p>
</div>
<div class="paragraph">
<p>When <code>size() == 0</code>, <code>rehash(0)</code> will deallocate the underlying buckets array.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_reserve"><a class="anchor" href="#unordered_map_reserve"></a>reserve</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void reserve(size_type n);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>a.rehash(ceil(n / a.max_load_factor()))</code>, or <code>a.rehash(1)</code> if <code>n &gt; 0</code> and <code>a.max_load_factor() == std::numeric_limits&lt;float&gt;::infinity()</code>.</p>
</div>
<div class="paragraph">
<p>Similar to <code>rehash</code>, this function can be used to grow or shrink the number of buckets in the container.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_map_deduction_guides"><a class="anchor" href="#unordered_map_deduction_guides"></a>Deduction Guides</h3>
<div class="paragraph">
<p>A deduction guide will not participate in overload resolution if any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has an <code>InputIterator</code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p>
</li>
<li>
<p>It has an <code>Allocator</code> template parameter and a type that does not qualify as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Hash</code> template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Pred</code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>size_Â­type</code> parameter type in a deduction guide refers to the <code>size_Â­type</code> member type of the
container type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.</p>
</div>
<div class="sect3">
<h4 id="unordered_map_iter_value_type"><a class="anchor" href="#unordered_map_iter_value_type"></a><em>iter-value-type</em></h4>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-value-type</em> =
    typename std::iterator_traits&lt;InputIterator&gt;::value_type; // exposition only</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_iter_key_type"><a class="anchor" href="#unordered_map_iter_key_type"></a><em>iter-key-type</em></h4>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-key-type</em> = std::remove_const_t&lt;
    std::tuple_element_t&lt;0, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;; // exposition only</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_iter_mapped_type"><a class="anchor" href="#unordered_map_iter_mapped_type"></a><em>iter-mapped-type</em></h4>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-mapped-type</em> =
    std::tuple_element_t&lt;1, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;;  // exposition only</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_iter_to_alloc_type"><a class="anchor" href="#unordered_map_iter_to_alloc_type"></a><em>iter-to-alloc-type</em></h4>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-to-alloc-type</em> = std::pair&lt;
    std::add_const_t&lt;std::tuple_element_t&lt;0, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;,
    std::tuple_element_t&lt;1, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;; // exposition only</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_map_equality_comparisons"><a class="anchor" href="#unordered_map_equality_comparisons"></a>Equality Comparisons</h3>
<div class="sect3">
<h4 id="unordered_map_operator_2"><a class="anchor" href="#unordered_map_operator_2"></a>operator==</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
  bool operator==(const unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                  const unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The behavior of this function was changed to match the C++11 standard in Boost 1.48.<br></p>
<div class="paragraph">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_operator_3"><a class="anchor" href="#unordered_map_operator_3"></a>operator!=</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
  bool operator!=(const unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                  const unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The behavior of this function was changed to match the C++11 standard in Boost 1.48.<br></p>
<div class="paragraph">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_map_swap_2"><a class="anchor" href="#unordered_map_swap_2"></a>Swap</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
  void swap(unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
            unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
    noexcept(noexcept(x.swap(y)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_map_erase_if"><a class="anchor" href="#unordered_map_erase_if"></a>erase_if</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
  typename unordered_map&lt;K, T, H, P, A&gt;::size_type
    erase_if(unordered_map&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">auto original_size = c.size();
for (auto i = c.begin(), last = c.end(); i != last; ) {
  if (pred(*i)) {
    i = c.erase(i);
  } else {
    ++i;
  }
}
return original_size - c.size();</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="unordered_multimap"><a class="anchor" href="#unordered_multimap"></a>Class template unordered_multimap</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>boost::unordered_multimap</code> â€” An unordered associative container that associates keys with another value. The same key can be stored multiple times.</p>
</div>
<div class="sect2">
<h3 id="unordered_multimap_synopsis"><a class="anchor" href="#unordered_multimap_synopsis"></a>Synopsis</h3>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/unordered_map.hpp&gt;

namespace boost {
  template&lt;class Key,
           class T,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
  class unordered_multimap {
  public:
    // types
    using key_type             = Key;
    using mapped_type          = T;
    using value_type           = std::pair&lt;const Key, T&gt;;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename boost::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename boost::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = <em>implementation-defined</em>;
    using difference_type      = <em>implementation-defined</em>;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;
    using local_iterator       = <em>implementation-defined</em>;
    using const_local_iterator = <em>implementation-defined</em>;
    using node_type            = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_multimap_default_constructor">unordered_multimap</a>();
    explicit <a href="#unordered_multimap_bucket_count_constructor">unordered_multimap</a>(size_type n,
                                const hasher&amp; hf = hasher(),
                                const key_equal&amp; eql = key_equal(),
                                const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_multimap_iterator_range_constructor">unordered_multimap</a>(InputIterator f, InputIterator l,
                         size_type n = <em>implementation-defined</em>,
                         const hasher&amp; hf = hasher(),
                         const key_equal&amp; eql = key_equal(),
                         const allocator_type&amp; a = allocator_type());
    <a href="#unordered_multimap_copy_constructor">unordered_multimap</a>(const unordered_multimap&amp; other);
    <a href="#unordered_multimap_move_constructor">unordered_multimap</a>(unordered_multimap&amp;&amp; other);
    template&lt;class InputIterator&gt;
      <a href="#unordered_multimap_iterator_range_constructor_with_allocator">unordered_multimap</a>(InputIterator f, InputIterator l, const allocator_type&amp; a);
    explicit <a href="#unordered_multimap_allocator_constructor">unordered_multimap</a>(const Allocator&amp; a);
    <a href="#unordered_multimap_copy_constructor_with_allocator">unordered_multimap</a>(const unordered_multimap&amp; other, const Allocator&amp; a);
    <a href="#unordered_multimap_move_constructor_with_allocator">unordered_multimap</a>(unordered_multimap&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_multimap_initializer_list_constructor">unordered_multimap</a>(std::initializer_list&lt;value_type&gt; il,
                       size_type n = <em>implementation-defined</em>,
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
    <a href="#unordered_multimap_bucket_count_constructor_with_allocator">unordered_multimap</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_multimap_bucket_count_constructor_with_hasher_and_allocator">unordered_multimap</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_multimap_iterator_range_constructor_with_bucket_count_and_allocator">unordered_multimap</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_multimap_iterator_range_constructor_with_bucket_count_and_hasher">unordered_multimap</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                         const allocator_type&amp; a);
    <a href="#unordered_multimap_initializer_list_constructor_with_allocator">unordered_multimap</a>(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);
    <a href="#unordered_multimap_initializer_list_constructor_with_bucket_count_and_allocator">unordered_multimap</a>(std::initializer_list&lt;value_type&gt; il, size_type n,
                       const allocator_type&amp; a);
    <a href="#unordered_multimap_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_multimap</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                       const allocator_type&amp; a);
    <a href="#unordered_multimap_destructor">~unordered_multimap</a>();
    unordered_multimap&amp; <a href="#unordered_multimap_copy_assignment">operator=</a>(const unordered_multimap&amp; other);
    unordered_multimap&amp; <a href="#unordered_multimap_move_assignment">operator=</a>(unordered_multimap&amp;&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Pred&gt;);
    unordered_multimap&amp; <a href="#unordered_multimap_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt; il);
    allocator_type <a href="#unordered_multimap_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_multimap_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_multimap_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_multimap_end">end</a>() noexcept;
    const_iterator <a href="#unordered_multimap_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_multimap_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_multimap_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_multimap_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_multimap_size">size</a>() const noexcept;
    size_type <a href="#unordered_multimap_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; iterator <a href="#unordered_multimap_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_multimap_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    iterator <a href="#unordered_multimap_copy_insert">insert</a>(const value_type&amp; obj);
    iterator <a href="#unordered_multimap_move_insert">insert</a>(value_type&amp;&amp; obj);
    template&lt;class P&gt; iterator <a href="#unordered_multimap_emplace_insert">insert</a>(P&amp;&amp; obj);
    iterator <a href="#unordered_multimap_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator <a href="#unordered_multimap_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    template&lt;class P&gt; iterator <a href="#unordered_multimap_emplace_insert_with_hint">insert</a>(const_iterator hint, P&amp;&amp; obj);
    template&lt;class InputIterator&gt; void <a href="#unordered_multimap_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_multimap_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt; il);

    node_type <a href="#unordered_multimap_extract_by_iterator">extract</a>(const_iterator position);
    node_type <a href="#unordered_multimap_extract_by_key">extract</a>(const key_type&amp; k);
    template&lt;class K&gt; node_type <a href="#unordered_multimap_extract_by_key">extract</a>(K&amp;&amp; k);
    iterator <a href="#unordered_multimap_insert_with_node_handle">insert</a>(node_type&amp;&amp; nh);
    iterator <a href="#unordered_multimap_insert_with_hint_and_node_handle">insert</a>(const_iterator hint, node_type&amp;&amp; nh);

    iterator  <a href="#unordered_multimap_erase_by_position">erase</a>(iterator position);
    iterator  <a href="#unordered_multimap_erase_by_position">erase</a>(const_iterator position);
    size_type <a href="#unordered_multimap_erase_by_key">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_multimap_erase_by_key">erase</a>(K&amp;&amp; k);
    iterator  <a href="#unordered_multimap_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_multimap_quick_erase">quick_erase</a>(const_iterator position);
    void      <a href="#unordered_multimap_erase_return_void">erase_return_void</a>(const_iterator position);
    void      <a href="#unordered_multimap_swap">swap</a>(unordered_multimap&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Pred&gt;);
    void      <a href="#unordered_multimap_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multimap_merge">merge</a>(unordered_multimap&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multimap_merge">merge</a>(unordered_multimap&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multimap_merge">merge</a>(unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multimap_merge">merge</a>(unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_multimap_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_multimap_key_eq">key_eq</a>() const;

    // map operations
    iterator         <a href="#unordered_multimap_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_multimap_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_multimap_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_multimap_find">find</a>(const K&amp; k) const;
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      iterator       <a href="#unordered_multimap_find">find</a>(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                          CompatiblePredicate const&amp; eq);
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      const_iterator <a href="#unordered_multimap_find">find</a>(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                          CompatiblePredicate const&amp; eq) const;
    size_type        <a href="#unordered_multimap_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_multimap_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_multimap_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_multimap_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_multimap_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_multimap_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_multimap_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_multimap_equal_range">equal_range</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_multimap_bucket_count">bucket_count</a>() const noexcept;
    size_type <a href="#unordered_multimap_max_bucket_count">max_bucket_count</a>() const noexcept;
    size_type <a href="#unordered_multimap_bucket_size">bucket_size</a>(size_type n) const;
    size_type <a href="#unordered_multimap_bucket">bucket</a>(const key_type&amp; k) const;
    template&lt;class K&gt; size_type <a href="#unordered_multimap_bucket">bucket</a>(const K&amp; k) const;
    local_iterator <a href="#unordered_multimap_begin_2">begin</a>(size_type n);
    const_local_iterator <a href="#unordered_multimap_begin_2">begin</a>(size_type n) const;
    local_iterator <a href="#unordered_multimap_end_2">end</a>(size_type n);
    const_local_iterator <a href="#unordered_multimap_end_2">end</a>(size_type n) const;
    const_local_iterator <a href="#unordered_multimap_cbegin_2">cbegin</a>(size_type n) const;
    const_local_iterator <a href="#unordered_multimap_cend_2">cend</a>(size_type n) const;

    // hash policy
    float <a href="#unordered_multimap_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_multimap_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_multimap_max_load_factor">max_load_factor</a>(float z);
    void <a href="#unordered_multimap_rehash">rehash</a>(size_type n);
    void <a href="#unordered_multimap_reserve">reserve</a>(size_type n);
  };

  // Deduction Guides
  template&lt;class InputIterator,
           class Hash = boost::hash&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
           class Pred = std::equal_to&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
           class Allocator = std::allocator&lt;<a href="#unordered_multimap_iter_to_alloc_type"><em>iter-to-alloc-type</em></a>&lt;InputIterator&gt;&gt;&gt;
    unordered_multimap(InputIterator, InputIterator, typename <a href="#unordered_multimap_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_multimap_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_multimap&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_multimap_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;, Hash,
                            Pred, Allocator&gt;;

  template&lt;class Key, class T, class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
    unordered_multimap(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;,
                       typename <a href="#unordered_multimap_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_multimap_deduction_guides"><em>see below</em></a>, Hash = Hash(),
                       Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_multimap&lt;Key, T, Hash, Pred, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_multimap(InputIterator, InputIterator, typename <a href="#unordered_multimap_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_multimap&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_multimap_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_multimap(InputIterator, InputIterator, Allocator)
      -&gt; unordered_multimap&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_multimap_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Hash, class Allocator&gt;
    unordered_multimap(InputIterator, InputIterator, typename <a href="#unordered_multimap_deduction_guides"><em>see below</em></a>::size_type, Hash,
                       Allocator)
      -&gt; unordered_multimap&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_multimap_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;, Hash,
                            std::equal_to&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Allocator&gt;
    unordered_multimap(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, typename <a href="#unordered_multimap_deduction_guides"><em>see below</em></a>::size_type,
                       Allocator)
      -&gt; unordered_multimap&lt;Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Allocator&gt;
    unordered_multimap(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, Allocator)
      -&gt; unordered_multimap&lt;Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Hash, class Allocator&gt;
    unordered_multimap(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, typename <a href="#unordered_multimap_deduction_guides"><em>see below</em></a>::size_type,
                       Hash, Allocator)
      -&gt; unordered_multimap&lt;Key, T, Hash, std::equal_to&lt;Key&gt;, Allocator&gt;;

  // Equality Comparisons
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_multimap_operator">operator==</a>(const unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_multimap_operator_2">operator!=</a>(const unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  // swap
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    void <a href="#unordered_multimap_swap_2">swap</a>(unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
              unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
    typename unordered_multimap&lt;K, T, H, P, A&gt;::size_type
      <a href="#unordered_multimap_erase_if">erase_if</a>(unordered_multimap&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_multimap_description"><a class="anchor" href="#unordered_multimap_description"></a>Description</h3>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Key</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container (i.e. <code>allocator_traits</code> can destroy it).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>T</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>T</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container (i.e. <code>allocator_traits</code> can destroy it).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that implements an equivalence relation on values of type <code>Key</code>. A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type bool.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket.</p>
</div>
<div class="paragraph">
<p>The number of buckets can be automatically increased by a call to insert, or as the result of calling rehash.</p>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multimap_typedefs"><a class="anchor" href="#unordered_multimap_typedefs"></a>Typedefs</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef typename allocator_type::pointer pointer;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>value_type*</code> if <code>allocator_type::pointer</code> is not defined.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef typename allocator_type::const_pointer const_pointer;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>boost::pointer_to_other&lt;pointer, value_type&gt;::type</code> if <code>allocator_type::const_pointer</code> is not defined.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> size_type;</code></pre>
</div>
</div>
<div class="paragraph">
<p>An unsigned integral type.</p>
</div>
<div class="paragraph">
<p><code>size_type</code> can represent any non-negative value of <code>difference_type</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> difference_type;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A signed integral type.</p>
</div>
<div class="paragraph">
<p>Is identical to the difference type of <code>iterator</code> and <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> iterator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> const_iterator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> local_iterator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator with the same value type, difference type and pointer and reference type as iterator.</p>
</div>
<div class="paragraph">
<p>A <code>local_iterator</code> object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> const_local_iterator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator with the same value type, difference type and pointer and reference type as const_iterator.</p>
</div>
<div class="paragraph">
<p>A const_local_iterator object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> node_type;</code></pre>
</div>
</div>
<div class="paragraph">
<p>See node_handle_map for details.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_multimap_constructors"><a class="anchor" href="#unordered_multimap_constructors"></a>Constructors</h3>
<div class="sect3">
<h4 id="unordered_multimap_default_constructor"><a class="anchor" href="#unordered_multimap_default_constructor"></a>Default Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multimap();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate, <code>allocator_type()</code> as the allocator
and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_bucket_count_constructor"><a class="anchor" href="#unordered_multimap_bucket_count_constructor"></a>Bucket Count Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">explicit unordered_multimap(size_type n,
                            const hasher&amp; hf = hasher(),
                            const key_equal&amp; eql = key_equal(),
                            const allocator_type&amp; a = allocator_type());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum
load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_iterator_range_constructor"><a class="anchor" href="#unordered_multimap_iterator_range_constructor"></a>Iterator Range Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
unordered_multimap(InputIterator f, InputIterator l,
                   size_type n = <em>implementation-defined</em>,
                   const hasher&amp; hf = hasher(),
                   const key_equal&amp; eql = key_equal(),
                   const allocator_type&amp; a = allocator_type());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_copy_constructor"><a class="anchor" href="#unordered_multimap_copy_constructor"></a>Copy Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multimap(const unordered_multimap&amp; other);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_move_constructor"><a class="anchor" href="#unordered_multimap_move_constructor"></a>Move Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multimap(unordered_multimap&amp;&amp; other);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move-constructible.<br></p>
<div class="paragraph">
<p>On compilers without rvalue reference support the emulation does not support moving without calling <code>boost::move</code> if <code>value_type</code> is not copyable.
So, for example, you can&#8217;t return the container from a function.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_iterator_range_constructor_with_allocator"><a class="anchor" href="#unordered_multimap_iterator_range_constructor_with_allocator"></a>Iterator Range Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
  unordered_multimap(InputIterator f, InputIterator l, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_allocator_constructor"><a class="anchor" href="#unordered_multimap_allocator_constructor"></a>Allocator Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">explicit unordered_multimap(const Allocator&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_copy_constructor_with_allocator"><a class="anchor" href="#unordered_multimap_copy_constructor_with_allocator"></a>Copy Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multimap(const unordered_multimap&amp; other, const Allocator&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an container, copying <code>other</code>'s contained elements, hash function, predicate, maximum load factor, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_move_constructor_with_allocator"><a class="anchor" href="#unordered_multimap_move_constructor_with_allocator"></a>Move Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multimap(unordered_multimap&amp;&amp; other, const Allocator&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Construct a container moving <code>other</code>'s contained elements, and having the hash function, predicate and maximum load factor, but using allocate <code>a</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move insertable.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_initializer_list_constructor"><a class="anchor" href="#unordered_multimap_initializer_list_constructor"></a>Initializer List Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multimap(std::initializer_list&lt;value_type&gt; il,
                   size_type n = <em>implementation-defined</em>,
                   const hasher&amp; hf = hasher(),
                   const key_equal&amp; eql = key_equal(),
                   const allocator_type&amp; a = allocator_type());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_bucket_count_constructor_with_allocator"><a class="anchor" href="#unordered_multimap_bucket_count_constructor_with_allocator"></a>Bucket Count Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multimap(size_type n, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_bucket_count_constructor_with_hasher_and_allocator"><a class="anchor" href="#unordered_multimap_bucket_count_constructor_with_hasher_and_allocator"></a>Bucket Count Constructor with Hasher and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multimap(size_type n, const hasher&amp; hf, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_iterator_range_constructor_with_bucket_count_and_allocator"><a class="anchor" href="#unordered_multimap_iterator_range_constructor_with_bucket_count_and_allocator"></a>Iterator Range Constructor with Bucket Count and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
  unordered_multimap(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_iterator_range_constructor_with_bucket_count_and_hasher"><a class="anchor" href="#unordered_multimap_iterator_range_constructor_with_bucket_count_and_hasher"></a>Iterator Range Constructor with Bucket Count and Hasher</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
  unordered_multimap(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                     const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_initializer_list_constructor_with_allocator"><a class="anchor" href="#unordered_multimap_initializer_list_constructor_with_allocator"></a>initializer_list Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multimap(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_initializer_list_constructor_with_bucket_count_and_allocator"><a class="anchor" href="#unordered_multimap_initializer_list_constructor_with_bucket_count_and_allocator"></a>initializer_list Constructor with Bucket Count and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multimap(std::initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="anchor" href="#unordered_multimap_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"></a>initializer_list Constructor with Bucket Count and Hasher and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multimap(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                   const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multimap_destructor"><a class="anchor" href="#unordered_multimap_destructor"></a>Destructor</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">~unordered_multimap();</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_multimap_assignment"><a class="anchor" href="#unordered_multimap_assignment"></a>Assignment</h3>
<div class="sect3">
<h4 id="unordered_multimap_copy_assignment"><a class="anchor" href="#unordered_multimap_copy_assignment"></a>Copy Assignment</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multimap&amp; operator=(const unordered_multimap&amp; other);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the copied elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_move_assignment"><a class="anchor" href="#unordered_multimap_move_assignment"></a>Move Assignment</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multimap&amp; operator=(unordered_multimap&amp;&amp; other)
  noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
           boost::is_nothrow_move_assignable_v&lt;Hash&gt; &amp;&amp;
           boost::is_nothrow_move_assignable_v&lt;Pred&gt;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the moved elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>On compilers without rvalue references, this is emulated using Boost.Move. Note that on some compilers the copy assignment operator may be used in some circumstances.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move constructible.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_initializer_list_assignment"><a class="anchor" href="#unordered_multimap_initializer_list_assignment"></a>Initializer List Assignment</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multimap&amp; operator=(std::initializer_list&lt;value_type&gt; il);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All existing elements are either overwritten by the new elements or destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a> into the container and <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable" target="_blank" rel="noopener">CopyAssignable</a>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multimap_iterators"><a class="anchor" href="#unordered_multimap_iterators"></a>Iterators</h3>
<div class="sect3">
<h4 id="unordered_multimap_begin"><a class="anchor" href="#unordered_multimap_begin"></a>begin</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator begin() noexcept;
const_iterator begin() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_end"><a class="anchor" href="#unordered_multimap_end"></a>end</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator       end() noexcept;
const_iterator end() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_cbegin"><a class="anchor" href="#unordered_multimap_cbegin"></a>cbegin</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">const_iterator cbegin() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_cend"><a class="anchor" href="#unordered_multimap_cend"></a>cend</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">const_iterator cend() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multimap_size_and_capacity"><a class="anchor" href="#unordered_multimap_size_and_capacity"></a>Size and Capacity</h3>
<div class="sect3">
<h4 id="unordered_multimap_empty"><a class="anchor" href="#unordered_multimap_empty"></a>empty</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">[[nodiscard]] bool empty() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_size"><a class="anchor" href="#unordered_multimap_size"></a>size</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type size() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_max_size"><a class="anchor" href="#unordered_multimap_max_size"></a>max_size</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type max_size() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multimap_modifiers"><a class="anchor" href="#unordered_multimap_modifiers"></a>Modifiers</h3>
<div class="sect3">
<h4 id="unordered_multimap_emplace"><a class="anchor" href="#unordered_multimap_emplace"></a>emplace</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class... Args&gt; iterator emplace(Args&amp;&amp;... args);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to <code>10</code> arguments, with no support for rvalue references or move semantics.<br></p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_emplace_hint"><a class="anchor" href="#unordered_multimap_emplace_hint"></a>emplace_hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class... Args&gt; iterator emplace_hint(const_iterator position, Args&amp;&amp;... args);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments args, in the container.</p>
</div>
<div class="paragraph">
<p><code>position</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to 10 arguments, with no support for rvalue references or move semantics.<br></p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_copy_insert"><a class="anchor" href="#unordered_multimap_copy_insert"></a>Copy Insert</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(const value_type&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_move_insert"><a class="anchor" href="#unordered_multimap_move_insert"></a>Move Insert</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(value_type&amp;&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_emplace_insert"><a class="anchor" href="#unordered_multimap_emplace_insert"></a>Emplace Insert</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class P&gt; iterator insert(P&amp;&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element into the container by performing <code>emplace(std::forward&lt;P&gt;(value))</code>.</p>
</div>
<div class="paragraph">
<p>Only participates in overload resolution if <code>std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value</code> is <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_copy_insert_with_hint"><a class="anchor" href="#unordered_multimap_copy_insert_with_hint"></a>Copy Insert with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(const_iterator hint, const value_type&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_move_insert_with_hint"><a class="anchor" href="#unordered_multimap_move_insert_with_hint"></a>Move Insert with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(const_iterator hint, value_type&amp;&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_emplace_insert_with_hint"><a class="anchor" href="#unordered_multimap_emplace_insert_with_hint"></a>Emplace Insert with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class P&gt; iterator insert(const_iterator hint, P&amp;&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element into the container by performing <code>emplace_hint(hint, std::forward&lt;P&gt;(value))</code>.</p>
</div>
<div class="paragraph">
<p>Only participates in overload resolution if <code>std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value</code> is <code>true</code>.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_insert_iterator_range"><a class="anchor" href="#unordered_multimap_insert_iterator_range"></a>Insert Iterator Range</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt; void insert(InputIterator first, InputIterator last);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_insert_initializer_list"><a class="anchor" href="#unordered_multimap_insert_initializer_list"></a>Insert Initializer List</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void insert(std::initializer_list&lt;value_type&gt; il);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_extract_by_iterator"><a class="anchor" href="#unordered_multimap_extract_by_iterator"></a>Extract by Iterator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">node_type extract(const_iterator position);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_map</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_extract_by_key"><a class="anchor" href="#unordered_multimap_extract_by_key"></a>Extract by Key</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">node_type extract(const key_type&amp; k);
template&lt;class K&gt; node_type extract(K&amp;&amp; k);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes an element with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element if found, otherwise an empty <code>node_type</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_map</code>.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_insert_with_node_handle"><a class="anchor" href="#unordered_multimap_insert_with_node_handle"></a>Insert with <code>node_handle</code></h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(node_type&amp;&amp; nh);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty, returns <code>end()</code>.<br></p>
<div class="paragraph">
<p>Otherwise returns an iterator pointing to the newly inserted element.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_map</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_insert_with_hint_and_node_handle"><a class="anchor" href="#unordered_multimap_insert_with_hint_and_node_handle"></a>Insert with Hint and <code>node_handle</code></h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(const_iterator hint, node_type&amp;&amp; nh);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code>.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty, returns <code>end()</code>.<br></p>
<div class="paragraph">
<p>Otherwise returns an iterator pointing to the newly inserted element.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to hasher the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_map</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_erase_by_position"><a class="anchor" href="#unordered_multimap_erase_by_position"></a>Erase by Position</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator erase(iterator position);
iterator erase(const_iterator position);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following <code>position</code> before the erasure.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In older versions this could be inefficient because it had to search through several buckets to find the position of the returned iterator. The data structure has been changed so that this is no longer the case, and the alternative erase methods have been deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_erase_by_key"><a class="anchor" href="#unordered_multimap_erase_by_key"></a>Erase by Key</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type erase(const key_type&amp; k);
template&lt;class K&gt; size_type erase(K&amp;&amp; k);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_erase_range"><a class="anchor" href="#unordered_multimap_erase_range"></a>Erase Range</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator erase(const_iterator first, const_iterator last);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_quick_erase"><a class="anchor" href="#unordered_multimap_quick_erase"></a>quick_erase</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void quick_erase(const_iterator position);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_erase_return_void"><a class="anchor" href="#unordered_multimap_erase_return_void"></a>erase_return_void</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void erase_return_void(const_iterator position);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_swap"><a class="anchor" href="#unordered_multimap_swap"></a>swap</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void swap(unordered_multimap&amp; other)
  noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
           boost::is_nothrow_swappable_v&lt;Hash&gt; &amp;&amp;
           boost::is_nothrow_swappable_v&lt;Pred&gt;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_clear"><a class="anchor" href="#unordered_multimap_clear"></a>clear</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void clear() noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Never throws an exception.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_merge"><a class="anchor" href="#unordered_multimap_merge"></a>merge</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class H2, class P2&gt;
  void merge(unordered_multimap&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
template&lt;class H2, class P2&gt;
  void merge(unordered_multimap&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);
template&lt;class H2, class P2&gt;
  void merge(unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
template&lt;class H2, class P2&gt;
  void merge(unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Attempt to "merge" two containers by iterating <code>source</code> and extracting all nodes in <code>source</code> and inserting them into <code>*this</code>.</p>
</div>
<div class="paragraph">
<p>Because <code>source</code> can have a different hash function and key equality predicate, the key of each node in
<code>source</code> is rehashed using <code>this-&gt;hash_function()</code> and then, if required, compared using <code>this-&gt;key_eq()</code>.</p>
</div>
<div class="paragraph">
<p>The behavior of this function is undefined if <code>this-&gt;get_allocator() != source.get_allocator()</code>.</p>
</div>
<div class="paragraph">
<p>This function does not copy or move any elements and instead simply relocates the nodes from <code>source</code>
into <code>*this</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Pointers and references to transferred elements remain valid.</p>
</li>
<li>
<p>Invalidates iterators to transferred elements.</p>
</li>
<li>
<p>Invalidates iterators belonging to <code>*this</code>.</p>
</li>
<li>
<p>Iterators to non-transferred elements in <code>source</code> remain valid.</p>
</li>
</ul>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multimap_observers"><a class="anchor" href="#unordered_multimap_observers"></a>Observers</h3>
<div class="sect3">
<h4 id="unordered_multimap_get_allocator"><a class="anchor" href="#unordered_multimap_get_allocator"></a>get_allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">allocator_type get_allocator() const;</code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_hash_function"><a class="anchor" href="#unordered_multimap_hash_function"></a>hash_function</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">hasher hash_function() const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_key_eq"><a class="anchor" href="#unordered_multimap_key_eq"></a>key_eq</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">key_equal key_eq() const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multimap_lookup"><a class="anchor" href="#unordered_multimap_lookup"></a>Lookup</h3>
<div class="sect3">
<h4 id="unordered_multimap_find"><a class="anchor" href="#unordered_multimap_find"></a>find</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator         find(const key_type&amp; k);
const_iterator   find(const key_type&amp; k) const;
template&lt;class K&gt;
  iterator       find(const K&amp; k);
template&lt;class K&gt;
  const_iterator find(const K&amp; k) const;
template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
  iterator       find(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                      CompatiblePredicate const&amp; eq);
template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
  const_iterator find(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                      CompatiblePredicate const&amp; eq) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>b.end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The templated overloads containing <code>CompatibleKey</code>, <code>CompatibleHash</code> and <code>CompatiblePredicate</code> are non-standard extensions which allow you to use a compatible hash function and equality predicate for a key of a different type in order to avoid an expensive type cast. In general, its use is not encouraged and instead the <code>K</code> member function templates should be used.<br></p>
<div class="paragraph">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_count"><a class="anchor" href="#unordered_multimap_count"></a>count</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type        count(const key_type&amp; k) const;
template&lt;class K&gt;
  size_type      count(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_contains"><a class="anchor" href="#unordered_multimap_contains"></a>contains</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">bool             contains(const key_type&amp; k) const;
template&lt;class K&gt;
  bool           contains(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_equal_range"><a class="anchor" href="#unordered_multimap_equal_range"></a>equal_range</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::pair&lt;iterator, iterator&gt;               equal_range(const key_type&amp; k);
std::pair&lt;const_iterator, const_iterator&gt;   equal_range(const key_type&amp; k) const;
template&lt;class K&gt;
  std::pair&lt;iterator, iterator&gt;             equal_range(const K&amp; k);
template&lt;class K&gt;
  std::pair&lt;const_iterator, const_iterator&gt; equal_range(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multimap_bucket_interface"><a class="anchor" href="#unordered_multimap_bucket_interface"></a>Bucket Interface</h3>
<div class="sect3">
<h4 id="unordered_multimap_bucket_count"><a class="anchor" href="#unordered_multimap_bucket_count"></a>bucket_count</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type bucket_count() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_max_bucket_count"><a class="anchor" href="#unordered_multimap_max_bucket_count"></a>max_bucket_count</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type max_bucket_count() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An upper bound on the number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_bucket_size"><a class="anchor" href="#unordered_multimap_bucket_size"></a>bucket_size</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type bucket_size(size_type n) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n &lt; bucket_count()</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements in bucket <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_bucket"><a class="anchor" href="#unordered_multimap_bucket"></a>bucket</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type bucket(const key_type&amp; k) const;
template&lt;class K&gt; size_type bucket(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The index of the bucket which would contain an element with key <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p>The return value is less than <code>bucket_count()</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_begin_2"><a class="anchor" href="#unordered_multimap_begin_2"></a>begin</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">local_iterator begin(size_type n);
const_local_iterator begin(size_type n) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_end_2"><a class="anchor" href="#unordered_multimap_end_2"></a>end</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">local_iterator end(size_type n);
const_local_iterator end(size_type n) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_cbegin_2"><a class="anchor" href="#unordered_multimap_cbegin_2"></a>cbegin</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">const_local_iterator cbegin(size_type n) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_cend_2"><a class="anchor" href="#unordered_multimap_cend_2"></a>cend</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">const_local_iterator cend(size_type n) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multimap_hash_policy"><a class="anchor" href="#unordered_multimap_hash_policy"></a>Hash Policy</h3>
<div class="sect3">
<h4 id="unordered_multimap_load_factor"><a class="anchor" href="#unordered_multimap_load_factor"></a>load_factor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">float load_factor() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The average number of elements per bucket.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_max_load_factor"><a class="anchor" href="#unordered_multimap_max_load_factor"></a>max_load_factor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">float max_load_factor() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the current maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_set_max_load_factor"><a class="anchor" href="#unordered_multimap_set_max_load_factor"></a>Set max_load_factor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void max_load_factor(float z);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Changes the container&#8217;s maximum load factor, using <code>z</code> as a hint.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_rehash"><a class="anchor" href="#unordered_multimap_rehash"></a>rehash</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void rehash(size_type n);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes the number of buckets so that there are at least <code>n</code> buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the <code>bucket_count()</code> associated with the container.</p>
</div>
<div class="paragraph">
<p>When <code>size() == 0</code>, <code>rehash(0)</code> will deallocate the underlying buckets array.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_reserve"><a class="anchor" href="#unordered_multimap_reserve"></a>reserve</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void reserve(size_type n);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>a.rehash(ceil(n / a.max_load_factor()))</code>, or <code>a.rehash(1)</code> if <code>n &gt; 0</code> and <code>a.max_load_factor() == std::numeric_limits&lt;float&gt;::infinity()</code>.</p>
</div>
<div class="paragraph">
<p>Similar to <code>rehash</code>, this function can be used to grow or shrink the number of buckets in the container.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multimap_deduction_guides"><a class="anchor" href="#unordered_multimap_deduction_guides"></a>Deduction Guides</h3>
<div class="paragraph">
<p>A deduction guide will not participate in overload resolution if any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has an <code>InputIterator</code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p>
</li>
<li>
<p>It has an <code>Allocator</code> template parameter and a type that does not qualify as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Hash</code> template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Pred</code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>size_Â­type</code> parameter type in a deduction guide refers to the <code>size_Â­type</code> member type of the
container type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.</p>
</div>
<div class="sect3">
<h4 id="unordered_multimap_iter_value_type"><a class="anchor" href="#unordered_multimap_iter_value_type"></a><em>iter-value-type</em></h4>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-value-type</em> =
    typename std::iterator_traits&lt;InputIterator&gt;::value_type; // exposition only</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_iter_key_type"><a class="anchor" href="#unordered_multimap_iter_key_type"></a><em>iter-key-type</em></h4>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-key-type</em> = std::remove_const_t&lt;
    std::tuple_element_t&lt;0, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;; // exposition only</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_iter_mapped_type"><a class="anchor" href="#unordered_multimap_iter_mapped_type"></a><em>iter-mapped-type</em></h4>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-mapped-type</em> =
    std::tuple_element_t&lt;1, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;;  // exposition only</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_iter_to_alloc_type"><a class="anchor" href="#unordered_multimap_iter_to_alloc_type"></a><em>iter-to-alloc-type</em></h4>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-to-alloc-type</em> = std::pair&lt;
    std::add_const_t&lt;std::tuple_element_t&lt;0, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;,
    std::tuple_element_t&lt;1, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;; // exposition only</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multimap_equality_comparisons"><a class="anchor" href="#unordered_multimap_equality_comparisons"></a>Equality Comparisons</h3>
<div class="sect3">
<h4 id="unordered_multimap_operator"><a class="anchor" href="#unordered_multimap_operator"></a>operator==</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
  bool operator==(const unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                  const unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every equivalent key group in <code>x</code>, there is a group in <code>y</code> for the same key, which is a permutation (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The behavior of this function was changed to match the C++11 standard in Boost 1.48.<br></p>
<div class="paragraph">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_operator_2"><a class="anchor" href="#unordered_multimap_operator_2"></a>operator!=</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
  bool operator!=(const unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                  const unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every equivalent key group in <code>x</code>, there is a group in <code>y</code> for the same key, which is a permutation (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The behavior of this function was changed to match the C++11 standard in Boost 1.48.<br></p>
<div class="paragraph">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multimap_swap_2"><a class="anchor" href="#unordered_multimap_swap_2"></a>Swap</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
  void swap(unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
            unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
    noexcept(noexcept(x.swap(y)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_multimap_erase_if"><a class="anchor" href="#unordered_multimap_erase_if"></a>erase_if</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
  typename unordered_multimap&lt;K, T, H, P, A&gt;::size_type
    erase_if(unordered_multimap&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">auto original_size = c.size();
for (auto i = c.begin(), last = c.end(); i != last; ) {
  if (pred(*i)) {
    i = c.erase(i);
  } else {
    ++i;
  }
}
return original_size - c.size();</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="unordered_set"><a class="anchor" href="#unordered_set"></a>Class template unordered_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>boost::unordered_set</code> â€” An unordered associative container that stores unique values.</p>
</div>
<div class="sect2">
<h3 id="unordered_set_synopsis"><a class="anchor" href="#unordered_set_synopsis"></a>Synopsis</h3>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/unordered_set.hpp&gt;

namespace boost {
  template&lt;class Key,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;Key&gt;&gt;
  class unordered_set {
  public:
    // types
    using key_type             = Key;
    using value_type           = Key;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename boost::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename boost::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = <em>implementation-defined</em>;
    using difference_type      = <em>implementation-defined</em>;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;
    using local_iterator       = <em>implementation-defined</em>;
    using const_local_iterator = <em>implementation-defined</em>;
    using node_type            = <em>implementation-defined</em>;
    using insert_return_type   = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_set_default_constructor">unordered_set</a>();
    explicit <a href="#unordered_set_bucket_count_constructor">unordered_set</a>(size_type n,
                           const hasher&amp; hf = hasher(),
                           const key_equal&amp; eql = key_equal(),
                           const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_set_iterator_range_constructor">unordered_set</a>(InputIterator f, InputIterator l,
                    size_type n = <em>implementation-defined</em>,
                    const hasher&amp; hf = hasher(),
                    const key_equal&amp; eql = key_equal(),
                    const allocator_type&amp; a = allocator_type());
    <a href="#unordered_set_copy_constructor">unordered_set</a>(const unordered_set&amp; other);
    <a href="#unordered_set_move_constructor">unordered_set</a>(unordered_set&amp;&amp; other);
    template&lt;class InputIterator&gt;
      <a href="#unordered_set_iterator_range_constructor_with_allocator">unordered_set</a>(InputIterator f, InputIterator l, const allocator_type&amp; a);
    explicit <a href="#unordered_set_allocator_constructor">unordered_set</a>(const Allocator&amp; a);
    <a href="#unordered_set_copy_constructor_with_allocator">unordered_set</a>(const unordered_set&amp; other, const Allocator&amp; a);
    <a href="#unordered_set_move_constructor_with_allocator">unordered_set</a>(unordered_set&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_set_initializer_list_constructor">unordered_set</a>(std::initializer_list&lt;value_type&gt; il,
                  size_type n = <em>implementation-defined</em>,
                  const hasher&amp; hf = hasher(),
                  const key_equal&amp; eql = key_equal(),
                  const allocator_type&amp; a = allocator_type());
    <a href="#unordered_set_bucket_count_constructor_with_allocator">unordered_set</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_set_bucket_count_constructor_with_hasher_and_allocator">unordered_set</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_set_iterator_range_constructor_with_bucket_count_and_allocator">unordered_set</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_set_iterator_range_constructor_with_bucket_count_and_hasher">unordered_set</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                    const allocator_type&amp; a);
    <a href="#unordered_set_initializer_list_constructor_with_allocator">unordered_set</a>(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);
    <a href="#unordered_set_initializer_list_constructor_with_bucket_count_and_allocator">unordered_set</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a);
    <a href="#unordered_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_set</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                  const allocator_type&amp; a);
    <a href="#unordered_set_destructor">~unordered_set</a>();
    unordered_set&amp; <a href="#unordered_set_copy_assignment">operator=</a>(const unordered_set&amp; other);
    unordered_set&amp; <a href="#unordered_set_move_assignment">operator=</a>(unordered_set&amp;&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Pred&gt;);
    unordered_set&amp; <a href="#unordered_set_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt; il);
    allocator_type <a href="#unordered_set_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_set_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_set_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_set_end">end</a>() noexcept;
    const_iterator <a href="#unordered_set_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_set_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_set_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_set_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_set_size">size</a>() const noexcept;
    size_type <a href="#unordered_set_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_set_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_set_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_set_copy_insert">insert</a>(const value_type&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_set_move_insert">insert</a>(value_type&amp;&amp; obj);
    template&lt;class K&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_set_transparent_insert">insert</a>(K&amp;&amp; k);
    iterator <a href="#unordered_set_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator <a href="#unordered_set_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    template&lt;class K&gt; iterator <a href="#unordered_set_transparent_insert_with_hint">insert</a>(const_iterator hint, K&amp;&amp; k);
    template&lt;class InputIterator&gt; void <a href="#unordered_set_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_set_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt;);

    node_type <a href="#unordered_set_extract_by_iterator">extract</a>(const_iterator position);
    node_type <a href="#unordered_set_extract_by_value">extract</a>(const key_type&amp; k);
    template&lt;class K&gt; node_type <a href="#unordered_set_extract_by_value">extract</a>(K&amp;&amp; k);
    insert_return_type <a href="#unordered_set_insert_with_node_handle">insert</a>(node_type&amp;&amp; nh);
    iterator           <a href="#unordered_set_insert_with_hint_and_node_handle">insert</a>(const_iterator hint, node_type&amp;&amp; nh);

    iterator  <a href="#unordered_set_erase_by_position">erase</a>(iterator position);
    iterator  <a href="#unordered_set_erase_by_position">erase</a>(const_iterator position);
    size_type <a href="#unordered_set_erase_by_value">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_set_erase_by_value">erase</a>(K&amp;&amp; k);
    iterator  <a href="#unordered_set_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_set_quick_erase">quick_erase</a>(const_iterator position);
    void      <a href="#unordered_set_erase_return_void">erase_return_void</a>(const_iterator position);
    void      <a href="#unordered_set_swap">swap</a>(unordered_set&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Pred&gt;);
    void      <a href="#unordered_set_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_set_merge">merge</a>(unordered_set&lt;Key, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_set_merge">merge</a>(unordered_set&lt;Key, H2, P2, Allocator&gt;&amp;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_set_merge">merge</a>(unordered_multiset&lt;Key, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_set_merge">merge</a>(unordered_multiset&lt;Key, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_set_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_set_key_eq">key_eq</a>() const;

    // set operations
    iterator         <a href="#unordered_set_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_set_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_set_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_set_find">find</a>(const K&amp; k) const;
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      iterator       <a href="#unordered_set_find">find</a>(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                          CompatiblePredicate const&amp; eq);
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      const_iterator <a href="#unordered_set_find">find</a>(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                          CompatiblePredicate const&amp; eq) const;
    size_type        <a href="#unordered_set_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_set_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_set_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_set_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_set_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_set_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_set_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_set_equal_range">equal_range</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_set_bucket_count">bucket_count</a>() const noexcept;
    size_type <a href="#unordered_set_max_bucket_count">max_bucket_count</a>() const noexcept;
    size_type <a href="#unordered_set_bucket_size">bucket_size</a>(size_type n) const;
    size_type <a href="#unordered_set_bucket">bucket</a>(const key_type&amp; k) const;
    template&lt;class K&gt; size_type <a href="#unordered_set_bucket">bucket</a>(const K&amp; k) const;
    local_iterator <a href="#unordered_set_begin_2">begin</a>(size_type n);
    const_local_iterator <a href="#unordered_set_begin_2">begin</a>(size_type n) const;
    local_iterator <a href="#unordered_set_end_2">end</a>(size_type n);
    const_local_iterator <a href="#unordered_set_end_2">end</a>(size_type n) const;
    const_local_iterator <a href="#unordered_set_cbegin_2">cbegin</a>(size_type n) const;
    const_local_iterator <a href="#unordered_set_cend_2">cend</a>(size_type n) const;

    // hash policy
    float <a href="#unordered_set_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_set_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_set_set_max_load_factor">max_load_factor</a>(float z);
    void <a href="#unordered_set_rehash">rehash</a>(size_type n);
    void <a href="#unordered_set_reserve">reserve</a>(size_type n);
  };

  // Deduction Guides
  template&lt;class InputIterator,
           class Hash = boost::hash&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
           class Pred = std::equal_to&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
           class Allocator = std::allocator&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;
    unordered_set(InputIterator, InputIterator, typename <a href="#unordered_set_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_set_deduction_guides"><em>see below</em></a>,
                  Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_set&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;, Hash, Pred, Allocator&gt;;

  template&lt;class T, class Hash = boost::hash&lt;T&gt;, class Pred = std::equal_to&lt;T&gt;,
           class Allocator = std::allocator&lt;T&gt;&gt;
    unordered_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_set_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_set_deduction_guides"><em>see below</em></a>,
                  Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_set&lt;T, Hash, Pred, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_set(InputIterator, InputIterator, typename <a href="#unordered_set_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_set&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;,
                       boost::hash&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
                       std::equal_to&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_set(InputIterator, InputIterator, Allocator)
      -&gt; unordered_set&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;,
                       boost::hash&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
                       std::equal_to&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Hash, class Allocator&gt;
    unordered_set(InputIterator, InputIterator, typename <a href="#unordered_set_deduction_guides"><em>see below</em></a>::size_type, Hash, Allocator)
      -&gt; unordered_set&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;, Hash,
                       std::equal_to&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_set_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_set&lt;T, boost::hash&lt;T&gt;, std::equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_set(std::initializer_list&lt;T&gt;, Allocator)
      -&gt; unordered_set&lt;T, boost::hash&lt;T&gt;, std::equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Hash, class Allocator&gt;
    unordered_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_set_deduction_guides"><em>see below</em></a>::size_type, Hash, Allocator)
      -&gt; unordered_set&lt;T, Hash, std::equal_to&lt;T&gt;, Allocator&gt;;

  // Equality Comparisons
  template&lt;class Key, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_set_operator">operator==</a>(const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; y);

  template&lt;class Key, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_set_operator_2">operator!=</a>(const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; y);

  // swap
  template&lt;class Key, class Hash, class Pred, class Alloc&gt;
    void <a href="#unordered_set_swap_2">swap</a>(unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
              unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  template&lt;class K, class H, class P, class A, class Predicate&gt;
    typename unordered_set&lt;K, H, P, A&gt;::size_type
      <a href="#unordered_set_erase_if">erase_if</a>(unordered_set&lt;K, H, P, A&gt;&amp; c, Predicate pred);
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_set_description"><a class="anchor" href="#unordered_set_description"></a>Description</h3>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Key</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container (i.e. <code>allocator_traits</code> can destroy it).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that implements an equivalence relation on values of type <code>Key</code>. A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type bool.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket.</p>
</div>
<div class="paragraph">
<p>The number of buckets can be automatically increased by a call to insert, or as the result of calling rehash.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_set_typedefs"><a class="anchor" href="#unordered_set_typedefs"></a>Typedefs</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef typename allocator_type::pointer pointer;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>value_type*</code> if <code>allocator_type::pointer</code> is not defined.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef typename allocator_type::const_pointer const_pointer;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>boost::pointer_to_other&lt;pointer, value_type&gt;::type</code> if <code>allocator_type::const_pointer</code> is not defined.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> size_type;</code></pre>
</div>
</div>
<div class="paragraph">
<p>An unsigned integral type.</p>
</div>
<div class="paragraph">
<p><code>size_type</code> can represent any non-negative value of <code>difference_type</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> difference_type;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A signed integral type.</p>
</div>
<div class="paragraph">
<p>Is identical to the difference type of <code>iterator</code> and <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> iterator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> const_iterator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> local_iterator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator with the same value type, difference type and pointer and reference type as iterator.</p>
</div>
<div class="paragraph">
<p>A <code>local_iterator</code> object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> const_local_iterator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator with the same value type, difference type and pointer and reference type as const_iterator.</p>
</div>
<div class="paragraph">
<p>A const_local_iterator object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> node_type;</code></pre>
</div>
</div>
<div class="paragraph">
<p>See node_handle_set for details.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> insert_return_type;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Structure returned by inserting node_type.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_set_constructors"><a class="anchor" href="#unordered_set_constructors"></a>Constructors</h3>
<div class="sect3">
<h4 id="unordered_set_default_constructor"><a class="anchor" href="#unordered_set_default_constructor"></a>Default Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_set();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate, <code>allocator_type()</code> as the allocator
and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_bucket_count_constructor"><a class="anchor" href="#unordered_set_bucket_count_constructor"></a>Bucket Count Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">explicit unordered_set(size_type n,
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum
load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_iterator_range_constructor"><a class="anchor" href="#unordered_set_iterator_range_constructor"></a>Iterator Range Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
  unordered_set(InputIterator f, InputIterator l,
                size_type n = <em>implementation-defined</em>,
                const hasher&amp; hf = hasher(),
                const key_equal&amp; eql = key_equal(),
                const allocator_type&amp; a = allocator_type());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_copy_constructor"><a class="anchor" href="#unordered_set_copy_constructor"></a>Copy Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_set(const unordered_set&amp; other);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_move_constructor"><a class="anchor" href="#unordered_set_move_constructor"></a>Move Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_set(unordered_set&amp;&amp; other);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move-constructible.<br></p>
<div class="paragraph">
<p>On compilers without rvalue reference support the emulation does not support moving without calling <code>boost::move</code> if <code>value_type</code> is not copyable.
So, for example, you can&#8217;t return the container from a function.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_iterator_range_constructor_with_allocator"><a class="anchor" href="#unordered_set_iterator_range_constructor_with_allocator"></a>Iterator Range Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
  unordered_set(InputIterator f, InputIterator l, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_allocator_constructor"><a class="anchor" href="#unordered_set_allocator_constructor"></a>Allocator Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">explicit unordered_set(const Allocator&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_copy_constructor_with_allocator"><a class="anchor" href="#unordered_set_copy_constructor_with_allocator"></a>Copy Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_set(const unordered_set&amp; other, const Allocator&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an container, copying <code>other</code>'s contained elements, hash function, predicate, maximum load factor, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_move_constructor_with_allocator"><a class="anchor" href="#unordered_set_move_constructor_with_allocator"></a>Move Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_set(unordered_set&amp;&amp; other, const Allocator&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Construct a container moving <code>other</code>'s contained elements, and having the hash function, predicate and maximum load factor, but using allocate <code>a</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move insertable.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_initializer_list_constructor"><a class="anchor" href="#unordered_set_initializer_list_constructor"></a>Initializer List Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_set(std::initializer_list&lt;value_type&gt; il,
              size_type n = <em>implementation-defined</em>,
              const hasher&amp; hf = hasher(),
              const key_equal&amp; eql = key_equal(),
              const allocator_type&amp; a = allocator_type());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_bucket_count_constructor_with_allocator"><a class="anchor" href="#unordered_set_bucket_count_constructor_with_allocator"></a>Bucket Count Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_set(size_type n, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_bucket_count_constructor_with_hasher_and_allocator"><a class="anchor" href="#unordered_set_bucket_count_constructor_with_hasher_and_allocator"></a>Bucket Count Constructor with Hasher and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_set(size_type n, const hasher&amp; hf, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_iterator_range_constructor_with_bucket_count_and_allocator"><a class="anchor" href="#unordered_set_iterator_range_constructor_with_bucket_count_and_allocator"></a>Iterator Range Constructor with Bucket Count and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
  unordered_set(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_iterator_range_constructor_with_bucket_count_and_hasher"><a class="anchor" href="#unordered_set_iterator_range_constructor_with_bucket_count_and_hasher"></a>Iterator Range Constructor with Bucket Count and Hasher</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
  unordered_set(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_initializer_list_constructor_with_allocator"><a class="anchor" href="#unordered_set_initializer_list_constructor_with_allocator"></a>initializer_list Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_set(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_initializer_list_constructor_with_bucket_count_and_allocator"><a class="anchor" href="#unordered_set_initializer_list_constructor_with_bucket_count_and_allocator"></a>initializer_list Constructor with Bucket Count and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_set(std::initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="anchor" href="#unordered_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"></a>initializer_list Constructor with Bucket Count and Hasher and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_set(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
              const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_set_destructor"><a class="anchor" href="#unordered_set_destructor"></a>Destructor</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">~unordered_set();</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_set_assignment"><a class="anchor" href="#unordered_set_assignment"></a>Assignment</h3>
<div class="sect3">
<h4 id="unordered_set_copy_assignment"><a class="anchor" href="#unordered_set_copy_assignment"></a>Copy Assignment</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_set&amp; operator=(const unordered_set&amp; other);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the copied elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_move_assignment"><a class="anchor" href="#unordered_set_move_assignment"></a>Move Assignment</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_set&amp; operator=(unordered_set&amp;&amp; other)
  noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
           boost::is_nothrow_move_assignable_v&lt;Hash&gt; &amp;&amp;
           boost::is_nothrow_move_assignable_v&lt;Pred&gt;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the moved elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>On compilers without rvalue references, this is emulated using Boost.Move. Note that on some compilers the copy assignment operator may be used in some circumstances.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move constructible.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_initializer_list_assignment"><a class="anchor" href="#unordered_set_initializer_list_assignment"></a>Initializer List Assignment</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_set&amp; operator=(std::initializer_list&lt;value_type&gt; il);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All existing elements are either overwritten by the new elements or destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a> into the container and <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable" target="_blank" rel="noopener">CopyAssignable</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_set_iterators"><a class="anchor" href="#unordered_set_iterators"></a>Iterators</h3>
<div class="sect3">
<h4 id="unordered_set_begin"><a class="anchor" href="#unordered_set_begin"></a>begin</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator       begin() noexcept;
const_iterator begin() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_end"><a class="anchor" href="#unordered_set_end"></a>end</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator       end() noexcept;
const_iterator end() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_cbegin"><a class="anchor" href="#unordered_set_cbegin"></a>cbegin</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">const_iterator cbegin() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_cend"><a class="anchor" href="#unordered_set_cend"></a>cend</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">const_iterator cend() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_set_size_and_capacity"><a class="anchor" href="#unordered_set_size_and_capacity"></a>Size and Capacity</h3>
<div class="sect3">
<h4 id="unordered_set_empty"><a class="anchor" href="#unordered_set_empty"></a>empty</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">[[nodiscard]] bool empty() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_size"><a class="anchor" href="#unordered_set_size"></a>size</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type size() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_max_size"><a class="anchor" href="#unordered_set_max_size"></a>max_size</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type max_size() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_set_modifiers"><a class="anchor" href="#unordered_set_modifiers"></a>Modifiers</h3>
<div class="sect3">
<h4 id="unordered_set_emplace"><a class="anchor" href="#unordered_set_emplace"></a>emplace</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class... Args&gt; std::pair&lt;iterator, bool&gt; emplace(Args&amp;&amp;... args);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent value.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent value.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to <code>10</code> arguments, with no support for rvalue references or move semantics.<br></p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_emplace_hint"><a class="anchor" href="#unordered_set_emplace_hint"></a>emplace_hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class... Args&gt; iterator emplace_hint(const_iterator position, Args&amp;&amp;... args);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent value.</p>
</div>
<div class="paragraph">
<p><code>position</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to 10 arguments, with no support for rvalue references or move semantics.<br></p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_copy_insert"><a class="anchor" href="#unordered_set_copy_insert"></a>Copy Insert</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::pair&lt;iterator, bool&gt; insert(const value_type&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_move_insert"><a class="anchor" href="#unordered_set_move_insert"></a>Move Insert</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::pair&lt;iterator, bool&gt; insert(value_type&amp;&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_transparent_insert"><a class="anchor" href="#unordered_set_transparent_insert"></a>Transparent Insert</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class K&gt; std::pair&lt;iterator, bool&gt; insert(K&amp;&amp; k);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element constructed from <code>std::forward&lt;K&gt;(k)</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> from <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_copy_insert_with_hint"><a class="anchor" href="#unordered_set_copy_insert_with_hint"></a>Copy Insert with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(const_iterator hint, const value_type&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_move_insert_with_hint"><a class="anchor" href="#unordered_set_move_insert_with_hint"></a>Move Insert with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(const_iterator hint, value_type&amp;&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_transparent_insert_with_hint"><a class="anchor" href="#unordered_set_transparent_insert_with_hint"></a>Transparent Insert with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class K&gt; iterator insert(const_iterator hint, K&amp;&amp; k);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element constructed from <code>std::forward&lt;K&gt;(k)</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> from <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_insert_iterator_range"><a class="anchor" href="#unordered_set_insert_iterator_range"></a>Insert Iterator Range</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt; void insert(InputIterator first, InputIterator last);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_insert_initializer_list"><a class="anchor" href="#unordered_set_insert_initializer_list"></a>Insert Initializer List</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void insert(std::initializer_list&lt;value_type&gt;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_extract_by_iterator"><a class="anchor" href="#unordered_set_extract_by_iterator"></a>Extract by Iterator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">node_type extract(const_iterator position);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In C++17 a node extracted using this method can be inserted into a compatible <code>unordered_multiset</code>, but that is not supported yet.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_extract_by_value"><a class="anchor" href="#unordered_set_extract_by_value"></a>Extract by Value</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">node_type extract(const key_type&amp; k);
template&lt;class K&gt; node_type extract(K&amp;&amp; k);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes an element with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element if found, otherwise an empty <code>node_type</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In C++17 a node extracted using this method can be inserted into a compatible <code>unordered_multiset</code>, but that is not supported yet.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_insert_with_node_handle"><a class="anchor" href="#unordered_set_insert_with_node_handle"></a>Insert with <code>node_handle</code></h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">insert_return_type insert(node_type&amp;&amp; nh);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code> if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty, returns an <code>insert_return_type</code> with: <code>inserted</code> equal to <code>false</code>, <code>position</code> equal to <code>end()</code> and <code>node</code> empty.<br></p>
<div class="paragraph">
<p>Otherwise if there was already an element with an equivalent key, returns an <code>insert_return_type</code> with: <code>inserted</code> equal to <code>false</code>, <code>position</code> pointing to a matching element and <code>node</code> contains the node from <code>nh</code>.<br></p>
</div>
<div class="paragraph">
<p>Otherwise if the insertion succeeded, returns an <code>insert_return_type</code> with: <code>inserted</code> equal to <code>true</code>, <code>position</code> pointing to the newly inserted element and <code>node</code> empty.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>In C++17 this can be used to insert a node extracted from a compatible <code>unordered_multiset</code>, but that is not supported yet.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_insert_with_hint_and_node_handle"><a class="anchor" href="#unordered_set_insert_with_hint_and_node_handle"></a>Insert with Hint and <code>node_handle</code></h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(const_iterator hint, node_type&amp;&amp; nh);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code> if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p>If there is already an element in the container with an equivalent key has no effect on <code>nh</code> (i.e. <code>nh</code> still contains the node.)</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty returns <code>end()</code>.<br></p>
<div class="paragraph">
<p>If there was already an element in the container with an equivalent key returns an iterator pointing to that.<br></p>
</div>
<div class="paragraph">
<p>Otherwise returns an iterator pointing to the newly inserted element.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_multiset</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_erase_by_position"><a class="anchor" href="#unordered_set_erase_by_position"></a>Erase by Position</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator erase(iterator position);
iterator erase(const_iterator position);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following <code>position</code> before the erasure.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In older versions this could be inefficient because it had to search through several buckets to find the position of the returned iterator. The data structure has been changed so that this is no longer the case, and the alternative erase methods have been deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_erase_by_value"><a class="anchor" href="#unordered_set_erase_by_value"></a>Erase by Value</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type erase(const key_type&amp; k);
template&lt;class K&gt; size_type erase(K&amp;&amp; k);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_erase_range"><a class="anchor" href="#unordered_set_erase_range"></a>Erase Range</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator erase(const_iterator first, const_iterator last);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_quick_erase"><a class="anchor" href="#unordered_set_quick_erase"></a>quick_erase</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void quick_erase(const_iterator position);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_erase_return_void"><a class="anchor" href="#unordered_set_erase_return_void"></a>erase_return_void</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void erase_return_void(const_iterator position);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_swap"><a class="anchor" href="#unordered_set_swap"></a>swap</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void swap(unordered_set&amp; other)
  noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
           boost::is_nothrow_swappable_v&lt;Hash&gt; &amp;&amp;
           boost::is_nothrow_swappable_v&lt;Pred&gt;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_clear"><a class="anchor" href="#unordered_set_clear"></a>clear</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void clear() noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Never throws an exception.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_merge"><a class="anchor" href="#unordered_set_merge"></a>merge</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class H2, class P2&gt;
  void merge(unordered_set&lt;Key, H2, P2, Allocator&gt;&amp; source);
template&lt;class H2, class P2&gt;
  void merge(unordered_set&lt;Key, H2, P2, Allocator&gt;&amp;&amp; source);
template&lt;class H2, class P2&gt;
  void merge(unordered_multiset&lt;Key, H2, P2, Allocator&gt;&amp; source);
template&lt;class H2, class P2&gt;
  void merge(unordered_multiset&lt;Key, H2, P2, Allocator&gt;&amp;&amp; source);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Attempt to "merge" two containers by iterating <code>source</code> and extracting any node in <code>source</code> that is not contained
in <code>*this</code> and then inserting it into <code>*this</code>.</p>
</div>
<div class="paragraph">
<p>Because <code>source</code> can have a different hash function and key equality predicate, the key of each node in
<code>source</code> is rehashed using <code>this-&gt;hash_function()</code> and then, if required, compared using <code>this-&gt;key_eq()</code>.</p>
</div>
<div class="paragraph">
<p>The behavior of this function is undefined if <code>this-&gt;get_allocator() != source.get_allocator()</code>.</p>
</div>
<div class="paragraph">
<p>This function does not copy or move any elements and instead simply relocates the nodes from <code>source</code>
into <code>*this</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Pointers and references to transferred elements remain valid.</p>
</li>
<li>
<p>Invalidates iterators to transferred elements.</p>
</li>
<li>
<p>Invalidates iterators belonging to <code>*this</code>.</p>
</li>
<li>
<p>Iterators to non-transferred elements in <code>source</code> remain valid.</p>
</li>
</ul>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_set_observers"><a class="anchor" href="#unordered_set_observers"></a>Observers</h3>
<div class="sect3">
<h4 id="unordered_set_get_allocator"><a class="anchor" href="#unordered_set_get_allocator"></a>get_allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">allocator_type get_allocator() const;</code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_hash_function"><a class="anchor" href="#unordered_set_hash_function"></a>hash_function</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">hasher hash_function() const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_key_eq"><a class="anchor" href="#unordered_set_key_eq"></a>key_eq</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">key_equal key_eq() const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_set_lookup"><a class="anchor" href="#unordered_set_lookup"></a>Lookup</h3>
<div class="sect3">
<h4 id="unordered_set_find"><a class="anchor" href="#unordered_set_find"></a>find</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator         find(const key_type&amp; k);
const_iterator   find(const key_type&amp; k) const;
template&lt;class K&gt;
  iterator       find(const K&amp; k);
template&lt;class K&gt;
  const_iterator find(const K&amp; k) const;
template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
  iterator       find(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                      CompatiblePredicate const&amp; eq);
template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
  const_iterator find(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                      CompatiblePredicate const&amp; eq) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>b.end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The templated overloads containing <code>CompatibleKey</code>, <code>CompatibleHash</code> and <code>CompatiblePredicate</code> are non-standard extensions which allow you to use a compatible hash function and equality predicate for a key of a different type in order to avoid an expensive type cast. In general, its use is not encouraged and instead the <code>K</code> member function templates should be used.<br></p>
<div class="paragraph">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_count"><a class="anchor" href="#unordered_set_count"></a>count</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type        count(const key_type&amp; k) const;
template&lt;class K&gt;
  size_type      count(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_contains"><a class="anchor" href="#unordered_set_contains"></a>contains</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">bool             contains(const key_type&amp; k) const;
template&lt;class K&gt;
  bool           contains(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_equal_range"><a class="anchor" href="#unordered_set_equal_range"></a>equal_range</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::pair&lt;iterator, iterator&gt;               equal_range(const key_type&amp; k);
std::pair&lt;const_iterator, const_iterator&gt;   equal_range(const key_type&amp; k) const;
template&lt;class K&gt;
  std::pair&lt;iterator, iterator&gt;             equal_range(const K&amp; k);
template&lt;class K&gt;
  std::pair&lt;const_iterator, const_iterator&gt; equal_range(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_set_bucket_interface"><a class="anchor" href="#unordered_set_bucket_interface"></a>Bucket Interface</h3>
<div class="sect3">
<h4 id="unordered_set_bucket_count"><a class="anchor" href="#unordered_set_bucket_count"></a>bucket_count</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type bucket_count() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_max_bucket_count"><a class="anchor" href="#unordered_set_max_bucket_count"></a>max_bucket_count</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type max_bucket_count() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An upper bound on the number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_bucket_size"><a class="anchor" href="#unordered_set_bucket_size"></a>bucket_size</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type bucket_size(size_type n) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n &lt; bucket_count()</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements in bucket <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_bucket"><a class="anchor" href="#unordered_set_bucket"></a>bucket</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type bucket(const key_type&amp; k) const;
template&lt;class K&gt; size_type bucket(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The index of the bucket which would contain an element with key <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p>The return value is less than <code>bucket_count()</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_begin_2"><a class="anchor" href="#unordered_set_begin_2"></a>begin</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">local_iterator begin(size_type n);
const_local_iterator begin(size_type n) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_end_2"><a class="anchor" href="#unordered_set_end_2"></a>end</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">local_iterator end(size_type n);
const_local_iterator end(size_type n) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_cbegin_2"><a class="anchor" href="#unordered_set_cbegin_2"></a>cbegin</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">const_local_iterator cbegin(size_type n) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_cend_2"><a class="anchor" href="#unordered_set_cend_2"></a>cend</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">const_local_iterator cend(size_type n) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_set_hash_policy"><a class="anchor" href="#unordered_set_hash_policy"></a>Hash Policy</h3>
<div class="sect3">
<h4 id="unordered_set_load_factor"><a class="anchor" href="#unordered_set_load_factor"></a>load_factor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">float load_factor() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The average number of elements per bucket.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_max_load_factor"><a class="anchor" href="#unordered_set_max_load_factor"></a>max_load_factor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">float max_load_factor() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the current maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_set_max_load_factor"><a class="anchor" href="#unordered_set_set_max_load_factor"></a>Set max_load_factor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void max_load_factor(float z);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Changes the container&#8217;s maximum load factor, using <code>z</code> as a hint.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_rehash"><a class="anchor" href="#unordered_set_rehash"></a>rehash</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void rehash(size_type n);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes the number of buckets so that there are at least <code>n</code> buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the <code>bucket_count()</code> associated with the container.</p>
</div>
<div class="paragraph">
<p>When <code>size() == 0</code>, <code>rehash(0)</code> will deallocate the underlying buckets array.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_reserve"><a class="anchor" href="#unordered_set_reserve"></a>reserve</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void reserve(size_type n);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>a.rehash(ceil(n / a.max_load_factor()))</code>, or <code>a.rehash(1)</code> if <code>n &gt; 0</code> and <code>a.max_load_factor() == std::numeric_limits&lt;float&gt;::infinity()</code>.</p>
</div>
<div class="paragraph">
<p>Similar to <code>rehash</code>, this function can be used to grow or shrink the number of buckets in the container.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_set_deduction_guides"><a class="anchor" href="#unordered_set_deduction_guides"></a>Deduction Guides</h3>
<div class="paragraph">
<p>A deduction guide will not participate in overload resolution if any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has an <code>InputIterator</code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p>
</li>
<li>
<p>It has an <code>Allocator</code> template parameter and a type that does not qualify as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Hash</code> template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Pred</code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>size_Â­type</code> parameter type in a deduction guide refers to the <code>size_Â­type</code> member type of the
container type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.</p>
</div>
<div class="sect3">
<h4 id="unordered_set_iter_value_type"><a class="anchor" href="#unordered_set_iter_value_type"></a><em>iter-value-type</em></h4>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-value-type</em> =
    typename std::iterator_traits&lt;InputIterator&gt;::value_type; // exposition only</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_set_equality_comparisons"><a class="anchor" href="#unordered_set_equality_comparisons"></a>Equality Comparisons</h3>
<div class="sect3">
<h4 id="unordered_set_operator"><a class="anchor" href="#unordered_set_operator"></a>operator==</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class Key, class Hash, class Pred, class Alloc&gt;
  bool operator==(const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
                  const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; y);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The behavior of this function was changed to match the C++11 standard in Boost 1.48.<br></p>
<div class="paragraph">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_operator_2"><a class="anchor" href="#unordered_set_operator_2"></a>operator!=</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class Key, class Hash, class Pred, class Alloc&gt;
  bool operator!=(const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
                  const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; y);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The behavior of this function was changed to match the C++11 standard in Boost 1.48.<br></p>
<div class="paragraph">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_set_swap_2"><a class="anchor" href="#unordered_set_swap_2"></a>Swap</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class Key, class Hash, class Pred, class Alloc&gt;
  void swap(unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
            unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; y)
    noexcept(noexcept(x.swap(y)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_set_erase_if"><a class="anchor" href="#unordered_set_erase_if"></a>erase_if</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class K, class H, class P, class A, class Predicate&gt;
  typename unordered_set&lt;K, H, P, A&gt;::size_type
    erase_if(unordered_set&lt;K, H, P, A&gt;&amp; c, Predicate pred);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">auto original_size = c.size();
for (auto i = c.begin(), last = c.end(); i != last; ) {
  if (pred(*i)) {
    i = c.erase(i);
  } else {
    ++i;
  }
}
return original_size - c.size();</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="unordered_multiset"><a class="anchor" href="#unordered_multiset"></a>Class template unordered_multiset</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>boost::unordered_multiset</code> â€” An unordered associative container that stores values. The same key can be stored multiple times.</p>
</div>
<div class="sect2">
<h3 id="unordered_multiset_synopsis"><a class="anchor" href="#unordered_multiset_synopsis"></a>Synopsis</h3>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/unordered_set.hpp&gt;

namespace boost {
  template&lt;class Key,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;Key&gt;&gt;
  class unordered_multiset {
  public:
    // types
    using key_type             = Key;
    using value_type           = Key;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename boost::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename boost::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = <em>implementation-defined</em>;
    using difference_type      = <em>implementation-defined</em>;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;
    using local_iterator       = <em>implementation-defined</em>;
    using const_local_iterator = <em>implementation-defined</em>;
    using node_type            = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_multiset_default_constructor">unordered_multiset</a>();
    explicit <a href="#unordered_multiset_bucket_count_constructor">unordered_multiset</a>(size_type n,
                                const hasher&amp; hf = hasher(),
                                const key_equal&amp; eql = key_equal(),
                                const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_multiset_iterator_range_constructor">unordered_multiset</a>(InputIterator f, InputIterator l,
                         size_type n = <em>implementation-defined</em>,
                         const hasher&amp; hf = hasher(),
                         const key_equal&amp; eql = key_equal(),
                         const allocator_type&amp; a = allocator_type());
    <a href="#unordered_multiset_copy_constructor">unordered_multiset</a>(const unordered_multiset&amp; other);
    <a href="#unordered_multiset_move_constructor">unordered_multiset</a>(unordered_multiset&amp;&amp; other);
    template&lt;class InputIterator&gt;
      <a href="#unordered_multiset_iterator_range_constructor_with_allocator">unordered_multiset</a>(InputIterator f, InputIterator l, const allocator_type&amp; a);
    explicit <a href="#unordered_multiset_allocator_constructor">unordered_multiset</a>(const Allocator&amp; a);
    <a href="#unordered_multiset_copy_constructor_with_allocator">unordered_multiset</a>(const unordered_multiset&amp; other, const Allocator&amp; a);
    <a href="#unordered_multiset_move_constructor_with_allocator">unordered_multiset</a>(unordered_multiset&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_multiset_initializer_list_constructor">unordered_multiset</a>(std::initializer_list&lt;value_type&gt; il,
                       size_type n = <em>implementation-defined</em>,
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
    <a href="#unordered_multiset_bucket_count_constructor_with_allocator">unordered_multiset</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_multiset_bucket_count_constructor_with_hasher_and_allocator">unordered_multiset</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_multiset_iterator_range_constructor_with_bucket_count_and_allocator">unordered_multiset</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_multiset_iterator_range_constructor_with_bucket_count_and_hasher">unordered_multiset</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                         const allocator_type&amp; a);
    <a href="#unordered_multiset_initializer_list_constructor_with_allocator">unordered_multiset</a>(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);
    <a href="#unordered_multiset_initializer_list_constructor_with_bucket_count_and_allocator">unordered_multiset</a>(std::initializer_list&lt;value_type&gt; il, size_type n,
                       const allocator_type&amp; a)
    <a href="#unordered_multiset_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_multiset</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                       const allocator_type&amp; a);
    <a href="#unordered_multiset_destructor">~unordered_multiset()</a>;
    unordered_multiset&amp; <a href="#unordered_multiset_copy_assignment">operator=</a>(const unordered_multiset&amp; other);
    unordered_multiset&amp; <a href="#unordered_multiset_move_assignment">operator=</a>(unordered_multiset&amp;&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Pred&gt;);
    unordered_multiset&amp; <a href="#unordered_multiset_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt; il);
    allocator_type <a href="#unordered_multiset_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_multiset_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_multiset_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_multiset_end">end</a>() noexcept;
    const_iterator <a href="#unordered_multiset_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_multiset_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_multiset_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_multiset_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_multiset_size">size</a>() const noexcept;
    size_type <a href="#unordered_multiset_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; iterator <a href="#unordered_multiset_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_multiset_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    iterator <a href="#unordered_multiset_copy_insert">insert</a>(const value_type&amp; obj);
    iterator <a href="#unordered_multiset_move_insert">insert</a>(value_type&amp;&amp; obj);
    iterator <a href="#unordered_multiset_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator <a href="#unordered_multiset_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    template&lt;class InputIterator&gt; void <a href="#unordered_multiset_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_multiset_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt; il);

    node_type <a href="#unordered_multiset_extract_by_iterator">extract</a>(const_iterator position);
    node_type <a href="#unordered_multiset_extract_by_value">extract</a>(const key_type&amp; k);
    template&lt;class K&gt; node_type <a href="#unordered_multiset_extract_by_value">extract</a>(K&amp;&amp; k);
    iterator <a href="#unordered_multiset_insert_with_node_handle">insert</a>(node_type&amp;&amp; nh);
    iterator <a href="#unordered_multiset_insert_with_hint_and_node_handle">insert</a>(const_iterator hint, node_type&amp;&amp; nh);

    iterator  <a href="#unordered_multiset_erase_by_position">erase</a>(iterator position);
    iterator  <a href="#unordered_multiset_erase_by_position">erase</a>(const_iterator position);
    size_type <a href="#unordered_multiset_erase_by_value">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_multiset_erase_by_value">erase</a>(K&amp;&amp; x);
    iterator  <a href="#unordered_multiset_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_multiset_quick_erase">quick_erase</a>(const_iterator position);
    void      <a href="#unordered_multiset_erase_return_void">erase_return_void</a>(const_iterator position);
    void      <a href="#unordered_multiset_swap">swap</a>(unordered_multiset&amp;)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Pred&gt;);
    void      <a href="#unordered_multiset_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multiset_merge">merge</a>(unordered_multiset&lt;Key, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multiset_merge">merge</a>(unordered_multiset&lt;Key, H2, P2, Allocator&gt;&amp;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multiset_merge">merge</a>(unordered_set&lt;Key, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multiset_merge">merge</a>(unordered_set&lt;Key, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_multiset_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_multiset_key_eq">key_eq</a>() const;

    // set operations
    iterator         <a href="#unordered_multiset_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_multiset_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_multiset_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_multiset_find">find</a>(const K&amp; k) const;
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      iterator       <a href="#unordered_multiset_find">find</a>(CompatibleKey const&amp;, CompatibleHash const&amp;,
                          CompatiblePredicate const&amp;);
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      const_iterator  <a href="#unordered_multiset_find">find</a>(CompatibleKey const&amp;, CompatibleHash const&amp;,
                           CompatiblePredicate const&amp;) const;
    size_type        <a href="#unordered_multiset_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_multiset_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_multiset_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_multiset_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_multiset_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_multiset_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_multiset_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_multiset_equal_range">equal_range</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_multiset_bucket_count">bucket_count</a>() const noexcept;
    size_type <a href="#unordered_multiset_max_bucket_count">max_bucket_count</a>() const noexcept;
    size_type <a href="#unordered_multiset_bucket_size">bucket_size</a>(size_type n) const;
    size_type <a href="#unordered_multiset_bucket">bucket</a>(const key_type&amp; k) const;
    template&lt;class K&gt; size_type <a href="#unordered_multiset_bucket">bucket</a>(const K&amp; k) const;
    local_iterator <a href="#unordered_multiset_begin_2">begin</a>(size_type n);
    const_local_iterator <a href="#unordered_multiset_begin_2">begin</a>(size_type n) const;
    local_iterator <a href="#unordered_multiset_end_2">end</a>(size_type n);
    const_local_iterator <a href="#unordered_multiset_end_2">end</a>(size_type n) const;
    const_local_iterator <a href="#unordered_multiset_cbegin_2">cbegin</a>(size_type n) const;
    const_local_iterator <a href="#unordered_multiset_cend_2">cend</a>(size_type n) const;

    // hash policy
    float <a href="#unordered_multiset_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_multiset_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_multiset_set_max_load_factor">max_load_factor</a>(float z);
    void <a href="#unordered_multiset_rehash">rehash</a>(size_type n);
    void <a href="#unordered_multiset_reserve">reserve</a>(size_type n);
  };

  // Deduction Guides
  template&lt;class InputIterator,
           class Hash = boost::hash&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
           class Pred = std::equal_to&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
           class Allocator = std::allocator&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;
    unordered_multiset(InputIterator, InputIterator, typename <a href="#unordered_multiset_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_multiset_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_multiset&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;, Hash, Pred, Allocator&gt;;

  template&lt;class T, class Hash = boost::hash&lt;T&gt;, class Pred = std::equal_to&lt;T&gt;,
           class Allocator = std::allocator&lt;T&gt;&gt;
    unordered_multiset(std::initializer_list&lt;T&gt;, typename <a href="#unordered_multiset_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_multiset_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_multiset&lt;T, Hash, Pred, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_multiset(InputIterator, InputIterator, typename <a href="#unordered_multiset_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_multiset&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_multiset(InputIterator, InputIterator, Allocator)
      -&gt; unordered_multiset&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Hash, class Allocator&gt;
    unordered_multiset(InputIterator, InputIterator, typename <a href="#unordered_multiset_deduction_guides"><em>see below</em></a>::size_type, Hash,
                       Allocator)
      -&gt; unordered_multiset&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;, Hash,
                            std::equal_to&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_multiset(std::initializer_list&lt;T&gt;, typename <a href="#unordered_multiset_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_multiset&lt;T, boost::hash&lt;T&gt;, std::equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_multiset(std::initializer_list&lt;T&gt;, Allocator)
      -&gt; unordered_multiset&lt;T, boost::hash&lt;T&gt;, std::equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Hash, class Allocator&gt;
    unordered_multiset(std::initializer_list&lt;T&gt;, typename <a href="#unordered_multiset_deduction_guides"><em>see below</em></a>::size_type, Hash, Allocator)
      -&gt; unordered_multiset&lt;T, Hash, std::equal_to&lt;T&gt;, Allocator&gt;;

  // Equality Comparisons
  template&lt;class Key, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_multiset_operator">operator==</a>(const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; y);

  template&lt;class Key, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_multiset_operator_2">operator!=</a>(const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; y);

  // swap
  template&lt;class Key, class Hash, class Pred, class Alloc&gt;
    void <a href="#unordered_multiset_swap_2">swap</a>(unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
              unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  template&lt;class K, class H, class P, class A, class Predicate&gt;
    typename unordered_multiset&lt;K, H, P, A&gt;::size_type
      <a href="#unordered_multiset_erase_if">erase_if</a>(unordered_multiset&lt;K, H, P, A&gt;&amp; c, Predicate pred);
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_multiset_description"><a class="anchor" href="#unordered_multiset_description"></a>Description</h3>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Key</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container (i.e. <code>allocator_traits</code> can destroy it).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that implements an equivalence relation on values of type <code>Key</code>. A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type bool.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket and elements with equivalent keys are stored next to each other.</p>
</div>
<div class="paragraph">
<p>The number of buckets can be automatically increased by a call to insert, or as the result of calling rehash.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_multiset_typedefs"><a class="anchor" href="#unordered_multiset_typedefs"></a>Typedefs</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef typename allocator_type::pointer pointer;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>value_type*</code> if <code>allocator_type::pointer</code> is not defined.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef typename allocator_type::const_pointer const_pointer;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>boost::pointer_to_other&lt;pointer, value_type&gt;::type</code> if <code>allocator_type::const_pointer</code> is not defined.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> size_type;</code></pre>
</div>
</div>
<div class="paragraph">
<p>An unsigned integral type.</p>
</div>
<div class="paragraph">
<p><code>size_type</code> can represent any non-negative value of <code>difference_type</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> difference_type;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A signed integral type.</p>
</div>
<div class="paragraph">
<p>Is identical to the difference type of <code>iterator</code> and <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> iterator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> const_iterator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> local_iterator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator with the same value type, difference type and pointer and reference type as iterator.</p>
</div>
<div class="paragraph">
<p>A <code>local_iterator</code> object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> const_local_iterator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator with the same value type, difference type and pointer and reference type as const_iterator.</p>
</div>
<div class="paragraph">
<p>A const_local_iterator object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> node_type;</code></pre>
</div>
</div>
<div class="paragraph">
<p>See node_handle_set for details.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_multiset_constructors"><a class="anchor" href="#unordered_multiset_constructors"></a>Constructors</h3>
<div class="sect3">
<h4 id="unordered_multiset_default_constructor"><a class="anchor" href="#unordered_multiset_default_constructor"></a>Default Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multiset();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate, <code>allocator_type()</code> as the allocator
and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_bucket_count_constructor"><a class="anchor" href="#unordered_multiset_bucket_count_constructor"></a>Bucket Count Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">explicit unordered_multiset(size_type n,
                            const hasher&amp; hf = hasher(),
                            const key_equal&amp; eql = key_equal(),
                            const allocator_type&amp; a = allocator_type());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum
load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_iterator_range_constructor"><a class="anchor" href="#unordered_multiset_iterator_range_constructor"></a>Iterator Range Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
  unordered_multiset(InputIterator f, InputIterator l,
                     size_type n = <em>implementation-defined</em>,
                     const hasher&amp; hf = hasher(),
                     const key_equal&amp; eql = key_equal(),
                     const allocator_type&amp; a = allocator_type());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_copy_constructor"><a class="anchor" href="#unordered_multiset_copy_constructor"></a>Copy Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multiset(const unordered_multiset&amp; other);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_move_constructor"><a class="anchor" href="#unordered_multiset_move_constructor"></a>Move Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multiset(unordered_multiset&amp;&amp; other);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move-constructible.<br></p>
<div class="paragraph">
<p>On compilers without rvalue reference support the emulation does not support moving without calling <code>boost::move</code> if <code>value_type</code> is not copyable.
So, for example, you can&#8217;t return the container from a function.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_iterator_range_constructor_with_allocator"><a class="anchor" href="#unordered_multiset_iterator_range_constructor_with_allocator"></a>Iterator Range Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
  unordered_multiset(InputIterator f, InputIterator l, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_allocator_constructor"><a class="anchor" href="#unordered_multiset_allocator_constructor"></a>Allocator Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">explicit unordered_multiset(const Allocator&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_copy_constructor_with_allocator"><a class="anchor" href="#unordered_multiset_copy_constructor_with_allocator"></a>Copy Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multiset(const unordered_multiset&amp; other, const Allocator&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an container, copying <code>other</code>'s contained elements, hash function, predicate, maximum load factor, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_move_constructor_with_allocator"><a class="anchor" href="#unordered_multiset_move_constructor_with_allocator"></a>Move Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multiset(unordered_multiset&amp;&amp; other, const Allocator&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Construct a container moving <code>other</code>'s contained elements, and having the hash function, predicate and maximum load factor, but using allocate <code>a</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move insertable.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_initializer_list_constructor"><a class="anchor" href="#unordered_multiset_initializer_list_constructor"></a>Initializer List Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multiset(std::initializer_list&lt;value_type&gt; il,
                   size_type n = <em>implementation-defined</em>,
                   const hasher&amp; hf = hasher(),
                   const key_equal&amp; eql = key_equal(),
                   const allocator_type&amp; a = allocator_type());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_bucket_count_constructor_with_allocator"><a class="anchor" href="#unordered_multiset_bucket_count_constructor_with_allocator"></a>Bucket Count Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multiset(size_type n, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_bucket_count_constructor_with_hasher_and_allocator"><a class="anchor" href="#unordered_multiset_bucket_count_constructor_with_hasher_and_allocator"></a>Bucket Count Constructor with Hasher and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multiset(size_type n, const hasher&amp; hf, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_iterator_range_constructor_with_bucket_count_and_allocator"><a class="anchor" href="#unordered_multiset_iterator_range_constructor_with_bucket_count_and_allocator"></a>Iterator Range Constructor with Bucket Count and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
  unordered_multiset(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_iterator_range_constructor_with_bucket_count_and_hasher"><a class="anchor" href="#unordered_multiset_iterator_range_constructor_with_bucket_count_and_hasher"></a>Iterator Range Constructor with Bucket Count and Hasher</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
  unordered_multiset(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                     const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_initializer_list_constructor_with_allocator"><a class="anchor" href="#unordered_multiset_initializer_list_constructor_with_allocator"></a>initializer_list Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multiset(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_initializer_list_constructor_with_bucket_count_and_allocator"><a class="anchor" href="#unordered_multiset_initializer_list_constructor_with_bucket_count_and_allocator"></a>initializer_list Constructor with Bucket Count and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multiset(std::initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="anchor" href="#unordered_multiset_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"></a>initializer_list Constructor with Bucket Count and Hasher and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">    unordered_multiset(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                       const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multiset_destructor"><a class="anchor" href="#unordered_multiset_destructor"></a>Destructor</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">~unordered_multiset();</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_multiset_assignment"><a class="anchor" href="#unordered_multiset_assignment"></a>Assignment</h3>
<div class="sect3">
<h4 id="unordered_multiset_copy_assignment"><a class="anchor" href="#unordered_multiset_copy_assignment"></a>Copy Assignment</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multiset&amp; operator=(const unordered_multiset&amp; other);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the copied elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_move_assignment"><a class="anchor" href="#unordered_multiset_move_assignment"></a>Move Assignment</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multiset&amp; operator=(unordered_multiset&amp;&amp; other)
  noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
           boost::is_nothrow_move_assignable_v&lt;Hash&gt; &amp;&amp;
           boost::is_nothrow_move_assignable_v&lt;Pred&gt;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the moved elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>On compilers without rvalue references, this is emulated using Boost.Move. Note that on some compilers the copy assignment operator may be used in some circumstances.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move constructible.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_initializer_list_assignment"><a class="anchor" href="#unordered_multiset_initializer_list_assignment"></a>Initializer List Assignment</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_multiset&amp; operator=(std::initializer_list&lt;value_type&gt; il);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All existing elements are either overwritten by the new elements or destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a> into the container and <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable" target="_blank" rel="noopener">CopyAssignable</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multiset_iterators"><a class="anchor" href="#unordered_multiset_iterators"></a>Iterators</h3>
<div class="sect3">
<h4 id="unordered_multiset_begin"><a class="anchor" href="#unordered_multiset_begin"></a>begin</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator       begin() noexcept;
const_iterator begin() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_end"><a class="anchor" href="#unordered_multiset_end"></a>end</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator       end() noexcept;
const_iterator end() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_cbegin"><a class="anchor" href="#unordered_multiset_cbegin"></a>cbegin</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">const_iterator cbegin() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_cend"><a class="anchor" href="#unordered_multiset_cend"></a>cend</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">const_iterator cend() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multiset_size_and_capacity"><a class="anchor" href="#unordered_multiset_size_and_capacity"></a>Size and Capacity</h3>
<div class="sect3">
<h4 id="unordered_multiset_empty"><a class="anchor" href="#unordered_multiset_empty"></a>empty</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">[[nodiscard]] bool empty() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_size"><a class="anchor" href="#unordered_multiset_size"></a>size</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type size() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_max_size"><a class="anchor" href="#unordered_multiset_max_size"></a>max_size</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type max_size() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multiset_modifiers"><a class="anchor" href="#unordered_multiset_modifiers"></a>Modifiers</h3>
<div class="sect3">
<h4 id="unordered_multiset_emplace"><a class="anchor" href="#unordered_multiset_emplace"></a>emplace</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class... Args&gt; iterator emplace(Args&amp;&amp;... args);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments args, in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to <code>10</code> arguments, with no support for rvalue references or move semantics.<br></p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_emplace_hint"><a class="anchor" href="#unordered_multiset_emplace_hint"></a>emplace_hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class... Args&gt; iterator emplace_hint(const_iterator position, Args&amp;&amp;... args);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments args, in the container.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to 10 arguments, with no support for rvalue references or move semantics.<br></p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_copy_insert"><a class="anchor" href="#unordered_multiset_copy_insert"></a>Copy Insert</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(const value_type&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_move_insert"><a class="anchor" href="#unordered_multiset_move_insert"></a>Move Insert</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(value_type&amp;&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_copy_insert_with_hint"><a class="anchor" href="#unordered_multiset_copy_insert_with_hint"></a>Copy Insert with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(const_iterator hint, const value_type&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_move_insert_with_hint"><a class="anchor" href="#unordered_multiset_move_insert_with_hint"></a>Move Insert with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(const_iterator hint, value_type&amp;&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_insert_iterator_range"><a class="anchor" href="#unordered_multiset_insert_iterator_range"></a>Insert Iterator Range</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt; void insert(InputIterator first, InputIterator last);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_insert_initializer_list"><a class="anchor" href="#unordered_multiset_insert_initializer_list"></a>Insert Initializer List</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void insert(std::initializer_list&lt;value_type&gt; il);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_extract_by_iterator"><a class="anchor" href="#unordered_multiset_extract_by_iterator"></a>Extract by Iterator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">node_type extract(const_iterator position);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_set</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_extract_by_value"><a class="anchor" href="#unordered_multiset_extract_by_value"></a>Extract by Value</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">node_type extract(const key_type&amp; k);
template&lt;class K&gt; node_type extract(K&amp;&amp; k);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes an element with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element if found, otherwise an empty <code>node_type</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_set</code>.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_insert_with_node_handle"><a class="anchor" href="#unordered_multiset_insert_with_node_handle"></a>Insert with <code>node_handle</code></h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(node_type&amp;&amp; nh);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty, returns <code>end()</code>.<br></p>
<div class="paragraph">
<p>Otherwise returns an iterator pointing to the newly inserted element.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_set</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_insert_with_hint_and_node_handle"><a class="anchor" href="#unordered_multiset_insert_with_hint_and_node_handle"></a>Insert with Hint and <code>node_handle</code></h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(const_iterator hint, node_type&amp;&amp; nh);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code>.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty, returns <code>end()</code>.<br></p>
<div class="paragraph">
<p>Otherwise returns an iterator pointing to the newly inserted element.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to hasher the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_set</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_erase_by_position"><a class="anchor" href="#unordered_multiset_erase_by_position"></a>Erase by Position</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator erase(iterator position);
iterator erase(const_iterator position);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following <code>position</code> before the erasure.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In older versions this could be inefficient because it had to search through several buckets to find the position of the returned iterator. The data structure has been changed so that this is no longer the case, and the alternative erase methods have been deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_erase_by_value"><a class="anchor" href="#unordered_multiset_erase_by_value"></a>Erase by Value</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type erase(const key_type&amp; k);
template&lt;class K&gt; size_type erase(K&amp;&amp; x);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_erase_range"><a class="anchor" href="#unordered_multiset_erase_range"></a>Erase Range</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator erase(const_iterator first, const_iterator last);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_quick_erase"><a class="anchor" href="#unordered_multiset_quick_erase"></a>quick_erase</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void quick_erase(const_iterator position);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_erase_return_void"><a class="anchor" href="#unordered_multiset_erase_return_void"></a>erase_return_void</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void erase_return_void(const_iterator position);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_swap"><a class="anchor" href="#unordered_multiset_swap"></a>swap</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void swap(unordered_multiset&amp;)
  noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
           boost::is_nothrow_swappable_v&lt;Hash&gt; &amp;&amp;
           boost::is_nothrow_swappable_v&lt;Pred&gt;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_clear"><a class="anchor" href="#unordered_multiset_clear"></a>clear</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void clear() noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Never throws an exception.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_merge"><a class="anchor" href="#unordered_multiset_merge"></a>merge</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class H2, class P2&gt;
  void merge(unordered_multiset&lt;Key, H2, P2, Allocator&gt;&amp; source);
template&lt;class H2, class P2&gt;
  void merge(unordered_multiset&lt;Key, H2, P2, Allocator&gt;&amp;&amp; source);
template&lt;class H2, class P2&gt;
  void merge(unordered_set&lt;Key, H2, P2, Allocator&gt;&amp; source);
template&lt;class H2, class P2&gt;
  void merge(unordered_set&lt;Key, H2, P2, Allocator&gt;&amp;&amp; source);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Attempt to "merge" two containers by iterating <code>source</code> and extracting all nodes in <code>source</code> and inserting them into <code>*this</code>.</p>
</div>
<div class="paragraph">
<p>Because <code>source</code> can have a different hash function and key equality predicate, the key of each node in
<code>source</code> is rehashed using <code>this-&gt;hash_function()</code> and then, if required, compared using <code>this-&gt;key_eq()</code>.</p>
</div>
<div class="paragraph">
<p>The behavior of this function is undefined if <code>this-&gt;get_allocator() != source.get_allocator()</code>.</p>
</div>
<div class="paragraph">
<p>This function does not copy or move any elements and instead simply relocates the nodes from <code>source</code>
into <code>*this</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Pointers and references to transferred elements remain valid.</p>
</li>
<li>
<p>Invalidates iterators to transferred elements.</p>
</li>
<li>
<p>Invalidates iterators belonging to <code>*this</code>.</p>
</li>
<li>
<p>Iterators to non-transferred elements in <code>source</code> remain valid.</p>
</li>
</ul>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multiset_observers"><a class="anchor" href="#unordered_multiset_observers"></a>Observers</h3>
<div class="sect3">
<h4 id="unordered_multiset_get_allocator"><a class="anchor" href="#unordered_multiset_get_allocator"></a>get_allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">allocator_type get_allocator() const noexcept;</code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_hash_function"><a class="anchor" href="#unordered_multiset_hash_function"></a>hash_function</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">hasher hash_function() const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_key_eq"><a class="anchor" href="#unordered_multiset_key_eq"></a>key_eq</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">key_equal key_eq() const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multiset_lookup"><a class="anchor" href="#unordered_multiset_lookup"></a>Lookup</h3>
<div class="sect3">
<h4 id="unordered_multiset_find"><a class="anchor" href="#unordered_multiset_find"></a>find</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator         find(const key_type&amp; k);
const_iterator   find(const key_type&amp; k) const;
template&lt;class K&gt;
  iterator       find(const K&amp; k);
template&lt;class K&gt;
  const_iterator find(const K&amp; k) const;
template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
  iterator       find(CompatibleKey const&amp;, CompatibleHash const&amp;,
                      CompatiblePredicate const&amp;);
template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
  const_iterator  find(CompatibleKey const&amp;, CompatibleHash const&amp;,
                       CompatiblePredicate const&amp;) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>b.end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The templated overloads containing <code>CompatibleKey</code>, <code>CompatibleHash</code> and <code>CompatiblePredicate</code> are non-standard extensions which allow you to use a compatible hash function and equality predicate for a key of a different type in order to avoid an expensive type cast. In general, its use is not encouraged and instead the <code>K</code> member function templates should be used.<br></p>
<div class="paragraph">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_count"><a class="anchor" href="#unordered_multiset_count"></a>count</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type        count(const key_type&amp; k) const;
template&lt;class K&gt;
  size_type      count(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_contains"><a class="anchor" href="#unordered_multiset_contains"></a>contains</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">bool             contains(const key_type&amp; k) const;
template&lt;class K&gt;
  bool           contains(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_equal_range"><a class="anchor" href="#unordered_multiset_equal_range"></a>equal_range</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::pair&lt;iterator, iterator&gt;               equal_range(const key_type&amp; k);
std::pair&lt;const_iterator, const_iterator&gt;   equal_range(const key_type&amp; k) const;
template&lt;class K&gt;
  std::pair&lt;iterator, iterator&gt;             equal_range(const K&amp; k);
template&lt;class K&gt;
  std::pair&lt;const_iterator, const_iterator&gt; equal_range(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multiset_bucket_interface"><a class="anchor" href="#unordered_multiset_bucket_interface"></a>Bucket Interface</h3>
<div class="sect3">
<h4 id="unordered_multiset_bucket_count"><a class="anchor" href="#unordered_multiset_bucket_count"></a>bucket_count</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type bucket_count() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_max_bucket_count"><a class="anchor" href="#unordered_multiset_max_bucket_count"></a>max_bucket_count</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type max_bucket_count() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An upper bound on the number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_bucket_size"><a class="anchor" href="#unordered_multiset_bucket_size"></a>bucket_size</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type bucket_size(size_type n) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n &lt; bucket_count()</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements in bucket <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_bucket"><a class="anchor" href="#unordered_multiset_bucket"></a>bucket</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type bucket(const key_type&amp; k) const;
template&lt;class K&gt; size_type bucket(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The index of the bucket which would contain an element with key <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p>The return value is less than <code>bucket_count()</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_begin_2"><a class="anchor" href="#unordered_multiset_begin_2"></a>begin</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">local_iterator begin(size_type n);
const_local_iterator begin(size_type n) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_end_2"><a class="anchor" href="#unordered_multiset_end_2"></a>end</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">local_iterator end(size_type n);
const_local_iterator end(size_type n) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_cbegin_2"><a class="anchor" href="#unordered_multiset_cbegin_2"></a>cbegin</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">const_local_iterator cbegin(size_type n) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_cend_2"><a class="anchor" href="#unordered_multiset_cend_2"></a>cend</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">const_local_iterator cend(size_type n) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multiset_hash_policy"><a class="anchor" href="#unordered_multiset_hash_policy"></a>Hash Policy</h3>
<div class="sect3">
<h4 id="unordered_multiset_load_factor"><a class="anchor" href="#unordered_multiset_load_factor"></a>load_factor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">float load_factor() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The average number of elements per bucket.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_max_load_factor"><a class="anchor" href="#unordered_multiset_max_load_factor"></a>max_load_factor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">float max_load_factor() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the current maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_set_max_load_factor"><a class="anchor" href="#unordered_multiset_set_max_load_factor"></a>Set max_load_factor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void max_load_factor(float z);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Changes the container&#8217;s maximum load factor, using <code>z</code> as a hint.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_rehash"><a class="anchor" href="#unordered_multiset_rehash"></a>rehash</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void rehash(size_type n);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes the number of buckets so that there are at least <code>n</code> buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the <code>bucket_count()</code> associated with the container.</p>
</div>
<div class="paragraph">
<p>When <code>size() == 0</code>, <code>rehash(0)</code> will deallocate the underlying buckets array.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_reserve"><a class="anchor" href="#unordered_multiset_reserve"></a>reserve</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void reserve(size_type n);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>a.rehash(ceil(n / a.max_load_factor()))</code>, or <code>a.rehash(1)</code> if <code>n &gt; 0</code> and <code>a.max_load_factor() == std::numeric_limits&lt;float&gt;::infinity()</code>.</p>
</div>
<div class="paragraph">
<p>Similar to <code>rehash</code>, this function can be used to grow or shrink the number of buckets in the container.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multiset_deduction_guides"><a class="anchor" href="#unordered_multiset_deduction_guides"></a>Deduction Guides</h3>
<div class="paragraph">
<p>A deduction guide will not participate in overload resolution if any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has an <code>InputIterator</code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p>
</li>
<li>
<p>It has an <code>Allocator</code> template parameter and a type that does not qualify as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Hash</code> template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Pred</code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>size_Â­type</code> parameter type in a deduction guide refers to the <code>size_Â­type</code> member type of the
container type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.</p>
</div>
<div class="sect3">
<h4 id="unordered_multiset_iter_value_type"><a class="anchor" href="#unordered_multiset_iter_value_type"></a><em>iter-value-type</em></h4>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-value-type</em> =
    typename std::iterator_traits&lt;InputIterator&gt;::value_type; // exposition only</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multiset_equality_comparisons"><a class="anchor" href="#unordered_multiset_equality_comparisons"></a>Equality Comparisons</h3>
<div class="sect3">
<h4 id="unordered_multiset_operator"><a class="anchor" href="#unordered_multiset_operator"></a>operator==</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class Key, class Hash, class Pred, class Alloc&gt;
  bool operator==(const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
                  const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; y);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The behavior of this function was changed to match the C++11 standard in Boost 1.48.<br></p>
<div class="paragraph">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_operator_2"><a class="anchor" href="#unordered_multiset_operator_2"></a>operator!=</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class Key, class Hash, class Pred, class Alloc&gt;
  bool operator!=(const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
                  const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; y);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The behavior of this function was changed to match the C++11 standard in Boost 1.48.<br></p>
<div class="paragraph">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multiset_swap_2"><a class="anchor" href="#unordered_multiset_swap_2"></a>Swap</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class Key, class Hash, class Pred, class Alloc&gt;
  void swap(unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
            unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; y)
    noexcept(noexcept(x.swap(y)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_multiset_erase_if"><a class="anchor" href="#unordered_multiset_erase_if"></a>erase_if</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class K, class H, class P, class A, class Predicate&gt;
  typename unordered_multiset&lt;K, H, P, A&gt;::size_type
    erase_if(unordered_multiset&lt;K, H, P, A&gt;&amp; c, Predicate pred);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">auto original_size = c.size();
for (auto i = c.begin(), last = c.end(); i != last; ) {
  if (pred(*i)) {
    i = c.erase(i);
  } else {
    ++i;
  }
}
return original_size - c.size();</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hash_traits"><a class="anchor" href="#hash_traits"></a>Hash traits</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="hash_traits_synopsis"><a class="anchor" href="#hash_traits_synopsis"></a>Synopsis</h3>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/hash_traits.hpp&gt;

namespace boost {
namespace unordered {

template&lt;typename Hash&gt;
struct <a href="#hash_traits_hash_is_avalanching">hash_is_avalanching</a>;

} // namespace unordered
} // namespace boost</pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="hash_traits_hash_is_avalanching"><a class="anchor" href="#hash_traits_hash_is_avalanching"></a>hash_is_avalanching</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;typename Hash&gt;
struct hash_is_avalanching;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A hash function is said to have the <em>avalanching property</em> if small changes in the input translate to
large changes in the returned hash code &#8212;ideally, flipping one bit in the representation of
the input value results in each bit of the hash code flipping with probability 50%. Approaching
this property is critical for the proper behavior of open-addressing hash containers.</p>
</div>
<div class="paragraph">
<p><code>hash_is_avalanching&lt;Hash&gt;::value</code> is <code>true</code> if <code>Hash::is_avalanching</code> is a valid type,
and <code>false</code> otherwise.
Users can then declare a hash function <code>Hash</code> as avalanching either by embedding an <code>is_avalanching</code> typedef
into the definition of <code>Hash</code>, or directly by specializing <code>hash_is_avalanching&lt;Hash&gt;</code> to a class with
an embedded compile-time constant <code>value</code> set to <code>true</code>.</p>
</div>
<div class="paragraph">
<p><a href="#unordered_flat_set"><code>boost::unordered_flat_set</code></a> and <a href="#unordered_flat_map"><code>boost::unordered_flat_map</code></a>
use the provided hash function <code>Hash</code> as-is if <code>hash_is_avalanching&lt;Hash&gt;::value</code> is <code>true</code>; otherwise, they
implement a bit-mixing post-processing stage to increase the quality of hashing at the expense of
extra computational cost.</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="unordered_flat_map"><a class="anchor" href="#unordered_flat_map"></a>Class template unordered_flat_map</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>boost::unordered_flat_map</code> â€” An open-addressing unordered associative container that associates unique keys with another value.</p>
</div>
<div class="paragraph">
<p>The performance of <code>boost::unordered_flat_map</code> is much better than that of <code>boost::unordered_map</code>
or other implementations of <code>std::unordered_map</code>. Unlike standard unordered associative containers,
which are node-based, the elements of a <code>boost::unordered_flat_map</code> are held directly in the bucket
array, and insertions into an already occupied bucket are diverted to available buckets in the
vicinity of the original position. This type of data layout is known as <em>open addressing</em>.</p>
</div>
<div class="paragraph">
<p>As a result of its using open addressing, the interface of <code>boost::unordered_flat_map</code> deviates in
a number of aspects from that of <code>boost::unordered_flat_map</code>/<code>std::unordered_flat_map</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>value_type</code> must be move-constructible.</p>
</li>
<li>
<p>Pointer stability is not kept under rehashing.</p>
</li>
<li>
<p><code>begin()</code> is not constant-time.</p>
</li>
<li>
<p><code>erase(iterator)</code> returns <code>void</code>.</p>
</li>
<li>
<p>There is no API for bucket handling (except <code>bucket_count</code>) or node extraction/insertion.</p>
</li>
<li>
<p>The maximum load factor of the container is managed internally and can&#8217;t be set by the user.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Other than this, <code>boost::unordered_flat_map</code> is mostly a drop-in replacement of node-based standard
unordered associative containers.</p>
</div>
<div class="sect2">
<h3 id="unordered_flat_map_synopsis"><a class="anchor" href="#unordered_flat_map_synopsis"></a>Synopsis</h3>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/unordered_flat_map.hpp&gt;

namespace boost {
  template&lt;class Key,
           class T,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
  class unordered_flat_map {
  public:
    // types
    using key_type             = Key;
    using mapped_type          = T;
    using value_type           = std::pair&lt;const Key, T&gt;;
    using init_type            = std::pair&lt;
                                   typename std::remove_const&lt;Key&gt;::type,
                                   typename std::remove_const&lt;T&gt;::type
                                 &gt;;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename std::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename std::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = std::size_t;
    using difference_type      = std::ptrdiff_t;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_flat_map_default_constructor">unordered_flat_map</a>();
    explicit <a href="#unordered_flat_map_bucket_count_constructor">unordered_flat_map</a>(size_type n,
                                const hasher&amp; hf = hasher(),
                                const key_equal&amp; eql = key_equal(),
                                const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_flat_map_iterator_range_constructor">unordered_flat_map</a>(InputIterator f, InputIterator l,
                         size_type n = <em>implementation-defined</em>,
                         const hasher&amp; hf = hasher(),
                         const key_equal&amp; eql = key_equal(),
                         const allocator_type&amp; a = allocator_type());
    <a href="#unordered_flat_map_copy_constructor">unordered_flat_map</a>(const unordered_flat_map&amp; other);
    <a href="#unordered_flat_map_move_constructor">unordered_flat_map</a>(unordered_flat_map&amp;&amp; other);
    template&lt;class InputIterator&gt;
      <a href="#unordered_flat_map_iterator_range_constructor_with_allocator">unordered_flat_map</a>(InputIterator f, InputIterator l, const allocator_type&amp; a);
    explicit <a href="#unordered_flat_map_allocator_constructor">unordered_flat_map</a>(const Allocator&amp; a);
    <a href="#unordered_flat_map_copy_constructor_with_allocator">unordered_flat_map</a>(const unordered_flat_map&amp; other, const Allocator&amp; a);
    <a href="#unordered_flat_map_move_constructor_with_allocator">unordered_flat_map</a>(unordered_flat_map&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_flat_map_initializer_list_constructor">unordered_flat_map</a>(std::initializer_list&lt;value_type&gt; il,
                       size_type n = <em>implementation-defined</em>
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
    <a href="#unordered_flat_map_bucket_count_constructor_with_allocator">unordered_flat_map</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_flat_map_bucket_count_constructor_with_hasher_and_allocator">unordered_flat_map</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_flat_map_iterator_range_constructor_with_bucket_count_and_allocator">unordered_flat_map</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_flat_map_iterator_range_constructor_with_bucket_count_and_hasher">unordered_flat_map</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                         const allocator_type&amp; a);
    <a href="#unordered_flat_map_initializer_list_constructor_with_allocator">unordered_flat_map</a>(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);
    <a href="#unordered_flat_map_initializer_list_constructor_with_bucket_count_and_allocator">unordered_flat_map</a>(std::initializer_list&lt;value_type&gt; il, size_type n,
                       const allocator_type&amp; a);
    <a href="#unordered_flat_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_flat_map</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                       const allocator_type&amp; a);
    <a href="#unordered_flat_map_destructor">~unordered_flat_map</a>();
    unordered_flat_map&amp; <a href="#unordered_flat_map_copy_assignment">operator=</a>(const unordered_flat_map&amp; other);
    unordered_flat_map&amp; <a href="#unordered_flat_map_move_assignment">operator=</a>(unordered_flat_map&amp;&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
              boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value);
    unordered_flat_map&amp; <a href="#unordered_flat_map_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt;);
    allocator_type <a href="#unordered_flat_map_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_flat_map_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_flat_map_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_flat_map_end">end</a>() noexcept;
    const_iterator <a href="#unordered_flat_map_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_flat_map_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_flat_map_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_flat_map_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_flat_map_size">size</a>() const noexcept;
    size_type <a href="#unordered_flat_map_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_flat_map_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_copy_insert">insert</a>(const value_type&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_copy_insert">insert</a>(const init_type&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_move_insert">insert</a>(value_type&amp;&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_move_insert">insert</a>(init_type&amp;&amp; obj);
    iterator       <a href="#unordered_flat_map_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator       <a href="#unordered_flat_map_copy_insert_with_hint">insert</a>(const_iterator hint, const init_type&amp; obj);
    iterator       <a href="#unordered_flat_map_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    iterator       <a href="#unordered_flat_map_copy_insert_with_hint">insert</a>(const_iterator hint, init_type&amp;&amp; obj);
    template&lt;class InputIterator&gt; void <a href="#unordered_flat_map_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_flat_map_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt;);

    template&lt;class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_try_emplace">try_emplace</a>(const key_type&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_try_emplace">try_emplace</a>(key_type&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class K, class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_try_emplace">try_emplace</a>(K&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      iterator <a href="#unordered_flat_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, const key_type&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      iterator <a href="#unordered_flat_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, key_type&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class K, class... Args&gt;
      iterator <a href="#unordered_flat_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, K&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_insert_or_assign">insert_or_assign</a>(const key_type&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_insert_or_assign">insert_or_assign</a>(key_type&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class K, class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_insert_or_assign">insert_or_assign</a>(K&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      iterator <a href="#unordered_flat_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, const key_type&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      iterator <a href="#unordered_flat_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, key_type&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class K, class M&gt;
      iterator <a href="#unordered_flat_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, K&amp;&amp; k, M&amp;&amp; obj);

    void      <a href="#unordered_flat_map_erase_by_position">erase</a>(iterator position);
    void      <a href="#unordered_flat_map_erase_by_position">erase</a>(const_iterator position);
    size_type <a href="#unordered_flat_map_erase_by_key">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_flat_map_erase_by_key">erase</a>(K&amp;&amp; k);
    iterator  <a href="#unordered_flat_map_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_flat_map_swap">swap</a>(unordered_flat_map&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
               boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_swap::value);
    void      <a href="#unordered_flat_map_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_flat_map_merge">merge</a>(unordered_flat_map&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_flat_map_merge">merge</a>(unordered_flat_map&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_flat_map_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_flat_map_key_eq">key_eq</a>() const;

    // map operations
    iterator         <a href="#unordered_flat_map_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_flat_map_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_flat_map_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_flat_map_find">find</a>(const K&amp; k) const;
    size_type        <a href="#unordered_flat_map_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_flat_map_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_flat_map_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_flat_map_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_flat_map_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_flat_map_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_flat_map_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_flat_map_equal_range">equal_range</a>(const K&amp; k) const;

    // element access
    mapped_type&amp; <a href="#unordered_flat_map_operator">operator[]</a>(const key_type&amp; k);
    mapped_type&amp; <a href="#unordered_flat_map_operator">operator[]</a>(key_type&amp;&amp; k);
    template&lt;class K&gt; mapped_type&amp; <a href="#unordered_flat_map_operator">operator[]</a>(K&amp;&amp; k);
    mapped_type&amp; <a href="#unordered_flat_map_at">at</a>(const key_type&amp; k);
    const mapped_type&amp; <a href="#unordered_flat_map_at">at</a>(const key_type&amp; k) const;
    template&lt;class K&gt; mapped_type&amp; <a href="#unordered_flat_map_at">at</a>(const K&amp; k);
    template&lt;class K&gt; const mapped_type&amp; <a href="#unordered_flat_map_at">at</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_flat_map_bucket_count">bucket_count</a>() const noexcept;

    // hash policy
    float <a href="#unordered_flat_map_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_flat_map_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_flat_map_set_max_load_factor">max_load_factor</a>(float z);
    size_type <a href="#unordered_flat_map_max_load">max_load</a>() const noexcept;
    void <a href="#unordered_flat_map_rehash">rehash</a>(size_type n);
    void <a href="#unordered_flat_map_reserve">reserve</a>(size_type n);
  };

  // Deduction Guides
  template&lt;class InputIterator,
           class Hash = boost::hash&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
           class Pred = std::equal_to&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
           class Allocator = std::allocator&lt;<a href="#unordered_flat_map_iter_to_alloc_type"><em>iter-to-alloc-type</em></a>&lt;InputIterator&gt;&gt;&gt;
    unordered_flat_map(InputIterator, InputIterator, typename <a href="#unordered_flat_map_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_flat_map_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_flat_map&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_flat_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;, Hash,
                            Pred, Allocator&gt;;

  template&lt;class Key, class T, class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
    unordered_flat_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;,
                       typename <a href="#unordered_flat_map_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_flat_map_deduction_guides"><em>see below</em></a>, Hash = Hash(),
                       Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_flat_map&lt;Key, T, Hash, Pred, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_flat_map(InputIterator, InputIterator, typename <a href="#unordered_flat_map_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_flat_map&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_flat_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_flat_map(InputIterator, InputIterator, Allocator)
      -&gt; unordered_flat_map&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_flat_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Hash, class Allocator&gt;
    unordered_flat_map(InputIterator, InputIterator, typename <a href="#unordered_flat_map_deduction_guides"><em>see below</em></a>::size_type, Hash,
                       Allocator)
      -&gt; unordered_flat_map&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_flat_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;, Hash,
                            std::equal_to&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Allocator&gt;
    unordered_flat_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, typename <a href="#unordered_flat_map_deduction_guides"><em>see below</em></a>::size_type,
                       Allocator)
      -&gt; unordered_flat_map&lt;Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Allocator&gt;
    unordered_flat_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, Allocator)
      -&gt; unordered_flat_map&lt;Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Hash, class Allocator&gt;
    unordered_flat_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, typename <a href="#unordered_flat_map_deduction_guides"><em>see below</em></a>::size_type,
                       Hash, Allocator)
      -&gt; unordered_flat_map&lt;Key, T, Hash, std::equal_to&lt;Key&gt;, Allocator&gt;;

  // Equality Comparisons
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_flat_map_operator_2">operator==</a>(const unordered_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_flat_map_operator_3">operator!=</a>(const unordered_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  // swap
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    void <a href="#unordered_flat_map_swap_2">swap</a>(unordered_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
              unordered_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
    typename unordered_flat_map&lt;K, T, H, P, A&gt;::size_type
       <a href="#unordered_flat_map_erase_if">erase_if</a>(unordered_flat_map&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_flat_map_description"><a class="anchor" href="#unordered_flat_map_description"></a>Description</h3>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock"><code>Key</code> and <code>T</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/MoveConstructible" target="_blank" rel="noopener">MoveConstructible</a>.
<code>std::pair&lt;const Key, T&gt;</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a>
into the container from any <code>std::pair</code> object convertible to it, and it also must be
<a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>T</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type <code>bool</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.
<code>std::allocator_traits&lt;Allocator&gt;::pointer</code> and <code>std::allocator_traits&lt;Allocator&gt;::const_pointer</code>
must be convertible to/from <code>value_type*</code> and <code>const value_type*</code>, respectively.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The elements of the container are held into an internal <em>bucket array</em>. An element is inserted into a bucket determined by its
hash code, but if the bucket is already occupied (a <em>collision</em>), an available one in the vicinity of the
original position is used.</p>
</div>
<div class="paragraph">
<p>The size of the bucket array can be automatically increased by a call to <code>insert</code>/<code>emplace</code>, or as a result of calling
<code>rehash</code>/<code>reserve</code>. The <em>load factor</em> of the container (number of elements divided by number of buckets) is never
greater than <code>max_load_factor()</code>, except possibly for small sizes where the implementation may decide to
allow for higher loads.</p>
</div>
<div class="paragraph">
<p>If <code><a href="#hash_traits_hash_is_avalanching">hash_is_avalanching</a>&lt;Hash&gt;::value</code> is <code>true</code>, the hash function
is used as-is; otherwise, a bit-mixing post-processing stage is added to increase the quality of hashing
at the expense of extra computational cost.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_flat_map_typedefs"><a class="anchor" href="#unordered_flat_map_typedefs"></a>Typedefs</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> iterator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> const_iterator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_map_constructors"><a class="anchor" href="#unordered_flat_map_constructors"></a>Constructors</h3>
<div class="sect3">
<h4 id="unordered_flat_map_default_constructor"><a class="anchor" href="#unordered_flat_map_default_constructor"></a>Default Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_map();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate and <code>allocator_type()</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_bucket_count_constructor"><a class="anchor" href="#unordered_flat_map_bucket_count_constructor"></a>Bucket Count Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">explicit unordered_flat_map(size_type n,
                            const hasher&amp; hf = hasher(),
                            const key_equal&amp; eql = key_equal(),
                            const allocator_type&amp; a = allocator_type());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_iterator_range_constructor"><a class="anchor" href="#unordered_flat_map_iterator_range_constructor"></a>Iterator Range Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
  unordered_flat_map(InputIterator f, InputIterator l,
                     size_type n = <em>implementation-defined</em>,
                     const hasher&amp; hf = hasher(),
                     const key_equal&amp; eql = key_equal(),
                     const allocator_type&amp; a = allocator_type());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code> as the allocator, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_copy_constructor"><a class="anchor" href="#unordered_flat_map_copy_constructor"></a>Copy Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_map(unordered_flat_map const&amp; other);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_move_constructor"><a class="anchor" href="#unordered_flat_map_move_constructor"></a>Move Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_map(unordered_flat_map&amp;&amp; other);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor. The internal bucket array of <code>other</code> is transferred directly to the new container.
The hash function, predicate and allocator are moved-constructed from <code>other</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_iterator_range_constructor_with_allocator"><a class="anchor" href="#unordered_flat_map_iterator_range_constructor_with_allocator"></a>Iterator Range Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
  unordered_flat_map(InputIterator f, InputIterator l, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator, with the default hash function and key equality predicate and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_allocator_constructor"><a class="anchor" href="#unordered_flat_map_allocator_constructor"></a>Allocator Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">explicit unordered_flat_map(Allocator const&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_copy_constructor_with_allocator"><a class="anchor" href="#unordered_flat_map_copy_constructor_with_allocator"></a>Copy Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_map(unordered_flat_map const&amp; other, Allocator const&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs a container, copying <code>other</code>'s contained elements, hash function, and predicate, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_move_constructor_with_allocator"><a class="anchor" href="#unordered_flat_map_move_constructor_with_allocator"></a>Move Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_map(unordered_flat_map&amp;&amp; other, Allocator const&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>a == other.get_allocator()</code>, the elements of <code>other</code> are transferred directly to the new container;
otherwise, elements are moved-constructed from those of <code>other</code>. The hash function and predicate are moved-constructed
from <code>other</code>, and the allocator is copy-constructed from <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_initializer_list_constructor"><a class="anchor" href="#unordered_flat_map_initializer_list_constructor"></a>Initializer List Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_map(std::initializer_list&lt;value_type&gt; il,
              size_type n = <em>implementation-defined</em>
              const hasher&amp; hf = hasher(),
              const key_equal&amp; eql = key_equal(),
              const allocator_type&amp; a = allocator_type());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code>, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_bucket_count_constructor_with_allocator"><a class="anchor" href="#unordered_flat_map_bucket_count_constructor_with_allocator"></a>Bucket Count Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_map(size_type n, allocator_type const&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_bucket_count_constructor_with_hasher_and_allocator"><a class="anchor" href="#unordered_flat_map_bucket_count_constructor_with_hasher_and_allocator"></a>Bucket Count Constructor with Hasher and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_map(size_type n, hasher const&amp; hf, allocator_type const&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_iterator_range_constructor_with_bucket_count_and_allocator"><a class="anchor" href="#unordered_flat_map_iterator_range_constructor_with_bucket_count_and_allocator"></a>Iterator Range Constructor with Bucket Count and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
  unordered_flat_map(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and default hash function and key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_iterator_range_constructor_with_bucket_count_and_hasher"><a class="anchor" href="#unordered_flat_map_iterator_range_constructor_with_bucket_count_and_hasher"></a>Iterator Range Constructor with Bucket Count and Hasher</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">    template&lt;class InputIterator&gt;
      unordered_flat_map(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                         const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_initializer_list_constructor_with_allocator"><a class="anchor" href="#unordered_flat_map_initializer_list_constructor_with_allocator"></a>initializer_list Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_map(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_initializer_list_constructor_with_bucket_count_and_allocator"><a class="anchor" href="#unordered_flat_map_initializer_list_constructor_with_bucket_count_and_allocator"></a>initializer_list Constructor with Bucket Count and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_map(std::initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="anchor" href="#unordered_flat_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"></a>initializer_list Constructor with Bucket Count and Hasher and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_map(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                   const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and default key equality predicate,and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_map_destructor"><a class="anchor" href="#unordered_flat_map_destructor"></a>Destructor</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">~unordered_flat_map();</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_flat_map_assignment"><a class="anchor" href="#unordered_flat_map_assignment"></a>Assignment</h3>
<div class="sect3">
<h4 id="unordered_flat_map_copy_assignment"><a class="anchor" href="#unordered_flat_map_copy_assignment"></a>Copy Assignment</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_map&amp; operator=(unordered_flat_map const&amp; other);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Destroys previously existing elements, copy-assigns the hash function and predicate from <code>other</code>,
copy-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>,
and finally inserts copies of the elements of <code>other</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_move_assignment"><a class="anchor" href="#unordered_flat_map_move_assignment"></a>Move Assignment</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_map&amp; operator=(unordered_flat_map&amp;&amp; other)
  noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
           boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator. Destroys previously existing elements, swaps the hash function and predicate from <code>other</code>,
and move-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>.
If at this point the allocator is equal to <code>other.get_allocator()</code>, the internal bucket array of <code>other</code> is transferred directly to the new container;
otherwise, inserts move-constructed copies of the elements of <code>other</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_initializer_list_assignment"><a class="anchor" href="#unordered_flat_map_initializer_list_assignment"></a>Initializer List Assignment</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_map&amp; operator=(std::initializer_list&lt;value_type&gt; il);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All previously existing elements are destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_map_iterators"><a class="anchor" href="#unordered_flat_map_iterators"></a>Iterators</h3>
<div class="sect3">
<h4 id="unordered_flat_map_begin"><a class="anchor" href="#unordered_flat_map_begin"></a>begin</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator begin() noexcept;
const_iterator begin() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>O(<code>bucket_count()</code>)</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_end"><a class="anchor" href="#unordered_flat_map_end"></a>end</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator end() noexcept;
const_iterator end() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_cbegin"><a class="anchor" href="#unordered_flat_map_cbegin"></a>cbegin</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">const_iterator cbegin() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>O(<code>bucket_count()</code>)</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_cend"><a class="anchor" href="#unordered_flat_map_cend"></a>cend</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">const_iterator cend() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_map_size_and_capacity"><a class="anchor" href="#unordered_flat_map_size_and_capacity"></a>Size and Capacity</h3>
<div class="sect3">
<h4 id="unordered_flat_map_empty"><a class="anchor" href="#unordered_flat_map_empty"></a>empty</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">[[nodiscard]] bool empty() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_size"><a class="anchor" href="#unordered_flat_map_size"></a>size</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type size() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_max_size"><a class="anchor" href="#unordered_flat_map_max_size"></a>max_size</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type max_size() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_map_modifiers"><a class="anchor" href="#unordered_flat_map_modifiers"></a>Modifiers</h3>
<div class="sect3">
<h4 id="unordered_flat_map_emplace"><a class="anchor" href="#unordered_flat_map_emplace"></a>emplace</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class... Args&gt; std::pair&lt;iterator, bool&gt; emplace(Args&amp;&amp;... args);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_emplace_hint"><a class="anchor" href="#unordered_flat_map_emplace_hint"></a>emplace_hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">    template&lt;class... Args&gt; iterator emplace_hint(const_iterator position, Args&amp;&amp;... args);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>position</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_copy_insert"><a class="anchor" href="#unordered_flat_map_copy_insert"></a>Copy Insert</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::pair&lt;iterator, bool&gt; insert(const value_type&amp; obj);
std::pair&lt;iterator, bool&gt; insert(const init_type&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>A call of the form <code>insert(x)</code>, where <code>x</code> is equally convertible to both <code>const value_type&amp;</code> and <code>const init_type&amp;</code>, is not ambiguous and selects the <code>init_type</code> overload.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_move_insert"><a class="anchor" href="#unordered_flat_map_move_insert"></a>Move Insert</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::pair&lt;iterator, bool&gt; insert(value_type&amp;&amp; obj);
std::pair&lt;iterator, bool&gt; insert(init_type&amp;&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>A call of the form <code>insert(x)</code>, where <code>x</code> is equally convertible to both <code>value_type&amp;&amp;</code> and <code>init_type&amp;&amp;</code>, is not ambiguous and selects the <code>init_type</code> overload.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_copy_insert_with_hint"><a class="anchor" href="#unordered_flat_map_copy_insert_with_hint"></a>Copy Insert with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(const_iterator hint, const value_type&amp; obj);
iterator insert(const_iterator hint, const init_type&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>A call of the form <code>insert(hint, x)</code>, where <code>x</code> is equally convertible to both <code>const value_type&amp;</code> and <code>const init_type&amp;</code>, is not ambiguous and selects the <code>init_type</code> overload.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_move_insert_with_hint"><a class="anchor" href="#unordered_flat_map_move_insert_with_hint"></a>Move Insert with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(const_iterator hint, value_type&amp;&amp; obj);
iterator insert(const_iterator hint, init_type&amp;&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>A call of the form <code>insert(hint, x)</code>, where <code>x</code> is equally convertible to both <code>value_type&amp;&amp;</code> and <code>init_type&amp;&amp;</code>, is not ambiguous and selects the <code>init_type</code> overload.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_insert_iterator_range"><a class="anchor" href="#unordered_flat_map_insert_iterator_range"></a>Insert Iterator Range</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt; void insert(InputIterator first, InputIterator last);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into the container from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_insert_initializer_list"><a class="anchor" href="#unordered_flat_map_insert_initializer_list"></a>Insert Initializer List</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void insert(std::initializer_list&lt;value_type&gt;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into the container from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_try_emplace"><a class="anchor" href="#unordered_flat_map_try_emplace"></a>try_emplace</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class... Args&gt;
  std::pair&lt;iterator, bool&gt; try_emplace(const key_type&amp; k, Args&amp;&amp;... args);
template&lt;class... Args&gt;
  std::pair&lt;iterator, bool&gt; try_emplace(key_type&amp;&amp; k, Args&amp;&amp;... args);
template&lt;class K, class... Args&gt;
  std::pair&lt;iterator, bool&gt; try_emplace(K&amp;&amp; k, Args&amp;&amp;... args);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new node into the container if there is no existing element with key <code>k</code> contained within it.</p>
</div>
<div class="paragraph">
<p>If there is an existing element with key <code>k</code> this function does nothing.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This function is similiar to <a href="#unordered_flat_map_emplace">emplace</a>, with the difference that no <code>value_type</code> is constructed
if there is an element with an equivalent key; otherwise, the construction is of the form:<br></p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">// first two overloads
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward&lt;Key&gt;(k)),
           std::forward_as_tuple(boost::forward&lt;Args&gt;(args)...))

// third overload
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward&lt;K&gt;(k)),
           std::forward_as_tuple(boost::forward&lt;Args&gt;(args)...))</code></pre>
</div>
</div>
<div class="paragraph">
<p>unlike <a href="#unordered_flat_map_emplace">emplace</a>, which simply forwards all arguments to <code>value_type</code>'s constructor.</p>
</div>
<div class="paragraph">
<p>Can invalidate iterators pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</div>
<div class="paragraph">
<p>The <code>template &lt;class K, class&#8230;&#8203; Args&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_try_emplace_with_hint"><a class="anchor" href="#unordered_flat_map_try_emplace_with_hint"></a>try_emplace with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class... Args&gt;
  iterator try_emplace(const_iterator hint, const key_type&amp; k, Args&amp;&amp;... args);
template&lt;class... Args&gt;
  iterator try_emplace(const_iterator hint, key_type&amp;&amp; k, Args&amp;&amp;... args);
template&lt;class K, class... Args&gt;
  iterator try_emplace(const_iterator hint, K&amp;&amp; k, Args&amp;&amp;... args);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new node into the container if there is no existing element with key <code>k</code> contained within it.</p>
</div>
<div class="paragraph">
<p>If there is an existing element with key <code>k</code> this function does nothing.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.  This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This function is similiar to <a href="#unordered_flat_map_emplace_hint">emplace_hint</a>, with the difference that no <code>value_type</code> is constructed
if there is an element with an equivalent key; otherwise, the construction is of the form:<br></p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">// first two overloads
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward&lt;Key&gt;(k)),
           std::forward_as_tuple(boost::forward&lt;Args&gt;(args)...))

// third overload
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward&lt;K&gt;(k)),
           std::forward_as_tuple(boost::forward&lt;Args&gt;(args)...))</code></pre>
</div>
</div>
<div class="paragraph">
<p>unlike <a href="#unordered_flat_map_emplace_hint">emplace_hint</a>, which simply forwards all arguments to <code>value_type</code>'s constructor.</p>
</div>
<div class="paragraph">
<p>Can invalidate iterators pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</div>
<div class="paragraph">
<p>The <code>template &lt;class K, class&#8230;&#8203; Args&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_insert_or_assign"><a class="anchor" href="#unordered_flat_map_insert_or_assign"></a>insert_or_assign</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class M&gt;
  std::pair&lt;iterator, bool&gt; insert_or_assign(const key_type&amp; k, M&amp;&amp; obj);
template&lt;class M&gt;
  std::pair&lt;iterator, bool&gt; insert_or_assign(key_type&amp;&amp; k, M&amp;&amp; obj);
template&lt;class K, class M&gt;
  std::pair&lt;iterator, bool&gt; insert_or_assign(K&amp;&amp; k, M&amp;&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the container or updates an existing one by assigning to the contained value.</p>
</div>
<div class="paragraph">
<p>If there is an element with key <code>k</code>, then it is updated by assigning <code>boost::forward&lt;M&gt;(obj)</code>.</p>
</div>
<div class="paragraph">
<p>If there is no such element, it is added to the container as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">// first two overloads
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward&lt;Key&gt;(k)),
           std::forward_as_tuple(boost::forward&lt;M&gt;(obj)))

// third overload
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward&lt;K&gt;(k)),
           std::forward_as_tuple(boost::forward&lt;M&gt;(obj)))</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators pointers and references, but only if the insert causes the load to be greater than the maximum load. <br></p>
<div class="paragraph">
<p>The <code>template&lt;class K, class M&gt;</code> only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_insert_or_assign_with_hint"><a class="anchor" href="#unordered_flat_map_insert_or_assign_with_hint"></a>insert_or_assign with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class M&gt;
  iterator insert_or_assign(const_iterator hint, const key_type&amp; k, M&amp;&amp; obj);
template&lt;class M&gt;
  iterator insert_or_assign(const_iterator hint, key_type&amp;&amp; k, M&amp;&amp; obj);
template&lt;class K, class M&gt;
  iterator insert_or_assign(const_iterator hint, K&amp;&amp; k, M&amp;&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the container or updates an existing one by assigning to the contained value.</p>
</div>
<div class="paragraph">
<p>If there is an element with key <code>k</code>, then it is updated by assigning <code>boost::forward&lt;M&gt;(obj)</code>.</p>
</div>
<div class="paragraph">
<p>If there is no such element, it is added to the container as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">// first two overloads
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward&lt;Key&gt;(k)),
           std::forward_as_tuple(boost::forward&lt;M&gt;(obj)))

// third overload
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward&lt;K&gt;(k)),
           std::forward_as_tuple(boost::forward&lt;M&gt;(obj)))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K, class M&gt;</code> only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_erase_by_position"><a class="anchor" href="#unordered_flat_map_erase_by_position"></a>Erase by Position</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void erase(iterator position);
void erase(const_iterator position);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_erase_by_key"><a class="anchor" href="#unordered_flat_map_erase_by_key"></a>Erase by Key</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type erase(const key_type&amp; k);
template&lt;class K&gt; size_type erase(K&amp;&amp; k);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_erase_range"><a class="anchor" href="#unordered_flat_map_erase_range"></a>Erase Range</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator erase(const_iterator first, const_iterator last);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing in this implementation (neither the <code>hasher</code> nor the <code>key_equal</code> objects are called).</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_swap"><a class="anchor" href="#unordered_flat_map_swap"></a>swap</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void swap(unordered_flat_map&amp; other)
  noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
           boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_swap::value);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing unless <code>key_equal</code> or <code>hasher</code> throw on swapping.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_clear"><a class="anchor" href="#unordered_flat_map_clear"></a>clear</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void clear() noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code>, <code>max_load() &gt;= max_load_factor() * bucket_count()</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_merge"><a class="anchor" href="#unordered_flat_map_merge"></a>merge</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class H2, class P2&gt;
  void merge(unordered_flat_map&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
template&lt;class H2, class P2&gt;
  void merge(unordered_flat_map&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Move-inserts all the elements from <code>source</code> whose key is not already present in <code>*this</code>, and erases them from <code>source</code>.</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_map_observers"><a class="anchor" href="#unordered_flat_map_observers"></a>Observers</h3>
<div class="sect3">
<h4 id="unordered_flat_map_get_allocator"><a class="anchor" href="#unordered_flat_map_get_allocator"></a>get_allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">allocator_type get_allocator() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s allocator.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_hash_function"><a class="anchor" href="#unordered_flat_map_hash_function"></a>hash_function</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">hasher hash_function() const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_key_eq"><a class="anchor" href="#unordered_flat_map_key_eq"></a>key_eq</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">key_equal key_eq() const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_map_lookup"><a class="anchor" href="#unordered_flat_map_lookup"></a>Lookup</h3>
<div class="sect3">
<h4 id="unordered_flat_map_find"><a class="anchor" href="#unordered_flat_map_find"></a>find</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator         find(const key_type&amp; k);
const_iterator   find(const key_type&amp; k) const;
template&lt;class K&gt;
  iterator       find(const K&amp; k);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_count"><a class="anchor" href="#unordered_flat_map_count"></a>count</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type        count(const key_type&amp; k) const;
template&lt;class K&gt;
  size_type      count(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_contains"><a class="anchor" href="#unordered_flat_map_contains"></a>contains</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">bool             contains(const key_type&amp; k) const;
template&lt;class K&gt;
  bool           contains(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_equal_range"><a class="anchor" href="#unordered_flat_map_equal_range"></a>equal_range</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::pair&lt;iterator, iterator&gt;               equal_range(const key_type&amp; k);
std::pair&lt;const_iterator, const_iterator&gt;   equal_range(const key_type&amp; k) const;
template&lt;class K&gt;
  std::pair&lt;iterator, iterator&gt;             equal_range(const K&amp; k);
template&lt;class K&gt;
  std::pair&lt;const_iterator, const_iterator&gt; equal_range(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_operator"><a class="anchor" href="#unordered_flat_map_operator"></a>operator[]</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">mapped_type&amp; operator[](const key_type&amp; k);
mapped_type&amp; operator[](key_type&amp;&amp; k);
template&lt;class K&gt; mapped_type&amp; operator[](K&amp;&amp; k);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>If the container does not already contain an element with a key equivalent to <code>k</code>, inserts the value <code>std::pair&lt;key_type const, mapped_type&gt;(k, mapped_type())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A reference to <code>x.second</code> where <code>x</code> is the element already in the container, or the newly inserted element with a key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_at"><a class="anchor" href="#unordered_flat_map_at"></a>at</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">mapped_type&amp; at(const key_type&amp; k);
const mapped_type&amp; at(const key_type&amp; k) const;
template&lt;class K&gt; mapped_type&amp; at(const K&amp; k);
template&lt;class K&gt; const mapped_type&amp; at(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A reference to <code>x.second</code> where <code>x</code> is the (unique) element whose key is equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>An exception object of type <code>std::out_of_range</code> if no such element is present.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_map_bucket_interface"><a class="anchor" href="#unordered_flat_map_bucket_interface"></a>Bucket Interface</h3>
<div class="sect3">
<h4 id="unordered_flat_map_bucket_count"><a class="anchor" href="#unordered_flat_map_bucket_count"></a>bucket_count</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type bucket_count() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The size of the bucket array.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_map_hash_policy"><a class="anchor" href="#unordered_flat_map_hash_policy"></a>Hash Policy</h3>
<div class="sect3">
<h4 id="unordered_flat_map_load_factor"><a class="anchor" href="#unordered_flat_map_load_factor"></a>load_factor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">float load_factor() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>static_cast&lt;float&gt;(size())/static_cast&lt;float&gt;(bucket_count())</code>, or <code>0</code> if <code>bucket_count() == 0</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_max_load_factor"><a class="anchor" href="#unordered_flat_map_max_load_factor"></a>max_load_factor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">float max_load_factor() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the container&#8217;s maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_set_max_load_factor"><a class="anchor" href="#unordered_flat_map_set_max_load_factor"></a>Set max_load_factor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void max_load_factor(float z);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Does nothing, as the user is not allowed to change this parameter. Kept for compatibility with <code>boost::unordered_map</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_max_load"><a class="anchor" href="#unordered_flat_map_max_load"></a>max_load</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type max_load() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The maximum number of elements the container can hold without rehashing, assuming that no further elements will be erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>After construction, rehash or clearance, the container&#8217;s maximum load is at least <code>max_load_factor() * bucket_count()</code>.
This number may decrease on erasure under high-load conditions.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_rehash"><a class="anchor" href="#unordered_flat_map_rehash"></a>rehash</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void rehash(size_type n);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes if necessary the size of the bucket array so that there are at least <code>n</code> buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the <code>bucket_count()</code> associated with the container.</p>
</div>
<div class="paragraph">
<p>When <code>size() == 0</code>, <code>rehash(0)</code> will deallocate the underlying buckets array.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, pointers and references, and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_reserve"><a class="anchor" href="#unordered_flat_map_reserve"></a>reserve</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void reserve(size_type n);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>a.rehash(ceil(n / a.max_load_factor()))</code>.</p>
</div>
<div class="paragraph">
<p>Similar to <code>rehash</code>, this function can be used to grow or shrink the number of buckets in the container.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, pointers and references, and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_map_deduction_guides"><a class="anchor" href="#unordered_flat_map_deduction_guides"></a>Deduction Guides</h3>
<div class="paragraph">
<p>A deduction guide will not participate in overload resolution if any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has an <code>InputIterator</code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p>
</li>
<li>
<p>It has an <code>Allocator</code> template parameter and a type that does not qualify as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Hash</code> template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Pred</code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>size_Â­type</code> parameter type in a deduction guide refers to the <code>size_Â­type</code> member type of the
container type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.</p>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_iter_value_type"><a class="anchor" href="#unordered_flat_map_iter_value_type"></a><em>iter-value-type</em></h4>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-value-type</em> =
    typename std::iterator_traits&lt;InputIterator&gt;::value_type; // exposition only</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_iter_key_type"><a class="anchor" href="#unordered_flat_map_iter_key_type"></a><em>iter-key-type</em></h4>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-key-type</em> = std::remove_const_t&lt;
    std::tuple_element_t&lt;0, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;; // exposition only</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_iter_mapped_type"><a class="anchor" href="#unordered_flat_map_iter_mapped_type"></a><em>iter-mapped-type</em></h4>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-mapped-type</em> =
    std::tuple_element_t&lt;1, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;;  // exposition only</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_iter_to_alloc_type"><a class="anchor" href="#unordered_flat_map_iter_to_alloc_type"></a><em>iter-to-alloc-type</em></h4>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-to-alloc-type</em> = std::pair&lt;
    std::add_const_t&lt;std::tuple_element_t&lt;0, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;,
    std::tuple_element_t&lt;1, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;; // exposition only</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_map_equality_comparisons"><a class="anchor" href="#unordered_flat_map_equality_comparisons"></a>Equality Comparisons</h3>
<div class="sect3">
<h4 id="unordered_flat_map_operator_2"><a class="anchor" href="#unordered_flat_map_operator_2"></a>operator==</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
  bool operator==(const unordered_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                  const unordered_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_operator_3"><a class="anchor" href="#unordered_flat_map_operator_3"></a>operator!=</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
  bool operator!=(const unordered_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                  const unordered_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_map_swap_2"><a class="anchor" href="#unordered_flat_map_swap_2"></a>Swap</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
  void swap(unordered_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
            unordered_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
    noexcept(noexcept(x.swap(y)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing unless <code>key_equal</code> or <code>hasher</code> throw on swapping.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_flat_map_erase_if"><a class="anchor" href="#unordered_flat_map_erase_if"></a>erase_if</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
  typename unordered_flat_map&lt;K, T, H, P, A&gt;::size_type
    erase_if(unordered_flat_map&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">auto original_size = c.size();
for (auto i = c.begin(), last = c.end(); i != last; ) {
  if (pred(*i)) {
    i = c.erase(i);
  } else {
    ++i;
  }
}
return original_size - c.size();</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="unordered_flat_set"><a class="anchor" href="#unordered_flat_set"></a>Class template unordered_flat_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>boost::unordered_flat_set</code> â€” An open-addressing unordered associative container that stores unique values.</p>
</div>
<div class="paragraph">
<p>The performance of <code>boost::unordered_flat_set</code> is much better than that of <code>boost::unordered_set</code>
or other implementations of <code>std::unordered_set</code>. Unlike standard unordered associative containers,
which are node-based, the elements of a <code>boost::unordered_flat_set</code> are held directly in the bucket
array, and insertions into an already occupied bucket are diverted to available buckets in the
vicinity of the original position. This type of data layout is known as <em>open addressing</em>.</p>
</div>
<div class="paragraph">
<p>As a result of its using open addressing, the interface of <code>boost::unordered_flat_set</code> deviates in
a number of aspects from that of <code>boost::unordered_flat_set</code>/<code>std::unordered_flat_set</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>value_type</code> must be move-constructible.</p>
</li>
<li>
<p>Pointer stability is not kept under rehashing.</p>
</li>
<li>
<p><code>begin()</code> is not constant-time.</p>
</li>
<li>
<p><code>erase(iterator)</code> returns <code>void</code>.</p>
</li>
<li>
<p>There is no API for bucket handling (except <code>bucket_count</code>) or node extraction/insertion.</p>
</li>
<li>
<p>The maximum load factor of the container is managed internally and can&#8217;t be set by the user.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Other than this, <code>boost::unordered_flat_set</code> is mostly a drop-in replacement of node-based standard
unordered associative containers.</p>
</div>
<div class="sect2">
<h3 id="unordered_flat_set_synopsis"><a class="anchor" href="#unordered_flat_set_synopsis"></a>Synopsis</h3>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/unordered_flat_set.hpp&gt;

namespace boost {
  template&lt;class Key,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;Key&gt;&gt;
  class unordered_flat_set {
  public:
    // types
    using key_type             = Key;
    using value_type           = Key;
    using init_type            = Key;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename std::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename std::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = std::size_t;
    using difference_type      = std::ptrdiff_t;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_flat_set_default_constructor">unordered_flat_set</a>();
    explicit <a href="#unordered_flat_set_bucket_count_constructor">unordered_flat_set</a>(size_type n,
                                const hasher&amp; hf = hasher(),
                                const key_equal&amp; eql = key_equal(),
                                const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_flat_set_iterator_range_constructor">unordered_flat_set</a>(InputIterator f, InputIterator l,
                         size_type n = <em>implementation-defined</em>,
                         const hasher&amp; hf = hasher(),
                         const key_equal&amp; eql = key_equal(),
                         const allocator_type&amp; a = allocator_type());
    <a href="#unordered_flat_set_copy_constructor">unordered_flat_set</a>(const unordered_flat_set&amp; other);
    <a href="#unordered_flat_set_move_constructor">unordered_flat_set</a>(unordered_flat_set&amp;&amp; other);
    template&lt;class InputIterator&gt;
      <a href="#unordered_flat_set_iterator_range_constructor_with_allocator">unordered_flat_set</a>(InputIterator f, InputIterator l, const allocator_type&amp; a);
    explicit <a href="#unordered_flat_set_allocator_constructor">unordered_flat_set</a>(const Allocator&amp; a);
    <a href="#unordered_flat_set_copy_constructor_with_allocator">unordered_flat_set</a>(const unordered_flat_set&amp; other, const Allocator&amp; a);
    <a href="#unordered_flat_set_move_constructor_with_allocator">unordered_flat_set</a>(unordered_flat_set&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_flat_set_initializer_list_constructor">unordered_flat_set</a>(std::initializer_list&lt;value_type&gt; il,
                       size_type n = <em>implementation-defined</em>
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
    <a href="#unordered_flat_set_bucket_count_constructor_with_allocator">unordered_flat_set</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_flat_set_bucket_count_constructor_with_hasher_and_allocator">unordered_flat_set</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_flat_set_iterator_range_constructor_with_bucket_count_and_allocator">unordered_flat_set</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_flat_set_iterator_range_constructor_with_bucket_count_and_hasher">unordered_flat_set</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                         const allocator_type&amp; a);
    <a href="#unordered_flat_set_initializer_list_constructor_with_allocator">unordered_flat_set</a>(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);
    <a href="#unordered_flat_set_initializer_list_constructor_with_bucket_count_and_allocator">unordered_flat_set</a>(std::initializer_list&lt;value_type&gt; il, size_type n,
                       const allocator_type&amp; a);
    <a href="#unordered_flat_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_flat_set</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                       const allocator_type&amp; a);
    <a href="#unordered_flat_set_destructor">~unordered_flat_set</a>();
    unordered_flat_set&amp; <a href="#unordered_flat_set_copy_assignment">operator=</a>(const unordered_flat_set&amp; other);
    unordered_flat_set&amp; <a href="#unordered_flat_set_move_assignment">operator=</a>(unordered_flat_set&amp;&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
               boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value);
    unordered_flat_set&amp; <a href="#unordered_flat_set_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt;);
    allocator_type <a href="#unordered_flat_set_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_flat_set_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_flat_set_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_flat_set_end">end</a>() noexcept;
    const_iterator <a href="#unordered_flat_set_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_flat_set_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_flat_set_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_flat_set_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_flat_set_size">size</a>() const noexcept;
    size_type <a href="#unordered_flat_set_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_set_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_flat_set_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_set_copy_insert">insert</a>(const value_type&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_set_move_insert">insert</a>(value_type&amp;&amp; obj);
    template&lt;class K&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_set_transparent_insert">insert</a>(K&amp;&amp; k);
    iterator <a href="#unordered_flat_set_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator <a href="#unordered_flat_set_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    template&lt;class K&gt; iterator <a href="#unordered_flat_set_transparent_insert_with_hint">insert</a>(const_iterator hint, K&amp;&amp; k);
    template&lt;class InputIterator&gt; void <a href="#unordered_flat_set_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_flat_set_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt;);

    void      <a href="#unordered_flat_set_erase_by_position">erase</a>(iterator position);
    void      <a href="#unordered_flat_set_erase_by_position">erase</a>(const_iterator position);
    size_type <a href="#unordered_flat_set_erase_by_key">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_flat_set_erase_by_key">erase</a>(K&amp;&amp; k);
    iterator  <a href="#unordered_flat_set_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_flat_set_swap">swap</a>(unordered_flat_set&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
               boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_swap::value);
    void      <a href="#unordered_flat_set_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_flat_set_merge">merge</a>(unordered_flat_set&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_flat_set_merge">merge</a>(unordered_flat_set&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_flat_set_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_flat_set_key_eq">key_eq</a>() const;

    // set operations
    iterator         <a href="#unordered_flat_set_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_flat_set_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_flat_set_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_flat_set_find">find</a>(const K&amp; k) const;
    size_type        <a href="#unordered_flat_set_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_flat_set_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_flat_set_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_flat_set_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_flat_set_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_flat_set_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_flat_set_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_flat_set_equal_range">equal_range</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_flat_set_bucket_count">bucket_count</a>() const noexcept;

    // hash policy
    float <a href="#unordered_flat_set_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_flat_set_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_flat_set_set_max_load_factor">max_load_factor</a>(float z);
    size_type <a href="#unordered_flat_set_max_load">max_load</a>() const noexcept;
    void <a href="#unordered_flat_set_rehash">rehash</a>(size_type n);
    void <a href="#unordered_flat_set_reserve">reserve</a>(size_type n);
  };

  // Deduction Guides
  template&lt;class InputIterator,
           class Hash = boost::hash&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
           class Pred = std::equal_to&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
           class Allocator = std::allocator&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;
    unordered_flat_set(InputIterator, InputIterator, typename <a href="#unordered_flat_set_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_flat_set_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_flat_set&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;, Hash, Pred, Allocator&gt;;

  template&lt;class T, class Hash = boost::hash&lt;T&gt;, class Pred = std::equal_to&lt;T&gt;,
           class Allocator = std::allocator&lt;T&gt;&gt;
    unordered_flat_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_flat_set_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_flat_set_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_flat_set&lt;T, Hash, Pred, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_flat_set(InputIterator, InputIterator, typename <a href="#unordered_flat_set_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_flat_set&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_flat_set(InputIterator, InputIterator, Allocator)
      -&gt; unordered_flat_set&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Hash, class Allocator&gt;
    unordered_flat_set(InputIterator, InputIterator, typename <a href="#unordered_flat_set_deduction_guides"><em>see below</em></a>::size_type, Hash,
                       Allocator)
      -&gt; unordered_flat_set&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;, Hash,
                            std::equal_to&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_flat_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_flat_set_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_flat_set&lt;T, boost::hash&lt;T&gt;, std::equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_flat_set(std::initializer_list&lt;T&gt;, Allocator)
      -&gt; unordered_flat_set&lt;T, boost::hash&lt;T&gt;, std::equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Hash, class Allocator&gt;
    unordered_flat_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_flat_set_deduction_guides"><em>see below</em></a>::size_type, Hash, Allocator)
      -&gt; unordered_flat_set&lt;T, Hash, std::equal_to&lt;T&gt;, Allocator&gt;;

  // Equality Comparisons
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_flat_set_operator_2">operator!=</a>(const unordered_flat_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_flat_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_flat_set_operator_3">operator!=</a>(const unordered_flat_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_flat_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  // swap
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    void <a href="#unordered_flat_set_swap_2">swap</a>(unordered_flat_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
              unordered_flat_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
    typename unordered_flat_set&lt;K, T, H, P, A&gt;::size_type
       <a href="#unordered_flat_set_erase_if">erase_if</a>(unordered_flat_set&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_flat_set_description"><a class="anchor" href="#unordered_flat_set_description"></a>Description</h3>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Key</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a> into the container
and <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type <code>bool</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.
<code>std::allocator_traits&lt;Allocator&gt;::pointer</code> and <code>std::allocator_traits&lt;Allocator&gt;::const_pointer</code>
must be convertible to/from <code>value_type*</code> and <code>const value_type*</code>, respectively.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The elements of the container are held into an internal <em>bucket array</em>. An element is inserted into a bucket determined by its
hash code, but if the bucket is already occupied (a <em>collision</em>), an available one in the vicinity of the
original position is used.</p>
</div>
<div class="paragraph">
<p>The size of the bucket array can be automatically increased by a call to <code>insert</code>/<code>emplace</code>, or as a result of calling
<code>rehash</code>/<code>reserve</code>. The <em>load factor</em> of the container (number of elements divided by number of buckets) is never
greater than <code>max_load_factor()</code>, except possibly for small sizes where the implementation may decide to
allow for higher loads.</p>
</div>
<div class="paragraph">
<p>If <code><a href="#hash_traits_hash_is_avalanching">hash_is_avalanching</a>&lt;Hash&gt;::value</code> is <code>true</code>, the hash function
is used as-is; otherwise, a bit-mixing post-processing stage is added to increase the quality of hashing
at the expense of extra computational cost.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_flat_set_typedefs"><a class="anchor" href="#unordered_flat_set_typedefs"></a>Typedefs</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> iterator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> const_iterator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_set_constructors"><a class="anchor" href="#unordered_flat_set_constructors"></a>Constructors</h3>
<div class="sect3">
<h4 id="unordered_flat_set_default_constructor"><a class="anchor" href="#unordered_flat_set_default_constructor"></a>Default Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_set();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate and <code>allocator_type()</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_bucket_count_constructor"><a class="anchor" href="#unordered_flat_set_bucket_count_constructor"></a>Bucket Count Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">explicit unordered_flat_set(size_type n,
                            const hasher&amp; hf = hasher(),
                            const key_equal&amp; eql = key_equal(),
                            const allocator_type&amp; a = allocator_type());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_iterator_range_constructor"><a class="anchor" href="#unordered_flat_set_iterator_range_constructor"></a>Iterator Range Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
  unordered_flat_set(InputIterator f, InputIterator l,
                     size_type n = <em>implementation-defined</em>,
                     const hasher&amp; hf = hasher(),
                     const key_equal&amp; eql = key_equal(),
                     const allocator_type&amp; a = allocator_type());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code> as the allocator, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_copy_constructor"><a class="anchor" href="#unordered_flat_set_copy_constructor"></a>Copy Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_set(unordered_flat_set const&amp; other);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_move_constructor"><a class="anchor" href="#unordered_flat_set_move_constructor"></a>Move Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_set(unordered_flat_set&amp;&amp; other);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor. The internal bucket array of <code>other</code> is transferred directly to the new container.
The hash function, predicate and allocator are moved-constructed from <code>other</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_iterator_range_constructor_with_allocator"><a class="anchor" href="#unordered_flat_set_iterator_range_constructor_with_allocator"></a>Iterator Range Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
  unordered_flat_set(InputIterator f, InputIterator l, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator, with the default hash function and key equality predicate and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_allocator_constructor"><a class="anchor" href="#unordered_flat_set_allocator_constructor"></a>Allocator Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">explicit unordered_flat_set(Allocator const&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_copy_constructor_with_allocator"><a class="anchor" href="#unordered_flat_set_copy_constructor_with_allocator"></a>Copy Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_set(unordered_flat_set const&amp; other, Allocator const&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs a container, copying <code>other</code>'s contained elements, hash function, and predicate, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_move_constructor_with_allocator"><a class="anchor" href="#unordered_flat_set_move_constructor_with_allocator"></a>Move Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_set(unordered_flat_set&amp;&amp; other, Allocator const&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>a == other.get_allocator()</code>, the elements of <code>other</code> are transferred directly to the new container;
otherwise, elements are moved-constructed from those of <code>other</code>. The hash function and predicate are moved-constructed
from <code>other</code>, and the allocator is copy-constructed from <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_initializer_list_constructor"><a class="anchor" href="#unordered_flat_set_initializer_list_constructor"></a>Initializer List Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_set(std::initializer_list&lt;value_type&gt; il,
              size_type n = <em>implementation-defined</em>
              const hasher&amp; hf = hasher(),
              const key_equal&amp; eql = key_equal(),
              const allocator_type&amp; a = allocator_type());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code>, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_bucket_count_constructor_with_allocator"><a class="anchor" href="#unordered_flat_set_bucket_count_constructor_with_allocator"></a>Bucket Count Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_set(size_type n, allocator_type const&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_bucket_count_constructor_with_hasher_and_allocator"><a class="anchor" href="#unordered_flat_set_bucket_count_constructor_with_hasher_and_allocator"></a>Bucket Count Constructor with Hasher and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_set(size_type n, hasher const&amp; hf, allocator_type const&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_iterator_range_constructor_with_bucket_count_and_allocator"><a class="anchor" href="#unordered_flat_set_iterator_range_constructor_with_bucket_count_and_allocator"></a>Iterator Range Constructor with Bucket Count and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
  unordered_flat_set(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and default hash function and key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_iterator_range_constructor_with_bucket_count_and_hasher"><a class="anchor" href="#unordered_flat_set_iterator_range_constructor_with_bucket_count_and_hasher"></a>Iterator Range Constructor with Bucket Count and Hasher</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">    template&lt;class InputIterator&gt;
      unordered_flat_set(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                         const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_initializer_list_constructor_with_allocator"><a class="anchor" href="#unordered_flat_set_initializer_list_constructor_with_allocator"></a>initializer_list Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_set(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_initializer_list_constructor_with_bucket_count_and_allocator"><a class="anchor" href="#unordered_flat_set_initializer_list_constructor_with_bucket_count_and_allocator"></a>initializer_list Constructor with Bucket Count and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_set(std::initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="anchor" href="#unordered_flat_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"></a>initializer_list Constructor with Bucket Count and Hasher and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_set(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                   const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and default key equality predicate,and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_set_destructor"><a class="anchor" href="#unordered_flat_set_destructor"></a>Destructor</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">~unordered_flat_set();</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_flat_set_assignment"><a class="anchor" href="#unordered_flat_set_assignment"></a>Assignment</h3>
<div class="sect3">
<h4 id="unordered_flat_set_copy_assignment"><a class="anchor" href="#unordered_flat_set_copy_assignment"></a>Copy Assignment</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_set&amp; operator=(unordered_flat_set const&amp; other);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Destroys previously existing elements, copy-assigns the hash function and predicate from <code>other</code>,
copy-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>,
and finally inserts copies of the elements of <code>other</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_move_assignment"><a class="anchor" href="#unordered_flat_set_move_assignment"></a>Move Assignment</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_set&amp; operator=(unordered_flat_set&amp;&amp; other)
  noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
           boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator. Destroys previously existing elements, swaps the hash function and predicate from <code>other</code>,
and move-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>.
If at this point the allocator is equal to <code>other.get_allocator()</code>, the internal bucket array of <code>other</code> is transferred directly to the new container;
otherwise, inserts move-constructed copies of the elements of <code>other</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_initializer_list_assignment"><a class="anchor" href="#unordered_flat_set_initializer_list_assignment"></a>Initializer List Assignment</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_flat_set&amp; operator=(std::initializer_list&lt;value_type&gt; il);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All previously existing elements are destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_set_iterators"><a class="anchor" href="#unordered_flat_set_iterators"></a>Iterators</h3>
<div class="sect3">
<h4 id="unordered_flat_set_begin"><a class="anchor" href="#unordered_flat_set_begin"></a>begin</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator begin() noexcept;
const_iterator begin() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>O(<code>bucket_count()</code>)</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_end"><a class="anchor" href="#unordered_flat_set_end"></a>end</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator end() noexcept;
const_iterator end() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_cbegin"><a class="anchor" href="#unordered_flat_set_cbegin"></a>cbegin</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">const_iterator cbegin() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>O(<code>bucket_count()</code>)</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_cend"><a class="anchor" href="#unordered_flat_set_cend"></a>cend</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">const_iterator cend() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_set_size_and_capacity"><a class="anchor" href="#unordered_flat_set_size_and_capacity"></a>Size and Capacity</h3>
<div class="sect3">
<h4 id="unordered_flat_set_empty"><a class="anchor" href="#unordered_flat_set_empty"></a>empty</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">[[nodiscard]] bool empty() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_size"><a class="anchor" href="#unordered_flat_set_size"></a>size</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type size() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_max_size"><a class="anchor" href="#unordered_flat_set_max_size"></a>max_size</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type max_size() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_set_modifiers"><a class="anchor" href="#unordered_flat_set_modifiers"></a>Modifiers</h3>
<div class="sect3">
<h4 id="unordered_flat_set_emplace"><a class="anchor" href="#unordered_flat_set_emplace"></a>emplace</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class... Args&gt; std::pair&lt;iterator, bool&gt; emplace(Args&amp;&amp;... args);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_emplace_hint"><a class="anchor" href="#unordered_flat_set_emplace_hint"></a>emplace_hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">    template&lt;class... Args&gt; iterator emplace_hint(const_iterator position, Args&amp;&amp;... args);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>position</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_copy_insert"><a class="anchor" href="#unordered_flat_set_copy_insert"></a>Copy Insert</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::pair&lt;iterator, bool&gt; insert(const value_type&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_move_insert"><a class="anchor" href="#unordered_flat_set_move_insert"></a>Move Insert</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::pair&lt;iterator, bool&gt; insert(value_type&amp;&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_transparent_insert"><a class="anchor" href="#unordered_flat_set_transparent_insert"></a>Transparent Insert</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class K&gt; std::pair&lt;iterator, bool&gt; insert(K&amp;&amp; k);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element constructed from <code>std::forward&lt;K&gt;(k)</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> from <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_copy_insert_with_hint"><a class="anchor" href="#unordered_flat_set_copy_insert_with_hint"></a>Copy Insert with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(const_iterator hint, const value_type&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_move_insert_with_hint"><a class="anchor" href="#unordered_flat_set_move_insert_with_hint"></a>Move Insert with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(const_iterator hint, value_type&amp;&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_transparent_insert_with_hint"><a class="anchor" href="#unordered_flat_set_transparent_insert_with_hint"></a>Transparent Insert with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class K&gt; std::pair&lt;iterator, bool&gt; insert(const_iterator hint, K&amp;&amp; k);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element constructed from <code>std::forward&lt;K&gt;(k)</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> from <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_insert_iterator_range"><a class="anchor" href="#unordered_flat_set_insert_iterator_range"></a>Insert Iterator Range</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt; void insert(InputIterator first, InputIterator last);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into the container from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_insert_initializer_list"><a class="anchor" href="#unordered_flat_set_insert_initializer_list"></a>Insert Initializer List</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void insert(std::initializer_list&lt;value_type&gt;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into the container from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_erase_by_position"><a class="anchor" href="#unordered_flat_set_erase_by_position"></a>Erase by Position</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void erase(iterator position);
void erase(const_iterator position);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_erase_by_key"><a class="anchor" href="#unordered_flat_set_erase_by_key"></a>Erase by Key</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type erase(const key_type&amp; k);
template&lt;class K&gt; size_type erase(K&amp;&amp; k);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_erase_range"><a class="anchor" href="#unordered_flat_set_erase_range"></a>Erase Range</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator erase(const_iterator first, const_iterator last);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing in this implementation (neither the <code>hasher</code> nor the <code>key_equal</code> objects are called).</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_swap"><a class="anchor" href="#unordered_flat_set_swap"></a>swap</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void swap(unordered_flat_set&amp; other)
  noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
           boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_swap::value);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing unless <code>key_equal</code> or <code>hasher</code> throw on swapping.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_clear"><a class="anchor" href="#unordered_flat_set_clear"></a>clear</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void clear() noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code>, <code>max_load() &gt;= max_load_factor() * bucket_count()</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_merge"><a class="anchor" href="#unordered_flat_set_merge"></a>merge</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class H2, class P2&gt;
  void merge(unordered_flat_set&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
template&lt;class H2, class P2&gt;
  void merge(unordered_flat_set&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Move-inserts all the elements from <code>source</code> whose key is not already present in <code>*this</code>, and erases them from <code>source</code>.</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_set_observers"><a class="anchor" href="#unordered_flat_set_observers"></a>Observers</h3>
<div class="sect3">
<h4 id="unordered_flat_set_get_allocator"><a class="anchor" href="#unordered_flat_set_get_allocator"></a>get_allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">allocator_type get_allocator() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s allocator.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_hash_function"><a class="anchor" href="#unordered_flat_set_hash_function"></a>hash_function</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">hasher hash_function() const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_key_eq"><a class="anchor" href="#unordered_flat_set_key_eq"></a>key_eq</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">key_equal key_eq() const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_set_lookup"><a class="anchor" href="#unordered_flat_set_lookup"></a>Lookup</h3>
<div class="sect3">
<h4 id="unordered_flat_set_find"><a class="anchor" href="#unordered_flat_set_find"></a>find</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator         find(const key_type&amp; k);
const_iterator   find(const key_type&amp; k) const;
template&lt;class K&gt;
  iterator       find(const K&amp; k);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_count"><a class="anchor" href="#unordered_flat_set_count"></a>count</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type        count(const key_type&amp; k) const;
template&lt;class K&gt;
  size_type      count(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_contains"><a class="anchor" href="#unordered_flat_set_contains"></a>contains</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">bool             contains(const key_type&amp; k) const;
template&lt;class K&gt;
  bool           contains(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_equal_range"><a class="anchor" href="#unordered_flat_set_equal_range"></a>equal_range</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::pair&lt;iterator, iterator&gt;               equal_range(const key_type&amp; k);
std::pair&lt;const_iterator, const_iterator&gt;   equal_range(const key_type&amp; k) const;
template&lt;class K&gt;
  std::pair&lt;iterator, iterator&gt;             equal_range(const K&amp; k);
template&lt;class K&gt;
  std::pair&lt;const_iterator, const_iterator&gt; equal_range(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_set_bucket_interface"><a class="anchor" href="#unordered_flat_set_bucket_interface"></a>Bucket Interface</h3>
<div class="sect3">
<h4 id="unordered_flat_set_bucket_count"><a class="anchor" href="#unordered_flat_set_bucket_count"></a>bucket_count</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type bucket_count() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The size of the bucket array.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_set_hash_policy"><a class="anchor" href="#unordered_flat_set_hash_policy"></a>Hash Policy</h3>
<div class="sect3">
<h4 id="unordered_flat_set_load_factor"><a class="anchor" href="#unordered_flat_set_load_factor"></a>load_factor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">float load_factor() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>static_cast&lt;float&gt;(size())/static_cast&lt;float&gt;(bucket_count())</code>, or <code>0</code> if <code>bucket_count() == 0</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_max_load_factor"><a class="anchor" href="#unordered_flat_set_max_load_factor"></a>max_load_factor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">float max_load_factor() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the container&#8217;s maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_set_max_load_factor"><a class="anchor" href="#unordered_flat_set_set_max_load_factor"></a>Set max_load_factor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void max_load_factor(float z);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Does nothing, as the user is not allowed to change this parameter. Kept for compatibility with <code>boost::unordered_set</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_max_load"><a class="anchor" href="#unordered_flat_set_max_load"></a>max_load</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type max_load() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The maximum number of elements the container can hold without rehashing, assuming that no further elements will be erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>After construction, rehash or clearance, the container&#8217;s maximum load is at least <code>max_load_factor() * bucket_count()</code>.
This number may decrease on erasure under high-load conditions.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_rehash"><a class="anchor" href="#unordered_flat_set_rehash"></a>rehash</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void rehash(size_type n);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes if necessary the size of the bucket array so that there are at least <code>n</code> buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the <code>bucket_count()</code> associated with the container.</p>
</div>
<div class="paragraph">
<p>When <code>size() == 0</code>, <code>rehash(0)</code> will deallocate the underlying buckets array.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, pointers and references, and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_reserve"><a class="anchor" href="#unordered_flat_set_reserve"></a>reserve</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void reserve(size_type n);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>a.rehash(ceil(n / a.max_load_factor()))</code>.</p>
</div>
<div class="paragraph">
<p>Similar to <code>rehash</code>, this function can be used to grow or shrink the number of buckets in the container.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, pointers and references, and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_set_deduction_guides"><a class="anchor" href="#unordered_flat_set_deduction_guides"></a>Deduction Guides</h3>
<div class="paragraph">
<p>A deduction guide will not participate in overload resolution if any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has an <code>InputIterator</code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p>
</li>
<li>
<p>It has an <code>Allocator</code> template parameter and a type that does not qualify as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Hash</code> template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Pred</code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>size_Â­type</code> parameter type in a deduction guide refers to the <code>size_Â­type</code> member type of the
container type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.</p>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_iter_value_type"><a class="anchor" href="#unordered_flat_set_iter_value_type"></a><em>iter-value-type</em></h4>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-value-type</em> =
    typename std::iterator_traits&lt;InputIterator&gt;::value_type; // exposition only</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_set_equality_comparisons"><a class="anchor" href="#unordered_flat_set_equality_comparisons"></a>Equality Comparisons</h3>
<div class="sect3">
<h4 id="unordered_flat_set_operator"><a class="anchor" href="#unordered_flat_set_operator"></a>operator==</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
  bool operator==(const unordered_flat_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                  const unordered_flat_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_operator_2"><a class="anchor" href="#unordered_flat_set_operator_2"></a>operator!=</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
  bool operator!=(const unordered_flat_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                  const unordered_flat_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_set_swap_2"><a class="anchor" href="#unordered_flat_set_swap_2"></a>Swap</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
  void swap(unordered_flat_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
            unordered_flat_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
    noexcept(noexcept(x.swap(y)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing unless <code>key_equal</code> or <code>hasher</code> throw on swapping.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_flat_set_erase_if"><a class="anchor" href="#unordered_flat_set_erase_if"></a>erase_if</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
  typename unordered_flat_set&lt;K, T, H, P, A&gt;::size_type
    erase_if(unordered_flat_set&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">auto original_size = c.size();
for (auto i = c.begin(), last = c.end(); i != last; ) {
  if (pred(*i)) {
    i = c.erase(i);
  } else {
    ++i;
  }
}
return original_size - c.size();</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="unordered_node_map"><a class="anchor" href="#unordered_node_map"></a>Class template unordered_node_map</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>boost::unordered_node_map</code> â€” A node-based, open-addressing unordered associative container that associates unique keys with another value.</p>
</div>
<div class="paragraph">
<p><code>boost::unordered_node_map</code> uses an open-addressing layout like <code>boost::unordered_flat_map</code>, but,
being node-based, it provides pointer/iterator stability and node handling functionalities.
Its performance lies between those of <code>boost::unordered_map</code> and <code>boost::unordered_flat_map</code>.</p>
</div>
<div class="paragraph">
<p>As a result of its using open addressing, the interface of <code>boost::unordered_node_map</code> deviates in
a number of aspects from that of <code>boost::unordered_map</code>/<code>std::unordered_map</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>begin()</code> is not constant-time.</p>
</li>
<li>
<p><code>erase(iterator)</code> returns <code>void</code>.</p>
</li>
<li>
<p>There is no API for bucket handling (except <code>bucket_count</code>).</p>
</li>
<li>
<p>The maximum load factor of the container is managed internally and can&#8217;t be set by the user.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Other than this, <code>boost::unordered_node_map</code> is mostly a drop-in replacement of standard
unordered associative containers.</p>
</div>
<div class="sect2">
<h3 id="unordered_node_map_synopsis"><a class="anchor" href="#unordered_node_map_synopsis"></a>Synopsis</h3>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/unordered_node_map.hpp&gt;

namespace boost {
  template&lt;class Key,
           class T,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
  class unordered_node_map {
  public:
    // types
    using key_type             = Key;
    using mapped_type          = T;
    using value_type           = std::pair&lt;const Key, T&gt;;
    using init_type            = std::pair&lt;
                                   typename std::remove_const&lt;Key&gt;::type,
                                   typename std::remove_const&lt;T&gt;::type
                                 &gt;;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename std::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename std::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = std::size_t;
    using difference_type      = std::ptrdiff_t;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;

    using node_type            = <em>implementation-defined</em>;
    using insert_return_type   = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_node_map_default_constructor">unordered_node_map</a>();
    explicit <a href="#unordered_node_map_bucket_count_constructor">unordered_node_map</a>(size_type n,
                                const hasher&amp; hf = hasher(),
                                const key_equal&amp; eql = key_equal(),
                                const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_node_map_iterator_range_constructor">unordered_node_map</a>(InputIterator f, InputIterator l,
                         size_type n = <em>implementation-defined</em>,
                         const hasher&amp; hf = hasher(),
                         const key_equal&amp; eql = key_equal(),
                         const allocator_type&amp; a = allocator_type());
    <a href="#unordered_node_map_copy_constructor">unordered_node_map</a>(const unordered_node_map&amp; other);
    <a href="#unordered_node_map_move_constructor">unordered_node_map</a>(unordered_node_map&amp;&amp; other);
    template&lt;class InputIterator&gt;
      <a href="#unordered_node_map_iterator_range_constructor_with_allocator">unordered_node_map</a>(InputIterator f, InputIterator l, const allocator_type&amp; a);
    explicit <a href="#unordered_node_map_allocator_constructor">unordered_node_map</a>(const Allocator&amp; a);
    <a href="#unordered_node_map_copy_constructor_with_allocator">unordered_node_map</a>(const unordered_node_map&amp; other, const Allocator&amp; a);
    <a href="#unordered_node_map_move_constructor_with_allocator">unordered_node_map</a>(unordered_node_map&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_node_map_initializer_list_constructor">unordered_node_map</a>(std::initializer_list&lt;value_type&gt; il,
                       size_type n = <em>implementation-defined</em>
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
    <a href="#unordered_node_map_bucket_count_constructor_with_allocator">unordered_node_map</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_node_map_bucket_count_constructor_with_hasher_and_allocator">unordered_node_map</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_node_map_iterator_range_constructor_with_bucket_count_and_allocator">unordered_node_map</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_node_map_iterator_range_constructor_with_bucket_count_and_hasher">unordered_node_map</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                         const allocator_type&amp; a);
    <a href="#unordered_node_map_initializer_list_constructor_with_allocator">unordered_node_map</a>(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);
    <a href="#unordered_node_map_initializer_list_constructor_with_bucket_count_and_allocator">unordered_node_map</a>(std::initializer_list&lt;value_type&gt; il, size_type n,
                       const allocator_type&amp; a);
    <a href="#unordered_node_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_node_map</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                       const allocator_type&amp; a);
    <a href="#unordered_node_map_destructor">~unordered_node_map</a>();
    unordered_node_map&amp; <a href="#unordered_node_map_copy_assignment">operator=</a>(const unordered_node_map&amp; other);
    unordered_node_map&amp; <a href="#unordered_node_map_move_assignment">operator=</a>(unordered_node_map&amp;&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
              boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value);
    unordered_node_map&amp; <a href="#unordered_node_map_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt;);
    allocator_type <a href="#unordered_node_map_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_node_map_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_node_map_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_node_map_end">end</a>() noexcept;
    const_iterator <a href="#unordered_node_map_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_node_map_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_node_map_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_node_map_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_node_map_size">size</a>() const noexcept;
    size_type <a href="#unordered_node_map_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_node_map_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_copy_insert">insert</a>(const value_type&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_copy_insert">insert</a>(const init_type&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_move_insert">insert</a>(value_type&amp;&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_move_insert">insert</a>(init_type&amp;&amp; obj);
    iterator       <a href="#unordered_node_map_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator       <a href="#unordered_node_map_copy_insert_with_hint">insert</a>(const_iterator hint, const init_type&amp; obj);
    iterator       <a href="#unordered_node_map_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    iterator       <a href="#unordered_node_map_copy_insert_with_hint">insert</a>(const_iterator hint, init_type&amp;&amp; obj);
    template&lt;class InputIterator&gt; void <a href="#unordered_node_map_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_node_map_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt;);
    insert_return_type <a href="#unordered_node_map_insert_node">insert</a>(node_type&amp;&amp; nh);
    iterator <a href="#unordered_node_map_insert_node_with_hint">insert</a>(const_iterator hint, node_type&amp;&amp; nh);

    template&lt;class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_try_emplace">try_emplace</a>(const key_type&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_try_emplace">try_emplace</a>(key_type&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class K, class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_try_emplace">try_emplace</a>(K&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      iterator <a href="#unordered_node_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, const key_type&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      iterator <a href="#unordered_node_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, key_type&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class K, class... Args&gt;
      iterator <a href="#unordered_node_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, K&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_insert_or_assign">insert_or_assign</a>(const key_type&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_insert_or_assign">insert_or_assign</a>(key_type&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class K, class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_insert_or_assign">insert_or_assign</a>(K&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      iterator <a href="#unordered_node_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, const key_type&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      iterator <a href="#unordered_node_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, key_type&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class K, class M&gt;
      iterator <a href="#unordered_node_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, K&amp;&amp; k, M&amp;&amp; obj);

    void      <a href="#unordered_node_map_erase_by_position">erase</a>(iterator position);
    void      <a href="#unordered_node_map_erase_by_position">erase</a>(const_iterator position);
    size_type <a href="#unordered_node_map_erase_by_key">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_node_map_erase_by_key">erase</a>(K&amp;&amp; k);
    iterator  <a href="#unordered_node_map_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_node_map_swap">swap</a>(unordered_node_map&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
               boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_swap::value);
    node_type <a href="#unordered_node_map_extract_by_position">extract</a>(const_iterator position);
    node_type <a href="#unordered_node_map_extract_by_key">extract</a>(const key_type&amp; key);
    template&lt;class K&gt; node_type <a href="#unordered_node_map_extract_by_key">extract</a>(K&amp;&amp; key);
    void      <a href="#unordered_node_map_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_node_map_merge">merge</a>(unordered_node_map&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_node_map_merge">merge</a>(unordered_node_map&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_node_map_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_node_map_key_eq">key_eq</a>() const;

    // map operations
    iterator         <a href="#unordered_node_map_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_node_map_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_node_map_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_node_map_find">find</a>(const K&amp; k) const;
    size_type        <a href="#unordered_node_map_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_node_map_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_node_map_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_node_map_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_node_map_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_node_map_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_node_map_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_node_map_equal_range">equal_range</a>(const K&amp; k) const;

    // element access
    mapped_type&amp; <a href="#unordered_node_map_operator">operator[]</a>(const key_type&amp; k);
    mapped_type&amp; <a href="#unordered_node_map_operator">operator[]</a>(key_type&amp;&amp; k);
    template&lt;class K&gt; mapped_type&amp; <a href="#unordered_node_map_operator">operator[]</a>(K&amp;&amp; k);
    mapped_type&amp; <a href="#unordered_node_map_at">at</a>(const key_type&amp; k);
    const mapped_type&amp; <a href="#unordered_node_map_at">at</a>(const key_type&amp; k) const;
    template&lt;class K&gt; mapped_type&amp; <a href="#unordered_node_map_at">at</a>(const K&amp; k);
    template&lt;class K&gt; const mapped_type&amp; <a href="#unordered_node_map_at">at</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_node_map_bucket_count">bucket_count</a>() const noexcept;

    // hash policy
    float <a href="#unordered_node_map_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_node_map_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_node_map_set_max_load_factor">max_load_factor</a>(float z);
    size_type <a href="#unordered_node_map_max_load">max_load</a>() const noexcept;
    void <a href="#unordered_node_map_rehash">rehash</a>(size_type n);
    void <a href="#unordered_node_map_reserve">reserve</a>(size_type n);
  };

  // Deduction Guides
  template&lt;class InputIterator,
           class Hash = boost::hash&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
           class Pred = std::equal_to&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
           class Allocator = std::allocator&lt;<a href="#unordered_node_map_iter_to_alloc_type"><em>iter-to-alloc-type</em></a>&lt;InputIterator&gt;&gt;&gt;
    unordered_node_map(InputIterator, InputIterator, typename <a href="#unordered_node_map_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_node_map_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_node_map&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_node_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;, Hash,
                            Pred, Allocator&gt;;

  template&lt;class Key, class T, class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
    unordered_node_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;,
                       typename <a href="#unordered_node_map_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_node_map_deduction_guides"><em>see below</em></a>, Hash = Hash(),
                       Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_node_map&lt;Key, T, Hash, Pred, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_node_map(InputIterator, InputIterator, typename <a href="#unordered_node_map_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_node_map&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_node_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_node_map(InputIterator, InputIterator, Allocator)
      -&gt; unordered_node_map&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_node_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Hash, class Allocator&gt;
    unordered_node_map(InputIterator, InputIterator, typename <a href="#unordered_node_map_deduction_guides"><em>see below</em></a>::size_type, Hash,
                       Allocator)
      -&gt; unordered_node_map&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_node_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;, Hash,
                            std::equal_to&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Allocator&gt;
    unordered_node_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, typename <a href="#unordered_node_map_deduction_guides"><em>see below</em></a>::size_type,
                       Allocator)
      -&gt; unordered_node_map&lt;Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Allocator&gt;
    unordered_node_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, Allocator)
      -&gt; unordered_node_map&lt;Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Hash, class Allocator&gt;
    unordered_node_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, typename <a href="#unordered_node_map_deduction_guides"><em>see below</em></a>::size_type,
                       Hash, Allocator)
      -&gt; unordered_node_map&lt;Key, T, Hash, std::equal_to&lt;Key&gt;, Allocator&gt;;

  // Equality Comparisons
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_node_map_operator_2">operator==</a>(const unordered_node_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_node_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_node_map_operator_3">operator!=</a>(const unordered_node_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_node_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  // swap
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    void <a href="#unordered_node_map_swap_2">swap</a>(unordered_node_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
              unordered_node_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
    typename unordered_node_map&lt;K, T, H, P, A&gt;::size_type
       <a href="#unordered_node_map_erase_if">erase_if</a>(unordered_node_map&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_node_map_description"><a class="anchor" href="#unordered_node_map_description"></a>Description</h3>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock"><code>std::pair&lt;const Key, T&gt;</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a>
into the container from any <code>std::pair</code> object convertible to it, and it also must be
<a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>T</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type <code>bool</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.
<code>std::allocator_traits&lt;Allocator&gt;::pointer</code> and <code>std::allocator_traits&lt;Allocator&gt;::const_pointer</code>
must be convertible to/from <code>value_type*</code> and <code>const value_type*</code>, respectively.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The element nodes of the container are held into an internal <em>bucket array</em>. A node is inserted into a bucket determined by the
hash code of its element, but if the bucket is already occupied (a <em>collision</em>), an available one in the vicinity of the
original position is used.</p>
</div>
<div class="paragraph">
<p>The size of the bucket array can be automatically increased by a call to <code>insert</code>/<code>emplace</code>, or as a result of calling
<code>rehash</code>/<code>reserve</code>. The <em>load factor</em> of the container (number of elements divided by number of buckets) is never
greater than <code>max_load_factor()</code>, except possibly for small sizes where the implementation may decide to
allow for higher loads.</p>
</div>
<div class="paragraph">
<p>If <code><a href="#hash_traits_hash_is_avalanching">hash_is_avalanching</a>&lt;Hash&gt;::value</code> is <code>true</code>, the hash function
is used as-is; otherwise, a bit-mixing post-processing stage is added to increase the quality of hashing
at the expense of extra computational cost.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_node_map_typedefs"><a class="anchor" href="#unordered_node_map_typedefs"></a>Typedefs</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> iterator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> const_iterator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> node_type;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A class for holding extracted container elements, modelling
<a href="https://en.cppreference.com/w/cpp/container/node_handle">NodeHandle</a>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> insert_return_type;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A specialization of an internal class template:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class Iterator, class NodeType&gt;
struct <em>insert_return_type</em> // name is exposition only
{
  Iterator position;
  bool     inserted;
  NodeType node;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>with <code>Iterator</code> = <code>iterator</code> and <code>NodeType</code> = <code>node_type</code>.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_node_map_constructors"><a class="anchor" href="#unordered_node_map_constructors"></a>Constructors</h3>
<div class="sect3">
<h4 id="unordered_node_map_default_constructor"><a class="anchor" href="#unordered_node_map_default_constructor"></a>Default Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_map();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate and <code>allocator_type()</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_bucket_count_constructor"><a class="anchor" href="#unordered_node_map_bucket_count_constructor"></a>Bucket Count Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">explicit unordered_node_map(size_type n,
                            const hasher&amp; hf = hasher(),
                            const key_equal&amp; eql = key_equal(),
                            const allocator_type&amp; a = allocator_type());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_iterator_range_constructor"><a class="anchor" href="#unordered_node_map_iterator_range_constructor"></a>Iterator Range Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
  unordered_node_map(InputIterator f, InputIterator l,
                     size_type n = <em>implementation-defined</em>,
                     const hasher&amp; hf = hasher(),
                     const key_equal&amp; eql = key_equal(),
                     const allocator_type&amp; a = allocator_type());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code> as the allocator, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_copy_constructor"><a class="anchor" href="#unordered_node_map_copy_constructor"></a>Copy Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_map(unordered_node_map const&amp; other);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_move_constructor"><a class="anchor" href="#unordered_node_map_move_constructor"></a>Move Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_map(unordered_node_map&amp;&amp; other);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor. The internal bucket array of <code>other</code> is transferred directly to the new container.
The hash function, predicate and allocator are moved-constructed from <code>other</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_iterator_range_constructor_with_allocator"><a class="anchor" href="#unordered_node_map_iterator_range_constructor_with_allocator"></a>Iterator Range Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
  unordered_node_map(InputIterator f, InputIterator l, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator, with the default hash function and key equality predicate and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_allocator_constructor"><a class="anchor" href="#unordered_node_map_allocator_constructor"></a>Allocator Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">explicit unordered_node_map(Allocator const&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_copy_constructor_with_allocator"><a class="anchor" href="#unordered_node_map_copy_constructor_with_allocator"></a>Copy Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_map(unordered_node_map const&amp; other, Allocator const&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs a container, copying <code>other</code>'s contained elements, hash function, and predicate, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_move_constructor_with_allocator"><a class="anchor" href="#unordered_node_map_move_constructor_with_allocator"></a>Move Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_map(unordered_node_map&amp;&amp; other, Allocator const&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>a == other.get_allocator()</code>, the element nodes of <code>other</code> are transferred directly to the new container;
otherwise, elements are moved-constructed from those of <code>other</code>. The hash function and predicate are moved-constructed
from <code>other</code>, and the allocator is copy-constructed from <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_initializer_list_constructor"><a class="anchor" href="#unordered_node_map_initializer_list_constructor"></a>Initializer List Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_map(std::initializer_list&lt;value_type&gt; il,
              size_type n = <em>implementation-defined</em>
              const hasher&amp; hf = hasher(),
              const key_equal&amp; eql = key_equal(),
              const allocator_type&amp; a = allocator_type());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code>, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_bucket_count_constructor_with_allocator"><a class="anchor" href="#unordered_node_map_bucket_count_constructor_with_allocator"></a>Bucket Count Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_map(size_type n, allocator_type const&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_bucket_count_constructor_with_hasher_and_allocator"><a class="anchor" href="#unordered_node_map_bucket_count_constructor_with_hasher_and_allocator"></a>Bucket Count Constructor with Hasher and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_map(size_type n, hasher const&amp; hf, allocator_type const&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_iterator_range_constructor_with_bucket_count_and_allocator"><a class="anchor" href="#unordered_node_map_iterator_range_constructor_with_bucket_count_and_allocator"></a>Iterator Range Constructor with Bucket Count and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
  unordered_node_map(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and default hash function and key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_iterator_range_constructor_with_bucket_count_and_hasher"><a class="anchor" href="#unordered_node_map_iterator_range_constructor_with_bucket_count_and_hasher"></a>Iterator Range Constructor with Bucket Count and Hasher</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">    template&lt;class InputIterator&gt;
      unordered_node_map(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                         const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_initializer_list_constructor_with_allocator"><a class="anchor" href="#unordered_node_map_initializer_list_constructor_with_allocator"></a>initializer_list Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_map(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_initializer_list_constructor_with_bucket_count_and_allocator"><a class="anchor" href="#unordered_node_map_initializer_list_constructor_with_bucket_count_and_allocator"></a>initializer_list Constructor with Bucket Count and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_map(std::initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="anchor" href="#unordered_node_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"></a>initializer_list Constructor with Bucket Count and Hasher and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_map(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                   const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and default key equality predicate,and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_node_map_destructor"><a class="anchor" href="#unordered_node_map_destructor"></a>Destructor</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">~unordered_node_map();</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_node_map_assignment"><a class="anchor" href="#unordered_node_map_assignment"></a>Assignment</h3>
<div class="sect3">
<h4 id="unordered_node_map_copy_assignment"><a class="anchor" href="#unordered_node_map_copy_assignment"></a>Copy Assignment</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_map&amp; operator=(unordered_node_map const&amp; other);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Destroys previously existing elements, copy-assigns the hash function and predicate from <code>other</code>,
copy-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>,
and finally inserts copies of the elements of <code>other</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_move_assignment"><a class="anchor" href="#unordered_node_map_move_assignment"></a>Move Assignment</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_map&amp; operator=(unordered_node_map&amp;&amp; other)
  noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
           boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator. Destroys previously existing elements, swaps the hash function and predicate from <code>other</code>,
and move-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>.
If at this point the allocator is equal to <code>other.get_allocator()</code>, the internal bucket array of <code>other</code> is transferred directly to the new container;
otherwise, inserts move-constructed copies of the elements of <code>other</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_initializer_list_assignment"><a class="anchor" href="#unordered_node_map_initializer_list_assignment"></a>Initializer List Assignment</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_map&amp; operator=(std::initializer_list&lt;value_type&gt; il);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All previously existing elements are destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_node_map_iterators"><a class="anchor" href="#unordered_node_map_iterators"></a>Iterators</h3>
<div class="sect3">
<h4 id="unordered_node_map_begin"><a class="anchor" href="#unordered_node_map_begin"></a>begin</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator begin() noexcept;
const_iterator begin() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>O(<code>bucket_count()</code>)</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_end"><a class="anchor" href="#unordered_node_map_end"></a>end</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator end() noexcept;
const_iterator end() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_cbegin"><a class="anchor" href="#unordered_node_map_cbegin"></a>cbegin</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">const_iterator cbegin() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>O(<code>bucket_count()</code>)</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_cend"><a class="anchor" href="#unordered_node_map_cend"></a>cend</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">const_iterator cend() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_node_map_size_and_capacity"><a class="anchor" href="#unordered_node_map_size_and_capacity"></a>Size and Capacity</h3>
<div class="sect3">
<h4 id="unordered_node_map_empty"><a class="anchor" href="#unordered_node_map_empty"></a>empty</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">[[nodiscard]] bool empty() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_size"><a class="anchor" href="#unordered_node_map_size"></a>size</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type size() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_max_size"><a class="anchor" href="#unordered_node_map_max_size"></a>max_size</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type max_size() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_node_map_modifiers"><a class="anchor" href="#unordered_node_map_modifiers"></a>Modifiers</h3>
<div class="sect3">
<h4 id="unordered_node_map_emplace"><a class="anchor" href="#unordered_node_map_emplace"></a>emplace</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class... Args&gt; std::pair&lt;iterator, bool&gt; emplace(Args&amp;&amp;... args);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_emplace_hint"><a class="anchor" href="#unordered_node_map_emplace_hint"></a>emplace_hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">    template&lt;class... Args&gt; iterator emplace_hint(const_iterator position, Args&amp;&amp;... args);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>position</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_copy_insert"><a class="anchor" href="#unordered_node_map_copy_insert"></a>Copy Insert</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::pair&lt;iterator, bool&gt; insert(const value_type&amp; obj);
std::pair&lt;iterator, bool&gt; insert(const init_type&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>A call of the form <code>insert(x)</code>, where <code>x</code> is equally convertible to both <code>const value_type&amp;</code> and <code>const init_type&amp;</code>, is not ambiguous and selects the <code>init_type</code> overload.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_move_insert"><a class="anchor" href="#unordered_node_map_move_insert"></a>Move Insert</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::pair&lt;iterator, bool&gt; insert(value_type&amp;&amp; obj);
std::pair&lt;iterator, bool&gt; insert(init_type&amp;&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>A call of the form <code>insert(x)</code>, where <code>x</code> is equally convertible to both <code>value_type&amp;&amp;</code> and <code>init_type&amp;&amp;</code>, is not ambiguous and selects the <code>init_type</code> overload.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_copy_insert_with_hint"><a class="anchor" href="#unordered_node_map_copy_insert_with_hint"></a>Copy Insert with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(const_iterator hint, const value_type&amp; obj);
iterator insert(const_iterator hint, const init_type&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>A call of the form <code>insert(hint, x)</code>, where <code>x</code> is equally convertible to both <code>const value_type&amp;</code> and <code>const init_type&amp;</code>, is not ambiguous and selects the <code>init_type</code> overload.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_move_insert_with_hint"><a class="anchor" href="#unordered_node_map_move_insert_with_hint"></a>Move Insert with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(const_iterator hint, value_type&amp;&amp; obj);
iterator insert(const_iterator hint, init_type&amp;&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>A call of the form <code>insert(hint, x)</code>, where <code>x</code> is equally convertible to both <code>value_type&amp;&amp;</code> and <code>init_type&amp;&amp;</code>, is not ambiguous and selects the <code>init_type</code> overload.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_insert_iterator_range"><a class="anchor" href="#unordered_node_map_insert_iterator_range"></a>Insert Iterator Range</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt; void insert(InputIterator first, InputIterator last);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into the container from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_insert_initializer_list"><a class="anchor" href="#unordered_node_map_insert_initializer_list"></a>Insert Initializer List</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void insert(std::initializer_list&lt;value_type&gt;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into the container from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_insert_node"><a class="anchor" href="#unordered_node_map_insert_node"></a>Insert Node</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">insert_return_type insert(node_type&amp;&amp; nh);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is not empty, inserts the associated element in the container if and only if there is no element in the container with a key equivalent to <code>nh.key()</code>.
<code>nh</code> is empty when the function returns.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An <code>insert_return_type</code> object constructed from <code>position</code>, <code>inserted</code> and <code>node</code>:<br></p>
<div class="ulist">
<ul>
<li>
<p>If <code>nh</code> is empty, <code>inserted</code> is <code>false</code>, <code>position</code> is <code>end()</code>, and <code>node</code> is empty.</p>
</li>
<li>
<p>Otherwise if the insertion took place, <code>inserted</code> is true, <code>position</code> points to the inserted element, and <code>node</code> is empty.</p>
</li>
<li>
<p>If the insertion failed, <code>inserted</code> is false, <code>node</code> has the previous value of <code>nh</code>, and <code>position</code> points to an element with a key equivalent to <code>nh.key()</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if <code>nh</code> is not empty and the allocators of <code>nh</code> and the container are not equal.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_insert_node_with_hint"><a class="anchor" href="#unordered_node_map_insert_node_with_hint"></a>Insert Node with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(const_iterator hint, node_type&amp;&amp; nh);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is not empty, inserts the associated element in the container if and only if there is no element in the container with a key equivalent to <code>nh.key()</code>.
<code>nh</code> becomes empty if insertion took place, otherwise it is not changed.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator returned is <code>end()</code> if <code>nh</code> is empty.
If insertion took place, then the iterator points to the newly inserted element; otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if <code>nh</code> is not empty and the allocators of <code>nh</code> and the container are not equal.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_try_emplace"><a class="anchor" href="#unordered_node_map_try_emplace"></a>try_emplace</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class... Args&gt;
  std::pair&lt;iterator, bool&gt; try_emplace(const key_type&amp; k, Args&amp;&amp;... args);
template&lt;class... Args&gt;
  std::pair&lt;iterator, bool&gt; try_emplace(key_type&amp;&amp; k, Args&amp;&amp;... args);
template&lt;class K, class... Args&gt;
  std::pair&lt;iterator, bool&gt; try_emplace(K&amp;&amp; k, Args&amp;&amp;... args);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new node into the container if there is no existing element with key <code>k</code> contained within it.</p>
</div>
<div class="paragraph">
<p>If there is an existing element with key <code>k</code> this function does nothing.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This function is similiar to <a href="#unordered_node_map_emplace">emplace</a>, with the difference that no <code>value_type</code> is constructed
if there is an element with an equivalent key; otherwise, the construction is of the form:<br></p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">// first two overloads
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward&lt;Key&gt;(k)),
           std::forward_as_tuple(boost::forward&lt;Args&gt;(args)...))

// third overload
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward&lt;K&gt;(k)),
           std::forward_as_tuple(boost::forward&lt;Args&gt;(args)...))</code></pre>
</div>
</div>
<div class="paragraph">
<p>unlike <a href="#unordered_node_map_emplace">emplace</a>, which simply forwards all arguments to <code>value_type</code>'s constructor.</p>
</div>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</div>
<div class="paragraph">
<p>The <code>template &lt;class K, class&#8230;&#8203; Args&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_try_emplace_with_hint"><a class="anchor" href="#unordered_node_map_try_emplace_with_hint"></a>try_emplace with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class... Args&gt;
  iterator try_emplace(const_iterator hint, const key_type&amp; k, Args&amp;&amp;... args);
template&lt;class... Args&gt;
  iterator try_emplace(const_iterator hint, key_type&amp;&amp; k, Args&amp;&amp;... args);
template&lt;class K, class... Args&gt;
  iterator try_emplace(const_iterator hint, K&amp;&amp; k, Args&amp;&amp;... args);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new node into the container if there is no existing element with key <code>k</code> contained within it.</p>
</div>
<div class="paragraph">
<p>If there is an existing element with key <code>k</code> this function does nothing.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.  This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This function is similiar to <a href="#unordered_node_map_emplace_hint">emplace_hint</a>, with the difference that no <code>value_type</code> is constructed
if there is an element with an equivalent key; otherwise, the construction is of the form:<br></p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">// first two overloads
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward&lt;Key&gt;(k)),
           std::forward_as_tuple(boost::forward&lt;Args&gt;(args)...))

// third overload
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward&lt;K&gt;(k)),
           std::forward_as_tuple(boost::forward&lt;Args&gt;(args)...))</code></pre>
</div>
</div>
<div class="paragraph">
<p>unlike <a href="#unordered_node_map_emplace_hint">emplace_hint</a>, which simply forwards all arguments to <code>value_type</code>'s constructor.</p>
</div>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</div>
<div class="paragraph">
<p>The <code>template &lt;class K, class&#8230;&#8203; Args&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_insert_or_assign"><a class="anchor" href="#unordered_node_map_insert_or_assign"></a>insert_or_assign</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class M&gt;
  std::pair&lt;iterator, bool&gt; insert_or_assign(const key_type&amp; k, M&amp;&amp; obj);
template&lt;class M&gt;
  std::pair&lt;iterator, bool&gt; insert_or_assign(key_type&amp;&amp; k, M&amp;&amp; obj);
template&lt;class K, class M&gt;
  std::pair&lt;iterator, bool&gt; insert_or_assign(K&amp;&amp; k, M&amp;&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the container or updates an existing one by assigning to the contained value.</p>
</div>
<div class="paragraph">
<p>If there is an element with key <code>k</code>, then it is updated by assigning <code>boost::forward&lt;M&gt;(obj)</code>.</p>
</div>
<div class="paragraph">
<p>If there is no such element, it is added to the container as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">// first two overloads
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward&lt;Key&gt;(k)),
           std::forward_as_tuple(boost::forward&lt;M&gt;(obj)))

// third overload
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward&lt;K&gt;(k)),
           std::forward_as_tuple(boost::forward&lt;M&gt;(obj)))</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load. <br></p>
<div class="paragraph">
<p>The <code>template&lt;class K, class M&gt;</code> only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_insert_or_assign_with_hint"><a class="anchor" href="#unordered_node_map_insert_or_assign_with_hint"></a>insert_or_assign with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class M&gt;
  iterator insert_or_assign(const_iterator hint, const key_type&amp; k, M&amp;&amp; obj);
template&lt;class M&gt;
  iterator insert_or_assign(const_iterator hint, key_type&amp;&amp; k, M&amp;&amp; obj);
template&lt;class K, class M&gt;
  iterator insert_or_assign(const_iterator hint, K&amp;&amp; k, M&amp;&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the container or updates an existing one by assigning to the contained value.</p>
</div>
<div class="paragraph">
<p>If there is an element with key <code>k</code>, then it is updated by assigning <code>boost::forward&lt;M&gt;(obj)</code>.</p>
</div>
<div class="paragraph">
<p>If there is no such element, it is added to the container as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">// first two overloads
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward&lt;Key&gt;(k)),
           std::forward_as_tuple(boost::forward&lt;M&gt;(obj)))

// third overload
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward&lt;K&gt;(k)),
           std::forward_as_tuple(boost::forward&lt;M&gt;(obj)))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K, class M&gt;</code> only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_erase_by_position"><a class="anchor" href="#unordered_node_map_erase_by_position"></a>Erase by Position</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void erase(iterator position);
void erase(const_iterator position);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_erase_by_key"><a class="anchor" href="#unordered_node_map_erase_by_key"></a>Erase by Key</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type erase(const key_type&amp; k);
template&lt;class K&gt; size_type erase(K&amp;&amp; k);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_erase_range"><a class="anchor" href="#unordered_node_map_erase_range"></a>Erase Range</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator erase(const_iterator first, const_iterator last);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing in this implementation (neither the <code>hasher</code> nor the <code>key_equal</code> objects are called).</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_swap"><a class="anchor" href="#unordered_node_map_swap"></a>swap</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void swap(unordered_node_map&amp; other)
  noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
           boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_swap::value);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing unless <code>key_equal</code> or <code>hasher</code> throw on swapping.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_extract_by_position"><a class="anchor" href="#unordered_node_map_extract_by_position"></a>Extract by Position</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">node_type extract(const_iterator position);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Extracts the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> object holding the extracted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_extract_by_key"><a class="anchor" href="#unordered_node_map_extract_by_key"></a>Extract by Key</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">node_type erase(const key_type&amp; k);
template&lt;class K&gt; node_type erase(K&amp;&amp; k);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Extracts the element with key equivalent to <code>k</code>, if it exists.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> object holding the extracted element, or empty if no element was extracted.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_clear"><a class="anchor" href="#unordered_node_map_clear"></a>clear</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void clear() noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code>, <code>max_load() &gt;= max_load_factor() * bucket_count()</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_merge"><a class="anchor" href="#unordered_node_map_merge"></a>merge</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class H2, class P2&gt;
  void merge(unordered_node_map&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
template&lt;class H2, class P2&gt;
  void merge(unordered_node_map&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Transfers all the element nodes from <code>source</code> whose key is not already present in <code>*this</code>.</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_node_map_observers"><a class="anchor" href="#unordered_node_map_observers"></a>Observers</h3>
<div class="sect3">
<h4 id="unordered_node_map_get_allocator"><a class="anchor" href="#unordered_node_map_get_allocator"></a>get_allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">allocator_type get_allocator() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s allocator.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_hash_function"><a class="anchor" href="#unordered_node_map_hash_function"></a>hash_function</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">hasher hash_function() const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_key_eq"><a class="anchor" href="#unordered_node_map_key_eq"></a>key_eq</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">key_equal key_eq() const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_node_map_lookup"><a class="anchor" href="#unordered_node_map_lookup"></a>Lookup</h3>
<div class="sect3">
<h4 id="unordered_node_map_find"><a class="anchor" href="#unordered_node_map_find"></a>find</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator         find(const key_type&amp; k);
const_iterator   find(const key_type&amp; k) const;
template&lt;class K&gt;
  iterator       find(const K&amp; k);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_count"><a class="anchor" href="#unordered_node_map_count"></a>count</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type        count(const key_type&amp; k) const;
template&lt;class K&gt;
  size_type      count(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_contains"><a class="anchor" href="#unordered_node_map_contains"></a>contains</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">bool             contains(const key_type&amp; k) const;
template&lt;class K&gt;
  bool           contains(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_equal_range"><a class="anchor" href="#unordered_node_map_equal_range"></a>equal_range</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::pair&lt;iterator, iterator&gt;               equal_range(const key_type&amp; k);
std::pair&lt;const_iterator, const_iterator&gt;   equal_range(const key_type&amp; k) const;
template&lt;class K&gt;
  std::pair&lt;iterator, iterator&gt;             equal_range(const K&amp; k);
template&lt;class K&gt;
  std::pair&lt;const_iterator, const_iterator&gt; equal_range(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_operator"><a class="anchor" href="#unordered_node_map_operator"></a>operator[]</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">mapped_type&amp; operator[](const key_type&amp; k);
mapped_type&amp; operator[](key_type&amp;&amp; k);
template&lt;class K&gt; mapped_type&amp; operator[](K&amp;&amp; k);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>If the container does not already contain an element with a key equivalent to <code>k</code>, inserts the value <code>std::pair&lt;key_type const, mapped_type&gt;(k, mapped_type())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A reference to <code>x.second</code> where <code>x</code> is the element already in the container, or the newly inserted element with a key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_at"><a class="anchor" href="#unordered_node_map_at"></a>at</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">mapped_type&amp; at(const key_type&amp; k);
const mapped_type&amp; at(const key_type&amp; k) const;
template&lt;class K&gt; mapped_type&amp; at(const K&amp; k);
template&lt;class K&gt; const mapped_type&amp; at(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A reference to <code>x.second</code> where <code>x</code> is the (unique) element whose key is equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>An exception object of type <code>std::out_of_range</code> if no such element is present.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_node_map_bucket_interface"><a class="anchor" href="#unordered_node_map_bucket_interface"></a>Bucket Interface</h3>
<div class="sect3">
<h4 id="unordered_node_map_bucket_count"><a class="anchor" href="#unordered_node_map_bucket_count"></a>bucket_count</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type bucket_count() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The size of the bucket array.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_node_map_hash_policy"><a class="anchor" href="#unordered_node_map_hash_policy"></a>Hash Policy</h3>
<div class="sect3">
<h4 id="unordered_node_map_load_factor"><a class="anchor" href="#unordered_node_map_load_factor"></a>load_factor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">float load_factor() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>static_cast&lt;float&gt;(size())/static_cast&lt;float&gt;(bucket_count())</code>, or <code>0</code> if <code>bucket_count() == 0</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_max_load_factor"><a class="anchor" href="#unordered_node_map_max_load_factor"></a>max_load_factor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">float max_load_factor() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the container&#8217;s maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_set_max_load_factor"><a class="anchor" href="#unordered_node_map_set_max_load_factor"></a>Set max_load_factor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void max_load_factor(float z);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Does nothing, as the user is not allowed to change this parameter. Kept for compatibility with <code>boost::unordered_map</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_max_load"><a class="anchor" href="#unordered_node_map_max_load"></a>max_load</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type max_load() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The maximum number of elements the container can hold without rehashing, assuming that no further elements will be erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>After construction, rehash or clearance, the container&#8217;s maximum load is at least <code>max_load_factor() * bucket_count()</code>.
This number may decrease on erasure under high-load conditions.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_rehash"><a class="anchor" href="#unordered_node_map_rehash"></a>rehash</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void rehash(size_type n);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes if necessary the size of the bucket array so that there are at least <code>n</code> buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the <code>bucket_count()</code> associated with the container.</p>
</div>
<div class="paragraph">
<p>When <code>size() == 0</code>, <code>rehash(0)</code> will deallocate the underlying buckets array.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_reserve"><a class="anchor" href="#unordered_node_map_reserve"></a>reserve</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void reserve(size_type n);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>a.rehash(ceil(n / a.max_load_factor()))</code>.</p>
</div>
<div class="paragraph">
<p>Similar to <code>rehash</code>, this function can be used to grow or shrink the number of buckets in the container.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_node_map_deduction_guides"><a class="anchor" href="#unordered_node_map_deduction_guides"></a>Deduction Guides</h3>
<div class="paragraph">
<p>A deduction guide will not participate in overload resolution if any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has an <code>InputIterator</code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p>
</li>
<li>
<p>It has an <code>Allocator</code> template parameter and a type that does not qualify as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Hash</code> template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Pred</code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>size_Â­type</code> parameter type in a deduction guide refers to the <code>size_Â­type</code> member type of the
container type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.</p>
</div>
<div class="sect3">
<h4 id="unordered_node_map_iter_value_type"><a class="anchor" href="#unordered_node_map_iter_value_type"></a><em>iter-value-type</em></h4>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-value-type</em> =
    typename std::iterator_traits&lt;InputIterator&gt;::value_type; // exposition only</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_map_iter_key_type"><a class="anchor" href="#unordered_node_map_iter_key_type"></a><em>iter-key-type</em></h4>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-key-type</em> = std::remove_const_t&lt;
    std::tuple_element_t&lt;0, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;; // exposition only</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_map_iter_mapped_type"><a class="anchor" href="#unordered_node_map_iter_mapped_type"></a><em>iter-mapped-type</em></h4>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-mapped-type</em> =
    std::tuple_element_t&lt;1, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;;  // exposition only</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_map_iter_to_alloc_type"><a class="anchor" href="#unordered_node_map_iter_to_alloc_type"></a><em>iter-to-alloc-type</em></h4>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-to-alloc-type</em> = std::pair&lt;
    std::add_const_t&lt;std::tuple_element_t&lt;0, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;,
    std::tuple_element_t&lt;1, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;; // exposition only</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_node_map_equality_comparisons"><a class="anchor" href="#unordered_node_map_equality_comparisons"></a>Equality Comparisons</h3>
<div class="sect3">
<h4 id="unordered_node_map_operator_2"><a class="anchor" href="#unordered_node_map_operator_2"></a>operator==</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
  bool operator==(const unordered_node_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                  const unordered_node_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_operator_3"><a class="anchor" href="#unordered_node_map_operator_3"></a>operator!=</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
  bool operator!=(const unordered_node_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                  const unordered_node_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_node_map_swap_2"><a class="anchor" href="#unordered_node_map_swap_2"></a>Swap</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
  void swap(unordered_node_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
            unordered_node_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
    noexcept(noexcept(x.swap(y)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing unless <code>key_equal</code> or <code>hasher</code> throw on swapping.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_node_map_erase_if"><a class="anchor" href="#unordered_node_map_erase_if"></a>erase_if</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
  typename unordered_node_map&lt;K, T, H, P, A&gt;::size_type
    erase_if(unordered_node_map&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">auto original_size = c.size();
for (auto i = c.begin(), last = c.end(); i != last; ) {
  if (pred(*i)) {
    i = c.erase(i);
  } else {
    ++i;
  }
}
return original_size - c.size();</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="unordered_node_set"><a class="anchor" href="#unordered_node_set"></a>Class template unordered_node_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>boost::unordered_node_set</code> â€” A node-based, open-addressing unordered associative container that stores unique values.</p>
</div>
<div class="paragraph">
<p><code>boost::unordered_node_set</code> uses an open-addressing layout like <code>boost::unordered_flat_set</code>, but,
being node-based, it provides pointer/iterator stability and node handling functionalities.
Its performance lies between those of <code>boost::unordered_set</code> and <code>boost::unordered_flat_set</code>.</p>
</div>
<div class="paragraph">
<p>As a result of its using open addressing, the interface of <code>boost::unordered_node_set</code> deviates in
a number of aspects from that of <code>boost::unordered_set</code>/<code>std::unordered_set</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>begin()</code> is not constant-time.</p>
</li>
<li>
<p><code>erase(iterator)</code> returns <code>void</code>.</p>
</li>
<li>
<p>There is no API for bucket handling (except <code>bucket_count</code>).</p>
</li>
<li>
<p>The maximum load factor of the container is managed internally and can&#8217;t be set by the user.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Other than this, <code>boost::unordered_node_set</code> is mostly a drop-in replacement of standard
unordered associative containers.</p>
</div>
<div class="sect2">
<h3 id="unordered_node_set_synopsis"><a class="anchor" href="#unordered_node_set_synopsis"></a>Synopsis</h3>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/unordered_node_set.hpp&gt;

namespace boost {
  template&lt;class Key,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;Key&gt;&gt;
  class unordered_node_set {
  public:
    // types
    using key_type             = Key;
    using value_type           = Key;
    using init_type            = Key;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename std::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename std::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = std::size_t;
    using difference_type      = std::ptrdiff_t;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;

    using node_type            = <em>implementation-defined</em>;
    using insert_return_type   = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_node_set_default_constructor">unordered_node_set</a>();
    explicit <a href="#unordered_node_set_bucket_count_constructor">unordered_node_set</a>(size_type n,
                                const hasher&amp; hf = hasher(),
                                const key_equal&amp; eql = key_equal(),
                                const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_node_set_iterator_range_constructor">unordered_node_set</a>(InputIterator f, InputIterator l,
                         size_type n = <em>implementation-defined</em>,
                         const hasher&amp; hf = hasher(),
                         const key_equal&amp; eql = key_equal(),
                         const allocator_type&amp; a = allocator_type());
    <a href="#unordered_node_set_copy_constructor">unordered_node_set</a>(const unordered_node_set&amp; other);
    <a href="#unordered_node_set_move_constructor">unordered_node_set</a>(unordered_node_set&amp;&amp; other);
    template&lt;class InputIterator&gt;
      <a href="#unordered_node_set_iterator_range_constructor_with_allocator">unordered_node_set</a>(InputIterator f, InputIterator l, const allocator_type&amp; a);
    explicit <a href="#unordered_node_set_allocator_constructor">unordered_node_set</a>(const Allocator&amp; a);
    <a href="#unordered_node_set_copy_constructor_with_allocator">unordered_node_set</a>(const unordered_node_set&amp; other, const Allocator&amp; a);
    <a href="#unordered_node_set_move_constructor_with_allocator">unordered_node_set</a>(unordered_node_set&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_node_set_initializer_list_constructor">unordered_node_set</a>(std::initializer_list&lt;value_type&gt; il,
                       size_type n = <em>implementation-defined</em>
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
    <a href="#unordered_node_set_bucket_count_constructor_with_allocator">unordered_node_set</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_node_set_bucket_count_constructor_with_hasher_and_allocator">unordered_node_set</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_node_set_iterator_range_constructor_with_bucket_count_and_allocator">unordered_node_set</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_node_set_iterator_range_constructor_with_bucket_count_and_hasher">unordered_node_set</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                         const allocator_type&amp; a);
    <a href="#unordered_node_set_initializer_list_constructor_with_allocator">unordered_node_set</a>(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);
    <a href="#unordered_node_set_initializer_list_constructor_with_bucket_count_and_allocator">unordered_node_set</a>(std::initializer_list&lt;value_type&gt; il, size_type n,
                       const allocator_type&amp; a);
    <a href="#unordered_node_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_node_set</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                       const allocator_type&amp; a);
    <a href="#unordered_node_set_destructor">~unordered_node_set</a>();
    unordered_node_set&amp; <a href="#unordered_node_set_copy_assignment">operator=</a>(const unordered_node_set&amp; other);
    unordered_node_set&amp; <a href="#unordered_node_set_move_assignment">operator=</a>(unordered_node_set&amp;&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
              boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value);
    unordered_node_set&amp; <a href="#unordered_node_set_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt;);
    allocator_type <a href="#unordered_node_set_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_node_set_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_node_set_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_node_set_end">end</a>() noexcept;
    const_iterator <a href="#unordered_node_set_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_node_set_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_node_set_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_node_set_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_node_set_size">size</a>() const noexcept;
    size_type <a href="#unordered_node_set_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_node_set_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_node_set_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_node_set_copy_insert">insert</a>(const value_type&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_node_set_move_insert">insert</a>(value_type&amp;&amp; obj);
    template&lt;class K&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_node_set_transparent_insert">insert</a>(K&amp;&amp; k);
    iterator <a href="#unordered_node_set_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator <a href="#unordered_node_set_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    template&lt;class K&gt; iterator <a href="#unordered_node_set_transparent_insert_with_hint">insert</a>(const_iterator hint, K&amp;&amp; k);
    template&lt;class InputIterator&gt; void <a href="#unordered_node_set_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_node_set_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt;);
    insert_return_type <a href="#unordered_node_set_insert_node">insert</a>(node_type&amp;&amp; nh);
    iterator <a href="#unordered_node_set_insert_node_with_hint">insert</a>(const_iterator hint, node_type&amp;&amp; nh);

    void      <a href="#unordered_node_set_erase_by_position">erase</a>(iterator position);
    void      <a href="#unordered_node_set_erase_by_position">erase</a>(const_iterator position);
    size_type <a href="#unordered_node_set_erase_by_key">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_node_set_erase_by_key">erase</a>(K&amp;&amp; k);
    iterator  <a href="#unordered_node_set_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_node_set_swap">swap</a>(unordered_node_set&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
               boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_swap::value);
    node_type <a href="#unordered_node_set_extract_by_position">extract</a>(const_iterator position);
    node_type <a href="#unordered_node_set_extract_by_key">extract</a>(const key_type&amp; key);
    template&lt;class K&gt; node_type <a href="#unordered_node_set_extract_by_key">extract</a>(K&amp;&amp; key);
    void      <a href="#unordered_node_set_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_node_set_merge">merge</a>(unordered_node_set&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_node_set_merge">merge</a>(unordered_node_set&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_node_set_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_node_set_key_eq">key_eq</a>() const;

    // set operations
    iterator         <a href="#unordered_node_set_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_node_set_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_node_set_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_node_set_find">find</a>(const K&amp; k) const;
    size_type        <a href="#unordered_node_set_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_node_set_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_node_set_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_node_set_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_node_set_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_node_set_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_node_set_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_node_set_equal_range">equal_range</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_node_set_bucket_count">bucket_count</a>() const noexcept;

    // hash policy
    float <a href="#unordered_node_set_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_node_set_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_node_set_set_max_load_factor">max_load_factor</a>(float z);
    size_type <a href="#unordered_node_set_max_load">max_load</a>() const noexcept;
    void <a href="#unordered_node_set_rehash">rehash</a>(size_type n);
    void <a href="#unordered_node_set_reserve">reserve</a>(size_type n);
  };

  // Deduction Guides
  template&lt;class InputIterator,
           class Hash = boost::hash&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
           class Pred = std::equal_to&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
           class Allocator = std::allocator&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;
    unordered_node_set(InputIterator, InputIterator, typename <a href="#unordered_node_set_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_node_set_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_node_set&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;, Hash, Pred, Allocator&gt;;

  template&lt;class T, class Hash = boost::hash&lt;T&gt;, class Pred = std::equal_to&lt;T&gt;,
           class Allocator = std::allocator&lt;T&gt;&gt;
    unordered_node_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_node_set_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_node_set_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_node_set&lt;T, Hash, Pred, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_node_set(InputIterator, InputIterator, typename <a href="#unordered_node_set_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_node_set&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_node_set(InputIterator, InputIterator, Allocator)
      -&gt; unordered_node_set&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Hash, class Allocator&gt;
    unordered_node_set(InputIterator, InputIterator, typename <a href="#unordered_node_set_deduction_guides"><em>see below</em></a>::size_type, Hash,
                       Allocator)
      -&gt; unordered_node_set&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;, Hash,
                            std::equal_to&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_node_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_node_set_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_node_set&lt;T, boost::hash&lt;T&gt;, std::equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_node_set(std::initializer_list&lt;T&gt;, Allocator)
      -&gt; unordered_node_set&lt;T, boost::hash&lt;T&gt;, std::equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Hash, class Allocator&gt;
    unordered_node_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_node_set_deduction_guides"><em>see below</em></a>::size_type, Hash, Allocator)
      -&gt; unordered_node_set&lt;T, Hash, std::equal_to&lt;T&gt;, Allocator&gt;;

  // Equality Comparisons
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_node_set_operator_2">operator!=</a>(const unordered_node_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_node_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_node_set_operator_3">operator!=</a>(const unordered_node_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_node_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  // swap
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    void <a href="#unordered_node_set_swap_2">swap</a>(unordered_node_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
              unordered_node_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
    typename unordered_node_set&lt;K, T, H, P, A&gt;::size_type
       <a href="#unordered_node_set_erase_if">erase_if</a>(unordered_node_set&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_node_set_description"><a class="anchor" href="#unordered_node_set_description"></a>Description</h3>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Key</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type <code>bool</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.
<code>std::allocator_traits&lt;Allocator&gt;::pointer</code> and <code>std::allocator_traits&lt;Allocator&gt;::const_pointer</code>
must be convertible to/from <code>value_type*</code> and <code>const value_type*</code>, respectively.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The element nodes of the container are held into an internal <em>bucket array</em>. A node is inserted into a bucket determined by
the hash code of its element, but if the bucket is already occupied (a <em>collision</em>), an available one in the vicinity of the
original position is used.</p>
</div>
<div class="paragraph">
<p>The size of the bucket array can be automatically increased by a call to <code>insert</code>/<code>emplace</code>, or as a result of calling
<code>rehash</code>/<code>reserve</code>. The <em>load factor</em> of the container (number of elements divided by number of buckets) is never
greater than <code>max_load_factor()</code>, except possibly for small sizes where the implementation may decide to
allow for higher loads.</p>
</div>
<div class="paragraph">
<p>If <code><a href="#hash_traits_hash_is_avalanching">hash_is_avalanching</a>&lt;Hash&gt;::value</code> is <code>true</code>, the hash function
is used as-is; otherwise, a bit-mixing post-processing stage is added to increase the quality of hashing
at the expense of extra computational cost.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_node_set_typedefs"><a class="anchor" href="#unordered_node_set_typedefs"></a>Typedefs</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> iterator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> const_iterator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> node_type;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A class for holding extracted container elements, modelling
<a href="https://en.cppreference.com/w/cpp/container/node_handle">NodeHandle</a>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">typedef <em>implementation-defined</em> insert_return_type;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A specialization of an internal class template:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class Iterator, class NodeType&gt;
struct <em>insert_return_type</em> // name is exposition only
{
  Iterator position;
  bool     inserted;
  NodeType node;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>with <code>Iterator</code> = <code>iterator</code> and <code>NodeType</code> = <code>node_type</code>.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_node_set_constructors"><a class="anchor" href="#unordered_node_set_constructors"></a>Constructors</h3>
<div class="sect3">
<h4 id="unordered_node_set_default_constructor"><a class="anchor" href="#unordered_node_set_default_constructor"></a>Default Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_set();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate and <code>allocator_type()</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_bucket_count_constructor"><a class="anchor" href="#unordered_node_set_bucket_count_constructor"></a>Bucket Count Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">explicit unordered_node_set(size_type n,
                            const hasher&amp; hf = hasher(),
                            const key_equal&amp; eql = key_equal(),
                            const allocator_type&amp; a = allocator_type());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_iterator_range_constructor"><a class="anchor" href="#unordered_node_set_iterator_range_constructor"></a>Iterator Range Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
  unordered_node_set(InputIterator f, InputIterator l,
                     size_type n = <em>implementation-defined</em>,
                     const hasher&amp; hf = hasher(),
                     const key_equal&amp; eql = key_equal(),
                     const allocator_type&amp; a = allocator_type());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code> as the allocator, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_copy_constructor"><a class="anchor" href="#unordered_node_set_copy_constructor"></a>Copy Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_set(unordered_node_set const&amp; other);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_move_constructor"><a class="anchor" href="#unordered_node_set_move_constructor"></a>Move Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_set(unordered_node_set&amp;&amp; other);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor. The internal bucket array of <code>other</code> is transferred directly to the new container.
The hash function, predicate and allocator are moved-constructed from <code>other</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_iterator_range_constructor_with_allocator"><a class="anchor" href="#unordered_node_set_iterator_range_constructor_with_allocator"></a>Iterator Range Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
  unordered_node_set(InputIterator f, InputIterator l, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator, with the default hash function and key equality predicate and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_allocator_constructor"><a class="anchor" href="#unordered_node_set_allocator_constructor"></a>Allocator Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">explicit unordered_node_set(Allocator const&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_copy_constructor_with_allocator"><a class="anchor" href="#unordered_node_set_copy_constructor_with_allocator"></a>Copy Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_set(unordered_node_set const&amp; other, Allocator const&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs a container, copying <code>other</code>'s contained elements, hash function, and predicate, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_move_constructor_with_allocator"><a class="anchor" href="#unordered_node_set_move_constructor_with_allocator"></a>Move Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_set(unordered_node_set&amp;&amp; other, Allocator const&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>a == other.get_allocator()</code>, the element nodes of <code>other</code> are transferred directly to the new container;
otherwise, elements are moved-constructed from those of <code>other</code>. The hash function and predicate are moved-constructed
from <code>other</code>, and the allocator is copy-constructed from <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_initializer_list_constructor"><a class="anchor" href="#unordered_node_set_initializer_list_constructor"></a>Initializer List Constructor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_set(std::initializer_list&lt;value_type&gt; il,
              size_type n = <em>implementation-defined</em>
              const hasher&amp; hf = hasher(),
              const key_equal&amp; eql = key_equal(),
              const allocator_type&amp; a = allocator_type());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code>, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_bucket_count_constructor_with_allocator"><a class="anchor" href="#unordered_node_set_bucket_count_constructor_with_allocator"></a>Bucket Count Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_set(size_type n, allocator_type const&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_bucket_count_constructor_with_hasher_and_allocator"><a class="anchor" href="#unordered_node_set_bucket_count_constructor_with_hasher_and_allocator"></a>Bucket Count Constructor with Hasher and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_set(size_type n, hasher const&amp; hf, allocator_type const&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_iterator_range_constructor_with_bucket_count_and_allocator"><a class="anchor" href="#unordered_node_set_iterator_range_constructor_with_bucket_count_and_allocator"></a>Iterator Range Constructor with Bucket Count and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt;
  unordered_node_set(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and default hash function and key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_iterator_range_constructor_with_bucket_count_and_hasher"><a class="anchor" href="#unordered_node_set_iterator_range_constructor_with_bucket_count_and_hasher"></a>Iterator Range Constructor with Bucket Count and Hasher</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">    template&lt;class InputIterator&gt;
      unordered_node_set(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                         const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_initializer_list_constructor_with_allocator"><a class="anchor" href="#unordered_node_set_initializer_list_constructor_with_allocator"></a>initializer_list Constructor with Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_set(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_initializer_list_constructor_with_bucket_count_and_allocator"><a class="anchor" href="#unordered_node_set_initializer_list_constructor_with_bucket_count_and_allocator"></a>initializer_list Constructor with Bucket Count and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_set(std::initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="anchor" href="#unordered_node_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"></a>initializer_list Constructor with Bucket Count and Hasher and Allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_set(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                   const allocator_type&amp; a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and default key equality predicate,and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_node_set_destructor"><a class="anchor" href="#unordered_node_set_destructor"></a>Destructor</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">~unordered_node_set();</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_node_set_assignment"><a class="anchor" href="#unordered_node_set_assignment"></a>Assignment</h3>
<div class="sect3">
<h4 id="unordered_node_set_copy_assignment"><a class="anchor" href="#unordered_node_set_copy_assignment"></a>Copy Assignment</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_set&amp; operator=(unordered_node_set const&amp; other);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Destroys previously existing elements, copy-assigns the hash function and predicate from <code>other</code>,
copy-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>,
and finally inserts copies of the elements of <code>other</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_move_assignment"><a class="anchor" href="#unordered_node_set_move_assignment"></a>Move Assignment</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_set&amp; operator=(unordered_node_set&amp;&amp; other)
  noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
           boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator. Destroys previously existing elements, swaps the hash function and predicate from <code>other</code>,
and move-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>.
If at this point the allocator is equal to <code>other.get_allocator()</code>, the internal bucket array of <code>other</code> is transferred directly to the new container;
otherwise, inserts move-constructed copies of the elements of <code>other</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_initializer_list_assignment"><a class="anchor" href="#unordered_node_set_initializer_list_assignment"></a>Initializer List Assignment</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">unordered_node_set&amp; operator=(std::initializer_list&lt;value_type&gt; il);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All previously existing elements are destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_node_set_iterators"><a class="anchor" href="#unordered_node_set_iterators"></a>Iterators</h3>
<div class="sect3">
<h4 id="unordered_node_set_begin"><a class="anchor" href="#unordered_node_set_begin"></a>begin</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator begin() noexcept;
const_iterator begin() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>O(<code>bucket_count()</code>)</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_end"><a class="anchor" href="#unordered_node_set_end"></a>end</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator end() noexcept;
const_iterator end() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_cbegin"><a class="anchor" href="#unordered_node_set_cbegin"></a>cbegin</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">const_iterator cbegin() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>O(<code>bucket_count()</code>)</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_cend"><a class="anchor" href="#unordered_node_set_cend"></a>cend</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">const_iterator cend() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_node_set_size_and_capacity"><a class="anchor" href="#unordered_node_set_size_and_capacity"></a>Size and Capacity</h3>
<div class="sect3">
<h4 id="unordered_node_set_empty"><a class="anchor" href="#unordered_node_set_empty"></a>empty</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">[[nodiscard]] bool empty() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_size"><a class="anchor" href="#unordered_node_set_size"></a>size</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type size() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_max_size"><a class="anchor" href="#unordered_node_set_max_size"></a>max_size</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type max_size() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_node_set_modifiers"><a class="anchor" href="#unordered_node_set_modifiers"></a>Modifiers</h3>
<div class="sect3">
<h4 id="unordered_node_set_emplace"><a class="anchor" href="#unordered_node_set_emplace"></a>emplace</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class... Args&gt; std::pair&lt;iterator, bool&gt; emplace(Args&amp;&amp;... args);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_emplace_hint"><a class="anchor" href="#unordered_node_set_emplace_hint"></a>emplace_hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">    template&lt;class... Args&gt; iterator emplace_hint(const_iterator position, Args&amp;&amp;... args);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>position</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_copy_insert"><a class="anchor" href="#unordered_node_set_copy_insert"></a>Copy Insert</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::pair&lt;iterator, bool&gt; insert(const value_type&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_move_insert"><a class="anchor" href="#unordered_node_set_move_insert"></a>Move Insert</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::pair&lt;iterator, bool&gt; insert(value_type&amp;&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_transparent_insert"><a class="anchor" href="#unordered_node_set_transparent_insert"></a>Transparent Insert</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class K&gt; std::pair&lt;iterator, bool&gt; insert(K&amp;&amp; k);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element constructed from <code>std::forward&lt;K&gt;(k)</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> from <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_copy_insert_with_hint"><a class="anchor" href="#unordered_node_set_copy_insert_with_hint"></a>Copy Insert with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(const_iterator hint, const value_type&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_move_insert_with_hint"><a class="anchor" href="#unordered_node_set_move_insert_with_hint"></a>Move Insert with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(const_iterator hint, value_type&amp;&amp; obj);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_transparent_insert_with_hint"><a class="anchor" href="#unordered_node_set_transparent_insert_with_hint"></a>Transparent Insert with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class K&gt; std::pair&lt;iterator, bool&gt; insert(const_iterator hint, K&amp;&amp; k);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element constructed from <code>std::forward&lt;K&gt;(k)</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> from <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_insert_iterator_range"><a class="anchor" href="#unordered_node_set_insert_iterator_range"></a>Insert Iterator Range</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class InputIterator&gt; void insert(InputIterator first, InputIterator last);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into the container from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_insert_initializer_list"><a class="anchor" href="#unordered_node_set_insert_initializer_list"></a>Insert Initializer List</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void insert(std::initializer_list&lt;value_type&gt;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into the container from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_insert_node"><a class="anchor" href="#unordered_node_set_insert_node"></a>Insert Node</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">insert_return_type insert(node_type&amp;&amp; nh);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is not empty, inserts the associated element in the container if and only if there is no element in the container with a key equivalent to <code>nh.value()</code>.
<code>nh</code> is empty when the function returns.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An <code>insert_return_type</code> object constructed from <code>position</code>, <code>inserted</code> and <code>node</code>:<br></p>
<div class="ulist">
<ul>
<li>
<p>If <code>nh</code> is empty, <code>inserted</code> is <code>false</code>, <code>position</code> is <code>end()</code>, and <code>node</code> is empty.</p>
</li>
<li>
<p>Otherwise if the insertion took place, <code>inserted</code> is true, <code>position</code> points to the inserted element, and <code>node</code> is empty.</p>
</li>
<li>
<p>If the insertion failed, <code>inserted</code> is false, <code>node</code> has the previous value of <code>nh</code>, and <code>position</code> points to an element with a key equivalent to <code>nh.value()</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if <code>nh</code> is not empty and the allocators of <code>nh</code> and the container are not equal.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_insert_node_with_hint"><a class="anchor" href="#unordered_node_set_insert_node_with_hint"></a>Insert Node with Hint</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator insert(const_iterator hint, node_type&amp;&amp; nh);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is not empty, inserts the associated element in the container if and only if there is no element in the container with a key equivalent to <code>nh.value()</code>.
<code>nh</code> becomes empty if insertion took place, otherwise it is not changed.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator returned is <code>end()</code> if <code>nh</code> is empty.
If insertion took place, then the iterator points to the newly inserted element; otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if <code>nh</code> is not empty and the allocators of <code>nh</code> and the container are not equal.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_erase_by_position"><a class="anchor" href="#unordered_node_set_erase_by_position"></a>Erase by Position</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void erase(iterator position);
void erase(const_iterator position);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_erase_by_key"><a class="anchor" href="#unordered_node_set_erase_by_key"></a>Erase by Key</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type erase(const key_type&amp; k);
template&lt;class K&gt; size_type erase(K&amp;&amp; k);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_erase_range"><a class="anchor" href="#unordered_node_set_erase_range"></a>Erase Range</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator erase(const_iterator first, const_iterator last);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing in this implementation (neither the <code>hasher</code> nor the <code>key_equal</code> objects are called).</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_swap"><a class="anchor" href="#unordered_node_set_swap"></a>swap</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void swap(unordered_node_set&amp; other)
  noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
           boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_swap::value);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing unless <code>key_equal</code> or <code>hasher</code> throw on swapping.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_extract_by_position"><a class="anchor" href="#unordered_node_set_extract_by_position"></a>Extract by Position</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">node_type extract(const_iterator position);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Extracts the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> object holding the extracted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_extract_by_key"><a class="anchor" href="#unordered_node_set_extract_by_key"></a>Extract by Key</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">node_type erase(const key_type&amp; k);
template&lt;class K&gt; node_type erase(K&amp;&amp; k);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Extracts the element with key equivalent to <code>k</code>, if it exists.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> object holding the extracted element, or empty if no element was extracted.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_clear"><a class="anchor" href="#unordered_node_set_clear"></a>clear</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void clear() noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code>, <code>max_load() &gt;= max_load_factor() * bucket_count()</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_merge"><a class="anchor" href="#unordered_node_set_merge"></a>merge</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class H2, class P2&gt;
  void merge(unordered_node_set&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
template&lt;class H2, class P2&gt;
  void merge(unordered_node_set&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Transfers all the element nodes from <code>source</code> whose key is not already present in <code>*this</code>.</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_node_set_observers"><a class="anchor" href="#unordered_node_set_observers"></a>Observers</h3>
<div class="sect3">
<h4 id="unordered_node_set_get_allocator"><a class="anchor" href="#unordered_node_set_get_allocator"></a>get_allocator</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">allocator_type get_allocator() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s allocator.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_hash_function"><a class="anchor" href="#unordered_node_set_hash_function"></a>hash_function</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">hasher hash_function() const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_key_eq"><a class="anchor" href="#unordered_node_set_key_eq"></a>key_eq</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">key_equal key_eq() const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_node_set_lookup"><a class="anchor" href="#unordered_node_set_lookup"></a>Lookup</h3>
<div class="sect3">
<h4 id="unordered_node_set_find"><a class="anchor" href="#unordered_node_set_find"></a>find</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">iterator         find(const key_type&amp; k);
const_iterator   find(const key_type&amp; k) const;
template&lt;class K&gt;
  iterator       find(const K&amp; k);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_count"><a class="anchor" href="#unordered_node_set_count"></a>count</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type        count(const key_type&amp; k) const;
template&lt;class K&gt;
  size_type      count(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_contains"><a class="anchor" href="#unordered_node_set_contains"></a>contains</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">bool             contains(const key_type&amp; k) const;
template&lt;class K&gt;
  bool           contains(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_equal_range"><a class="anchor" href="#unordered_node_set_equal_range"></a>equal_range</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::pair&lt;iterator, iterator&gt;               equal_range(const key_type&amp; k);
std::pair&lt;const_iterator, const_iterator&gt;   equal_range(const key_type&amp; k) const;
template&lt;class K&gt;
  std::pair&lt;iterator, iterator&gt;             equal_range(const K&amp; k);
template&lt;class K&gt;
  std::pair&lt;const_iterator, const_iterator&gt; equal_range(const K&amp; k) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_node_set_bucket_interface"><a class="anchor" href="#unordered_node_set_bucket_interface"></a>Bucket Interface</h3>
<div class="sect3">
<h4 id="unordered_node_set_bucket_count"><a class="anchor" href="#unordered_node_set_bucket_count"></a>bucket_count</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type bucket_count() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The size of the bucket array.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_node_set_hash_policy"><a class="anchor" href="#unordered_node_set_hash_policy"></a>Hash Policy</h3>
<div class="sect3">
<h4 id="unordered_node_set_load_factor"><a class="anchor" href="#unordered_node_set_load_factor"></a>load_factor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">float load_factor() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>static_cast&lt;float&gt;(size())/static_cast&lt;float&gt;(bucket_count())</code>, or <code>0</code> if <code>bucket_count() == 0</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_max_load_factor"><a class="anchor" href="#unordered_node_set_max_load_factor"></a>max_load_factor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">float max_load_factor() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the container&#8217;s maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_set_max_load_factor"><a class="anchor" href="#unordered_node_set_set_max_load_factor"></a>Set max_load_factor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void max_load_factor(float z);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Does nothing, as the user is not allowed to change this parameter. Kept for compatibility with <code>boost::unordered_set</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_max_load"><a class="anchor" href="#unordered_node_set_max_load"></a>max_load</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">size_type max_load() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The maximum number of elements the container can hold without rehashing, assuming that no further elements will be erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>After construction, rehash or clearance, the container&#8217;s maximum load is at least <code>max_load_factor() * bucket_count()</code>.
This number may decrease on erasure under high-load conditions.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_rehash"><a class="anchor" href="#unordered_node_set_rehash"></a>rehash</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void rehash(size_type n);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes if necessary the size of the bucket array so that there are at least <code>n</code> buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the <code>bucket_count()</code> associated with the container.</p>
</div>
<div class="paragraph">
<p>When <code>size() == 0</code>, <code>rehash(0)</code> will deallocate the underlying buckets array.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_reserve"><a class="anchor" href="#unordered_node_set_reserve"></a>reserve</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void reserve(size_type n);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>a.rehash(ceil(n / a.max_load_factor()))</code>.</p>
</div>
<div class="paragraph">
<p>Similar to <code>rehash</code>, this function can be used to grow or shrink the number of buckets in the container.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_node_set_deduction_guides"><a class="anchor" href="#unordered_node_set_deduction_guides"></a>Deduction Guides</h3>
<div class="paragraph">
<p>A deduction guide will not participate in overload resolution if any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has an <code>InputIterator</code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p>
</li>
<li>
<p>It has an <code>Allocator</code> template parameter and a type that does not qualify as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Hash</code> template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Pred</code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>size_Â­type</code> parameter type in a deduction guide refers to the <code>size_Â­type</code> member type of the
container type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.</p>
</div>
<div class="sect3">
<h4 id="unordered_node_set_iter_value_type"><a class="anchor" href="#unordered_node_set_iter_value_type"></a><em>iter-value-type</em></h4>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-value-type</em> =
    typename std::iterator_traits&lt;InputIterator&gt;::value_type; // exposition only</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_node_set_equality_comparisons"><a class="anchor" href="#unordered_node_set_equality_comparisons"></a>Equality Comparisons</h3>
<div class="sect3">
<h4 id="unordered_node_set_operator"><a class="anchor" href="#unordered_node_set_operator"></a>operator==</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
  bool operator==(const unordered_node_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                  const unordered_node_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_operator_2"><a class="anchor" href="#unordered_node_set_operator_2"></a>operator!=</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
  bool operator!=(const unordered_node_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                  const unordered_node_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_node_set_swap_2"><a class="anchor" href="#unordered_node_set_swap_2"></a>Swap</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
  void swap(unordered_node_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
            unordered_node_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
    noexcept(noexcept(x.swap(y)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing unless <code>key_equal</code> or <code>hasher</code> throw on swapping.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="unordered_node_set_erase_if"><a class="anchor" href="#unordered_node_set_erase_if"></a>erase_if</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
  typename unordered_node_set&lt;K, T, H, P, A&gt;::size_type
    erase_if(unordered_node_set&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">auto original_size = c.size();
for (auto i = c.begin(), last = c.end(); i != last; ) {
  if (pred(*i)) {
    i = c.erase(i);
  } else {
    ++i;
  }
}
return original_size - c.size();</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<script id="site-script" src="../../_/js/site.js" data-ui-root-path="../../_"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
  </body>
</html>
