<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>The Data Structure :: Antora Docs</title>
    <meta name="generator" content="Antora 3.1.2">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../..">Antora Docs</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="unordered" data-version="develop">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Boost.Unordered</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="intro.html">Introduction</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="buckets.html">The Data Structure</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="hash_equality.html">Equality Predicates and Hash Functions</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="comparison.html">Comparison with Associative Containers</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="compliance.html">Standard Compliance</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="benchmarks.html">Benchmarks</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="rationale.html">Implementation Rationale</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Reference</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="hash_traits.html"><code>hash_traits</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="unordered_flat_map.html"><code>unordered_flat_map</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="unordered_flat_set.html"><code>unordered_flat_set</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="unordered_map.html"><code>unordered_map</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="unordered_multimap.html"><code>unordered_multimap</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="unordered_multiset.html"><code>unordered_multiset</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="unordered_node_map.html"><code>unordered_node_map</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="unordered_node_set.html"><code>unordered_node_set</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="unordered_set.html"><code>unordered_set</code></a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="changes.html">Change Log</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="bibliography.html">Bibliography</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="copyright.html">Copyright and License</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Boost.Unordered</span>
    <span class="version">develop</span>
  </div>
  <ul class="components">
    <li class="component">
      <a class="title" href="../../../mp11/index.html">Boost.Mp11</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../mp11/index.html">master</a>
        </li>
        <li class="version">
          <a href="../../../mp11/develop/index.html">develop</a>
        </li>
        <li class="version">
          <a href="../../../mp11/boost-1.82.0/index.html">boost-1.82.0</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <a class="title" href="../index.html">Boost.Unordered</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">develop</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Boost.Unordered</a></li>
    <li><a href="buckets.html">The Data Structure</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="file:///c:/Users/vinnie/src/boost/libs/unordered/antora/modules/ROOT/pages/unordered/buckets.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">The Data Structure</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>The containers are made up of a number of 'buckets', each of which can contain
any number of elements. For example, the following diagram shows a <a href="#unordered_set"><code>boost::unordered_set</code></a> with 7 buckets containing 5 elements, <code>A</code>,
<code>B</code>, <code>C</code>, <code>D</code> and <code>E</code> (this is just for illustration, containers will typically
have more buckets).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../_images/buckets.png" alt="buckets">
</div>
</div>
<div class="paragraph">
<p>In order to decide which bucket to place an element in, the container applies
the hash function, <code>Hash</code>, to the element&#8217;s key (for <code>unordered_set</code> and
<code>unordered_multiset</code> the key is the whole element, but is referred to as the key
so that the same terminology can be used for sets and maps). This returns a
value of type <code>std::size_t</code>. <code>std::size_t</code> has a much greater range of values
then the number of buckets, so the container applies another transformation to
that value to choose a bucket to place the element in.</p>
</div>
<div class="paragraph">
<p>Retrieving the elements for a given key is simple. The same process is applied
to the key to find the correct bucket. Then the key is compared with the
elements in the bucket to find any elements that match (using the equality
predicate <code>Pred</code>). If the hash function has worked well the elements will be
evenly distributed amongst the buckets so only a small number of elements will
need to be examined.</p>
</div>
<div class="paragraph">
<p>There is <a href="#hash_equality">more information on hash functions and
equality predicates in the next section</a>.</p>
</div>
<div class="paragraph">
<p>You can see in the diagram that <code>A</code> &amp; <code>D</code> have been placed in the same bucket.
When looking for elements in this bucket up to 2 comparisons are made, making
the search slower. This is known as a <strong>collision</strong>. To keep things fast we try to
keep collisions to a minimum.</p>
</div>
<div class="paragraph">
<p>If instead of <code>boost::unordered_set</code> we had used <a href="#unordered_flat_set"><code>boost::unordered_flat_set</code></a>, the
diagram would look as follows:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../_images/buckets-oa.png" alt="buckets oa">
</div>
</div>
<div class="paragraph">
<p>In open-addressing containers, buckets can hold at most one element; if a collision happens
(like is the case of <code>D</code> in the example), the element uses some other available bucket in
the vicinity of the original position. Given this simpler scenario, Boost.Unordered
open-addressing containers offer a very limited API for accessing buckets.</p>
</div>
<table class="tableblock frame-all grid-rows stretch">
<caption class="title">Table 1. Methods for Accessing Buckets</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-center valign-top" colspan="2"><p class="tableblock"><strong>All containers</strong></p></th>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><strong>Method</strong></p></th>
<th class="tableblock halign-left valign-middle"><p class="tableblock"><strong>Description</strong></p></th>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>size_type bucket_count() const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">The number of buckets.</p></td>
</tr>
<tr>
<th class="tableblock halign-center valign-top" colspan="2"><p class="tableblock"><strong>Closed-addressing containers only</strong><br>
<code>boost::unordered_[multi]set</code>, <code>boost::unordered_[multi]map</code></p></th>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><strong>Method</strong></p></th>
<th class="tableblock halign-left valign-middle"><p class="tableblock"><strong>Description</strong></p></th>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>size_type max_bucket_count() const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">An upper bound on the number of buckets.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>size_type bucket_size(size_type n) const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">The number of elements in bucket <code>n</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>size_type bucket(key_type const&amp; k) const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Returns the index of the bucket which would contain <code>k</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>local_iterator begin(size_type n)</code></p></td>
<td class="tableblock halign-left valign-middle" rowspan="6"><p class="tableblock">Return begin and end iterators for bucket <code>n</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>local_iterator end(size_type n)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>const_local_iterator begin(size_type n) const</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>const_local_iterator end(size_type n) const</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>const_local_iterator cbegin(size_type n) const</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>const_local_iterator cend(size_type n) const</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="buckets_controlling_the_number_of_buckets"><a class="anchor" href="#buckets_controlling_the_number_of_buckets"></a>Controlling the number of buckets</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As more elements are added to an unordered associative container, the number
of collisions will increase causing performance to degrade.
To combat this the containers increase the bucket count as elements are inserted.
You can also tell the container to change the bucket count (if required) by
calling <code>rehash</code>.</p>
</div>
<div class="paragraph">
<p>The standard leaves a lot of freedom to the implementer to decide how the
number of buckets is chosen, but it does make some requirements based on the
container&#8217;s 'load factor', the number of elements divided by the number of buckets.
Containers also have a 'maximum load factor' which they should try to keep the
load factor below.</p>
</div>
<div class="paragraph">
<p>You can&#8217;t control the bucket count directly but there are two ways to
influence it:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Specify the minimum number of buckets when constructing a container or when calling <code>rehash</code>.</p>
</li>
<li>
<p>Suggest a maximum load factor by calling <code>max_load_factor</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>max_load_factor</code> doesn&#8217;t let you set the maximum load factor yourself, it just
lets you give a <em>hint</em>. And even then, the standard doesn&#8217;t actually
require the container to pay much attention to this value. The only time the
load factor is <em>required</em> to be less than the maximum is following a call to
<code>rehash</code>. But most implementations will try to keep the number of elements
below the max load factor, and set the maximum load factor to be the same as
or close to the hint - unless your hint is unreasonably small or large.</p>
</div>
<table class="tableblock frame-all grid-rows stretch">
<caption class="title">Table 2. Methods for Controlling Bucket Size</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-center valign-top" colspan="2"><p class="tableblock"><strong>All containers</strong></p></th>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><strong>Method</strong></p></th>
<th class="tableblock halign-left valign-middle"><p class="tableblock"><strong>Description</strong></p></th>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X(size_type n)</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Construct an empty container with at least <code>n</code> buckets (<code>X</code> is the container type).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X(InputIterator i, InputIterator j, size_type n)</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Construct an empty container with at least <code>n</code> buckets and insert elements from the range <code>[i, j)</code> (<code>X</code> is the container type).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>float load_factor() const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">The average number of elements per bucket.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>float max_load_factor() const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Returns the current maximum load factor.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>float max_load_factor(float z)</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Changes the container&#8217;s maximum load factor, using <code>z</code> as a hint.<br>
<strong>Open-addressing containers:</strong> this function does nothing: users are not allowed to change the maximum load factor.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void rehash(size_type n)</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Changes the number of buckets so that there at least <code>n</code> buckets, and so that the load factor is less than the maximum load factor.</p></td>
</tr>
<tr>
<th class="tableblock halign-center valign-top" colspan="2"><p class="tableblock"><strong>Open-addressing containers only</strong><br>
<code>boost::unordered_flat_set</code>, <code>boost::unordered_flat_map</code><br>
<code>boost::unordered_node_set</code>, <code>boost::unordered_node_map</code><br></p></th>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><strong>Method</strong></p></th>
<th class="tableblock halign-left valign-middle"><p class="tableblock"><strong>Description</strong></p></th>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>size_type max_load() const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Returns the maximum number of allowed elements in the container before rehash.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>A note on <code>max_load</code> for open-addressing containers: the maximum load will be
(<code>max_load_factor() * bucket_count()</code>) right after <code>rehash</code> or on container creation, but may
slightly decrease when erasing elements in high-load situations. For instance, if we
have a <a href="#unordered_flat_map"><code>boost::unordered_flat_map</code></a> with <code>size()</code> almost
at <code>max_load()</code> level and then erase 1,000 elements, <code>max_load()</code> may decrease by around a
few dozen elements. This is done internally by Boost.Unordered in order
to keep its performance stable, and must be taken into account when planning for rehash-free insertions.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="buckets_iterator_invalidation"><a class="anchor" href="#buckets_iterator_invalidation"></a>Iterator Invalidation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It is not specified how member functions other than <code>rehash</code> and <code>reserve</code> affect
the bucket count, although <code>insert</code> can only invalidate iterators
when the insertion causes the container&#8217;s load to be greater than the maximum allowed.
For most implementations this means that <code>insert</code> will only
change the number of buckets when this happens. Iterators can be
invalidated by calls to <code>insert</code>, <code>rehash</code> and <code>reserve</code>.</p>
</div>
<div class="paragraph">
<p>As for pointers and references,
they are never invalidated for node-based containers
(<code>boost::unordered_[multi]set</code>, <code>boost::unordered_[multi]map</code>, <code>boost::unordered_node_set</code>, <code>boost::unordered_node_map</code>),
but they will when rehashing occurs for
<code>boost::unordered_flat_set</code> and <code>boost::unordered_flat_map</code>: this is because
these containers store elements directly into their holding buckets, so
when allocating a new bucket array the elements must be transferred by means of move construction.</p>
</div>
<div class="paragraph">
<p>In a similar manner to using <code>reserve</code> for <code>vector</code>s, it can be a good idea
to call <code>reserve</code> before inserting a large number of elements. This will get
the expensive rehashing out of the way and let you store iterators, safe in
the knowledge that they won&#8217;t be invalidated. If you are inserting <code>n</code>
elements into container <code>x</code>, you could first call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">x.reserve(n);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Note</dt>
<dd>
<p><code>reserve(n)</code> reserves space for at least <code>n</code> elements, allocating enough buckets
so as to not exceed the maximum load factor.</p>
<div class="paragraph">
<p>Because the maximum load factor is defined as the number of elements divided by the total
number of available buckets, this function is logically equivalent to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">x.rehash(std::ceil(n / x.max_load_factor()))</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="#unordered_map_rehash">reference for more details</a> on the <code>rehash</code> function.</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="buckets_fast_closed_addressing_implementation"><a class="anchor" href="#buckets_fast_closed_addressing_implementation"></a>Fast Closed Addressing Implementation</h2>
<div class="sectionbody">
<style>
  .imageblock > .title {
    text-align: inherit;
  }
</style>
<div class="paragraph">
<p>Boost.Unordered sports one of the fastest implementations of closed addressing, also commonly known as <a href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining">separate chaining</a>. An example figure representing the data structure is below:</p>
</div>
<div id="img-bucket-groups" class="imageblock text-center">
<div class="content">
<img src="../_images/bucket-groups.png" alt="bucket groups">
</div>
<div class="title">Figure 1. A simple bucket group approach</div>
</div>
<div class="paragraph">
<p>An array of "buckets" is allocated and each bucket in turn points to its own individual linked list. This makes meeting the standard requirements of bucket iteration straight-forward. Unfortunately, iteration of the entire container is often times slow using this layout as each bucket must be examined for occupancy, yielding a time complexity of <code>O(bucket_count() + size())</code> when the standard requires complexity to be <code>O(size())</code>.</p>
</div>
<div class="paragraph">
<p>Canonical standard implementations will wind up looking like the diagram below:</p>
</div>
<div class="imageblock text-center text-center">
<div class="content">
<a class="image" href="../diagrams/singly-linked.png" target="_blank" rel="noopener"><img src="../_images/singly-linked.png" alt="singly linked"></a>
</div>
<div class="title">Figure 2. The canonical standard approach</div>
</div>
<div class="paragraph">
<p>It&#8217;s worth noting that this approach is only used by libc++ and libstdc++; the MSVC Dinkumware implementation uses a different one. A more detailed analysis of the standard containers can be found <a href="http://bannalia.blogspot.com/2013/10/implementation-of-c-unordered.html">here</a>.</p>
</div>
<div class="paragraph">
<p>This unusually laid out data structure is chosen to make iteration of the entire container efficient by inter-connecting all of the nodes into a singly-linked list. One might also notice that buckets point to the node <em>before</em> the start of the bucket&#8217;s elements. This is done so that removing elements from the list can be done efficiently without introducing the need for a doubly-linked list. Unfortunately, this data structure introduces a guaranteed extra indirection. For example, to access the first element of a bucket, something like this must be done:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">auto const idx = get_bucket_idx(hash_function(key));
node* p = buckets[idx]; // first load
node* n = p-&gt;next; // second load
if (n &amp;&amp; is_in_bucket(n, idx)) {
  value_type const&amp; v = *n; // third load
  // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With a simple bucket group layout, this is all that must be done:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">auto const idx = get_bucket_idx(hash_function(key));
node* n = buckets[idx]; // first load
if (n) {
  value_type const&amp; v = *n; // second load
  // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In practice, the extra indirection can have a dramatic performance impact to common operations such as <code>insert</code>, <code>find</code> and <code>erase</code>. But to keep iteration of the container fast, Boost.Unordered introduces a novel data structure, a "bucket group". A bucket group is a fixed-width view of a subsection of the buckets array. It contains a bitmask (a <code>std::size_t</code>) which it uses to track occupancy of buckets and contains two pointers so that it can form a doubly-linked list with non-empty groups. An example diagram is below:</p>
</div>
<div id="img-fca-layout" class="imageblock text-center">
<div class="content">
<img src="../_images/fca.png" alt="fca">
</div>
<div class="title">Figure 3. The new layout used by Boost</div>
</div>
<div class="paragraph">
<p>Thus container-wide iteration is turned into traversing the non-empty bucket groups (an operation with constant time complexity) which reduces the time complexity back to <code>O(size())</code>. In total, a bucket group is only 4 words in size and it views <code>sizeof(std::size_t) * CHAR_BIT</code> buckets meaning that for all common implementations, there&#8217;s only 4 bits of space overhead per bucket introduced by the bucket groups.</p>
</div>
<div class="paragraph">
<p>A more detailed description of Boost.Unordered&#8217;s closed-addressing implementation is
given in an
<a href="https://bannalia.blogspot.com/2022/06/advancing-state-of-art-for.html">external article</a>.
For more information on implementation rationale, read the
<a href="#rationale_boostunordered_multiset_and_boostunordered_multimap">corresponding section</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="buckets_open_addressing_implementation"><a class="anchor" href="#buckets_open_addressing_implementation"></a>Open Addressing Implementation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The diagram shows the basic internal layout of <code>boost::unordered_flat_map</code>/<code>unordered_node_map</code> and
<code>boost:unordered_flat_set</code>/<code>unordered_node_set</code>.</p>
</div>
<div id="img-foa-layout" class="imageblock text-center">
<div class="content">
<img src="../_images/foa.png" alt="foa">
</div>
<div class="title">Figure 4. Open-addressing layout used by Boost.Unordered.</div>
</div>
<div class="paragraph">
<p>As with all open-addressing containers, elements (or pointers to the element nodes in the case of
<code>boost::unordered_node_map</code> and <code>boost::unordered_node_set</code>) are stored directly in the bucket array.
This array is logically divided into 2<sup><em>n</em></sup> <em>groups</em> of 15 elements each.
In addition to the bucket array, there is an associated <em>metadata array</em> with 2<sup><em>n</em></sup>
16-byte words.</p>
</div>
<div id="img-foa-metadata" class="imageblock text-center">
<div class="content">
<img src="../_images/foa-metadata.png" alt="foa metadata">
</div>
<div class="title">Figure 5. Breakdown of a metadata word.</div>
</div>
<div class="paragraph">
<p>A metadata word is divided into 15 <em>h</em><sub><em>i</em></sub> bytes (one for each associated
bucket), and an <em>overflow byte</em> (<em>ofw</em> in the diagram). The value of <em>h</em><sub><em>i</em></sub> is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>0 if the corresponding bucket is empty.</p>
</li>
<li>
<p>1 to encode a special empty bucket called a <em>sentinel</em>, which is used internally to
stop iteration when the container has been fully traversed.</p>
</li>
<li>
<p>If the bucket is occupied, a <em>reduced hash value</em> obtained from the hash value of
the element.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When looking for an element with hash value <em>h</em>, SIMD technologies such as
<a href="https://en.wikipedia.org/wiki/SSE2">SSE2</a> and
<a href="https://en.wikipedia.org/wiki/ARM_architecture_family#Advanced_SIMD_(Neon)">Neon</a> allow us
to very quickly inspect the full metadata word and look for the reduced value of <em>h</em> among all the
15 buckets with just a handful of CPU instructions: non-matching buckets can be
readily discarded, and those whose reduced hash value matches need be inspected via full
comparison with the corresponding element. If the looked-for element is not present,
the overflow byte is inspected:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the bit in the position <em>h</em> mod 8 is zero, lookup terminates (and the
element is not present).</p>
</li>
<li>
<p>If the bit is set to 1 (the group has been <em>overflowed</em>), further groups are
checked using <a href="https://en.wikipedia.org/wiki/Quadratic_probing"><em>quadratic probing</em></a>, and
the process is repeated.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Insertion is algorithmically similar: empty buckets are located using SIMD,
and when going past a full group its corresponding overflow bit is set to 1.</p>
</div>
<div class="paragraph">
<p>In architectures without SIMD support, the logical layout stays the same, but the metadata
word is codified using a technique we call <em>bit interleaving</em>: this layout allows us
to emulate SIMD with reasonably good performance using only standard arithmetic and
logical operations.</p>
</div>
<div id="img-foa-metadata-interleaving" class="imageblock text-center">
<div class="content">
<img src="../_images/foa-metadata-interleaving.png" alt="foa metadata interleaving">
</div>
<div class="title">Figure 6. Bit-interleaved metadata word.</div>
</div>
<div class="paragraph">
<p>A more detailed description of Boost.Unordered&#8217;s open-addressing implementation is
given in an
<a href="https://bannalia.blogspot.com/2022/11/inside-boostunorderedflatmap.html">external article</a>.
For more information on implementation rationale, read the
<a href="#rationale_boostunordered_flat_set_and_boostunordered_flat_map">corresponding section</a>.</p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
