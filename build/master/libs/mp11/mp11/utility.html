
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Utility Components, &lt;boost/mp11/utility.hpp&gt; :: Boost Libraries Documentation</title>
    <link rel="canonical" href="https://antora.cppalliance.org/master/libs/mp11/mp11/utility.html">
    <meta name="generator" content="Antora 3.1.2">
    <link rel="stylesheet" href="../../_/css/site.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">
    <script>var uiRootPath = '../../_'</script>
<script>

function updateTheme() {
  if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
    document.documentElement.classList.add('dark')
    document.getElementById("theme-button").checked = true;
  } else {
    document.documentElement.classList.remove('dark')
    document.getElementById("theme-button").checked = false;
  }
};

function onThemeButton() {
  if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
    localStorage.theme = 'light';
  } else {
    localStorage.theme = 'dark';
  }
  updateTheme();
}

window.addEventListener('load', function() {
    updateTheme();
}, false);

</script>
  </head>
  <body class="article">
<header>
  <nav class="navbar">
    <div class="navbar-brand">
      <button class="site-logo"></button>
      <a class="site-name" href="https://antora.cppalliance.org/master/libs">Boost</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-tabs">
        <a class="navbar-item" href="#">News</a>
        <a class="navbar-item" href="#">Learn</a>
        <a class="navbar-item" href="#">Community</a>
        <a class="navbar-item" href="#">Libraries</a>
        <a class="navbar-item" href="#">Releases</a>
        <div id="theme">
          <input type="checkbox" id="theme-button" onclick="onThemeButton()"/>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="mp11" data-version="">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" title="Toggle expand/collapse all"></button>
    <h3 class="title"><a href="../index.html">Boost.Mp11</a></h3>
    <ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="definitions.html">Definitions</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="examples.html">Examples</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="changelog.html">Revision History</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../reference.html">Reference</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="integral.html">Integral Constants</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="list.html">List Operations</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="utility.html">Utility Components</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="algorithm.html">Algorithms</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="set.html">Set Operations</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="map.html">Map Operations</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="function.html">Helper Metafunctions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="bind.html">Bind</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="integer_sequence.html">Integer Sequences</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="tuple.html">Tuple Operations</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="mp11.html">Convenience Header</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="mpl.html">MPL Support</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
    </div>
  </aside>
</div>
   
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../user-manual/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Boost.Mp11</a></li>
    <li><a href="../reference.html">Reference</a></li>
    <li><a href="utility.html">Utility Components</a></li>
  </ul>
</nav>
    <div class="edit-this-page"><a href="https://github.com/vinniefalco/mp11/edit/master/antora/modules/ROOT/pages/mp11/utility.adoc">Edit this Page</a></div>
    </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Utility Components, &lt;boost/mp11/utility.hpp&gt;</h1>
<div class="sect1">
<h2 id="mp_identityt"><a class="anchor" href="#mp_identityt"></a>mp_identity&lt;T&gt;</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>template&lt;class T&gt; struct mp_identity
{
    using type = T;
};</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_identity</code> is a simple <em>transformation type trait</em> (as per the C++ standard)
that just returns the same type. It&#8217;s useful both as such, and as a type wrapper
for passing types as values to functions.</p>
</div>
<div class="listingblock">
<div class="title">Using mp_identity as a type trait</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">template&lt;class T&gt; using addp_if_not_ref =
    typename mp_if&lt;std::is_reference&lt;T&gt;, mp_identity&lt;T&gt;, std::add_pointer&lt;T&gt;&gt;::type;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Using mp_identity to protect qualifiers and references</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">template&lt;class T&gt; void print1()
{
    std::cout &lt;&lt; typeid(T).name() &lt;&lt; std::endl;
}

template&lt;class T&gt; void print2()
{
    std::cout &lt;&lt; typeid(mp_identity&lt;T&gt;).name() &lt;&lt; std::endl;
}

int main()
{
    print1&lt;int const&amp;&gt;(); // 'int'
    print2&lt;int const&amp;&gt;(); // 'mp_identity&lt;int const &amp;&gt;'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mp_identity_tt"><a class="anchor" href="#mp_identity_tt"></a>mp_identity_t&lt;T&gt;</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>template&lt;class T&gt; using mp_identity_t = typename mp_identity&lt;T&gt;::type;</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mp_inheritt"><a class="anchor" href="#mp_inheritt"></a>mp_inherit&lt;T&#8230;&#8203;&gt;</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>template&lt;class... T&gt; struct mp_inherit: T... {};</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mp_if_cc_t_e"><a class="anchor" href="#mp_if_cc_t_e"></a>mp_if_c&lt;C, T, E&#8230;&#8203;&gt;</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>template&lt;bool C, class T, class... E&gt; using mp_if_c = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_if_c&lt;true, T, E&#8230;&#8203;&gt;</code> is an alias for <code>T</code>. <code>mp_if_c&lt;false, T, E&gt;</code> is an alias for <code>E</code>. Otherwise, the result is a substitution failure.</p>
</div>
<div class="listingblock">
<div class="title">Using mp_if_c to select between two alternatives</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">using R1 = mp_if_c&lt;true, int, void&gt;;  // int

using R2 = mp_if_c&lt;false, int, void&gt;; // void</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Using mp_if_c to fail substitution when a condition is not met</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">template&lt;class I&gt; using void_if_5 = mp_if_c&lt;I::value == 5, void&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example returns <code>void</code> when <code>I::value</code> is 5, and generates a substitution failure
otherwise. It&#8217;s the same as <code>std::enable_if_t&lt;I::value == 5&gt;</code> in C&#43;&#43;14, or
<code>typename std::enable_if&lt;I::value == 5&gt;::type</code> in C&#43;&#43;11.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mp_ifc_t_e"><a class="anchor" href="#mp_ifc_t_e"></a>mp_if&lt;C, T, E&#8230;&#8203;&gt;</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>template&lt;class C, class T, class... E&gt; using mp_if =
    mp_if_c&lt;static_cast&lt;bool&gt;(C::value), T, E...&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>Like <code>mp_if_c</code>, but the first argument is a type.</p>
</div>
<div class="listingblock">
<div class="title">Using mp_if to select between two alternatives</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">using R1 = mp_if&lt;mp_true, int, void&gt;;  // int

using R2 = mp_if&lt;mp_false, int, void&gt;; // void</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Using mp_if to fail substitution when a condition is not met</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">template&lt;class T&gt; using void_if_const = mp_if&lt;std::is_const&lt;T&gt;, void&gt;;

template&lt;class... T&gt; using void_if_all_const =
    mp_if&lt;mp_all&lt;std::is_const&lt;T&gt;...&gt;, void&gt;;

template&lt;class T&gt; using if_non_const = mp_if&lt;mp_not&lt;std::is_const&lt;T&gt;&gt;, T&gt;;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mp_eval_if_cc_t_f_u"><a class="anchor" href="#mp_eval_if_cc_t_f_u"></a>mp_eval_if_c&lt;C, T, F, U&#8230;&#8203;&gt;</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>template&lt;bool C, class T, template&lt;class...&gt; class F, class... U&gt; using mp_eval_if_c =
    /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_eval_if_c&lt;C, T, F, U&#8230;&#8203;&gt;</code> is an alias for <code>T</code> when <code>C</code> is <code>true</code>, for <code>F&lt;U&#8230;&#8203;&gt;</code> otherwise. Its purpose
is to avoid evaluating <code>F&lt;U&#8230;&#8203;&gt;</code> when the condition is <code>true</code> as it may not be valid in this case.</p>
</div>
<div class="listingblock">
<div class="title">Using mp_eval_if_c to select the first pack element, or void</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">template&lt;class... T&gt; using first_or_void =
    mp_eval_if_c&lt;sizeof...(T) == 0, void, mp_first, mp_list&lt;T...&gt;&gt;;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mp_eval_ifc_t_f_u"><a class="anchor" href="#mp_eval_ifc_t_f_u"></a>mp_eval_if&lt;C, T, F, U&#8230;&#8203;&gt;</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>template&lt;class C, class T, template&lt;class...&gt; class F, class... U&gt; using mp_eval_if =
    mp_eval_if_c&lt;static_cast&lt;bool&gt;(C::value), T, F, U...&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>Like <code>mp_eval_if_c</code>, but the first argument is a type.</p>
</div>
<div class="listingblock">
<div class="title">Using mp_eval_if to select the first list element, or void</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">template&lt;class L&gt; using first_or_void = mp_eval_if&lt;mp_empty&lt;L&gt;, void, mp_first, L&gt;;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mp_eval_if_qc_t_q_u"><a class="anchor" href="#mp_eval_if_qc_t_q_u"></a>mp_eval_if_q&lt;C, T, Q, U&#8230;&#8203;&gt;</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>template&lt;class C, class T, class Q, class... U&gt; using mp_eval_if_q =
    mp_eval_if&lt;C, T, Q::template fn, U...&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>Like <code>mp_eval_if</code>, but takes a quoted metafunction.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mp_eval_if_notc_t_f_u"><a class="anchor" href="#mp_eval_if_notc_t_f_u"></a>mp_eval_if_not&lt;C, T, F, U&#8230;&#8203;&gt;</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>template&lt;class C, class T, template&lt;class...&gt; class F, class... U&gt;
    using mp_eval_if_not = mp_eval_if&lt;mp_not&lt;C&gt;, T, F, U...&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>Same as <code>mp_eval_if</code>, but the condition is reversed.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mp_eval_if_not_qc_t_q_u"><a class="anchor" href="#mp_eval_if_not_qc_t_q_u"></a>mp_eval_if_not_q&lt;C, T, Q, U&#8230;&#8203;&gt;</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>template&lt;class C, class T, class Q, class... U&gt; using mp_eval_if_not_q =
    mp_eval_if_not&lt;C, T, Q::template fn, U...&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>Same as <code>mp_eval_if_not</code>, but takes a quoted metafunction.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mp_validf_t"><a class="anchor" href="#mp_validf_t"></a>mp_valid&lt;F, T&#8230;&#8203;&gt;</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>template&lt;template&lt;class...&gt; class F, class... T&gt; using mp_valid = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_valid&lt;F, T&#8230;&#8203;&gt;</code> is an alias for <code>mp_true</code> when <code>F&lt;T&#8230;&#8203;&gt;</code> is a valid expression, for <code>mp_false</code> otherwise.</p>
</div>
<div class="listingblock">
<div class="title">Using mp_valid to write a metafunction that checks for the existence of a nested type</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">template&lt;class T&gt; using get_nested_type = typename T::type;

template&lt;class T&gt; struct has_nested_type: mp_valid&lt;get_nested_type, T&gt; {};</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mp_valid_qq_t"><a class="anchor" href="#mp_valid_qq_t"></a>mp_valid_q&lt;Q, T&#8230;&#8203;&gt;</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>template&lt;class Q, class... T&gt; using mp_valid_q = mp_valid&lt;Q::template fn, T...&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>Like <code>mp_valid</code>, but takes a quoted metafunction.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mp_eval_ort_f_u"><a class="anchor" href="#mp_eval_ort_f_u"></a>mp_eval_or&lt;T, F, U&#8230;&#8203;&gt;</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>template&lt;class T, template&lt;class...&gt; class F, class... U&gt; using mp_eval_or =
    mp_eval_if_not&lt;mp_valid&lt;F, U...&gt;, T, F, U...&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_eval_or&lt;T, F, U&#8230;&#8203;&gt;</code> is an alias for <code>F&lt;U&#8230;&#8203;&gt;</code> when this expression is valid, for <code>T</code> otherwise.</p>
</div>
<div class="listingblock">
<div class="title">Using mp_eval_or to select the first pack element, or void</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">template&lt;class... T&gt; using first_or_void =
    mp_eval_or&lt;void, mp_first, mp_list&lt;T...&gt;&gt;;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mp_eval_or_qt_q_u"><a class="anchor" href="#mp_eval_or_qt_q_u"></a>mp_eval_or_q&lt;T, Q, U&#8230;&#8203;&gt;</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>template&lt;class T, class Q, class... U&gt; using mp_eval_or_q =
    mp_eval_or&lt;T, Q::template fn, U...&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>Like <code>mp_eval_or</code>, but takes a quoted metafunction.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mp_valid_and_truef_t"><a class="anchor" href="#mp_valid_and_truef_t"></a>mp_valid_and_true&lt;F, T&#8230;&#8203;&gt;</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>template&lt;template&lt;class...&gt; class F, class... T&gt; using mp_valid_and_true =
    mp_eval_or&lt;mp_false, F, T...&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_valid_and_true&lt;F, T&#8230;&#8203;&gt;</code> is an alias for <code>F&lt;T&#8230;&#8203;&gt;</code> when this expression is valid, for <code>mp_false</code> otherwise.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mp_valid_and_true_qq_t"><a class="anchor" href="#mp_valid_and_true_qq_t"></a>mp_valid_and_true_q&lt;Q, T&#8230;&#8203;&gt;</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>template&lt;class Q, class... T&gt; using mp_valid_and_true_q =
    mp_valid_and_true&lt;Q::template fn, T...&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>Like <code>mp_valid_and_true</code>, but takes a quoted metafunction.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mp_condc_t_r"><a class="anchor" href="#mp_condc_t_r"></a>mp_cond&lt;C, T, R&#8230;&#8203;&gt;</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>template&lt;class C, class T, class... R&gt; using mp_cond = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_cond&lt;C, T, R&#8230;&#8203;&gt;</code> is an alias for <code>T</code> when <code>static_cast&lt;bool&gt;(C::value)</code> is <code>true</code>.
When <code>static_cast&lt;bool&gt;(C::value)</code> is <code>false</code>, it&#8217;s an alias for <code>mp_cond&lt;R&#8230;&#8203;&gt;</code>.</p>
</div>
<div class="paragraph">
<p>(If <code>static_cast&lt;bool&gt;(C::value)</code> is a substitution failure, the result is too a substitution
failure.)</p>
</div>
<div class="listingblock">
<div class="title">Using mp_cond</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">template&lt;int N&gt; using unsigned_ = mp_cond&lt;
    mp_bool&lt;N ==  8&gt;, uint8_t,
    mp_bool&lt;N == 16&gt;, uint16_t,
    mp_bool&lt;N == 32&gt;, uint32_t,
    mp_bool&lt;N == 64&gt;, uint64_t,
    mp_true, unsigned // default case
&gt;;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mp_deferf_t"><a class="anchor" href="#mp_deferf_t"></a>mp_defer&lt;F, T&#8230;&#8203;&gt;</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>template&lt;template&lt;class...&gt; class F, class... T&gt; using mp_defer = /*...*/;</pre>
</div>
</div>
<div class="paragraph">
<p>When <code>mp_valid&lt;F, T&#8230;&#8203;&gt;</code> is <code>mp_true</code>, <code>mp_defer&lt;F, T&#8230;&#8203;&gt;</code> is a struct with a nested type <code>type</code> which is an alias for <code>F&lt;T&#8230;&#8203;&gt;</code>. Otherwise,
<code>mp_defer&lt;F, T&#8230;&#8203;&gt;</code> is an empty struct.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mp_quotef"><a class="anchor" href="#mp_quotef"></a>mp_quote&lt;F&gt;</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>template&lt;template&lt;class...&gt; class F&gt; struct mp_quote
{
    template&lt;class... T&gt; using fn = F&lt;T...&gt;;
};</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_quote&lt;F&gt;</code> transforms the template <code>F</code> into a <em>quoted metafunction</em>, a type with a nested template <code>fn</code> such that <code>fn&lt;T&#8230;&#8203;&gt;</code> returns <code>F&lt;T&#8230;&#8203;&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="title">Using mp_quote to make a list of metafunctions</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">using LQ = mp_list&lt;mp_quote&lt;std::is_const&gt;, mp_quote&lt;std::is_volatile&gt;&gt;;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mp_quote_traitf"><a class="anchor" href="#mp_quote_traitf"></a>mp_quote_trait&lt;F&gt;</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>template&lt;template&lt;class...&gt; class F&gt; struct mp_quote_trait
{
    template&lt;class... T&gt; using fn = typename F&lt;T...&gt;::type;
};</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_quote_trait&lt;F&gt;</code> transforms the C++03-style trait <code>F</code> into a quoted metafunction.</p>
</div>
<div class="listingblock">
<div class="title">Using mp_quote_trait with std::add_pointer</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">using L1 = mp_list&lt;int, void, float&gt;;
using R1 = mp_transform_q&lt;mp_quote_trait&lt;std::add_pointer&gt;, L1&gt;;
  // mp_list&lt;int*, void*, float*&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mp_invoke_qq_t"><a class="anchor" href="#mp_invoke_qq_t"></a>mp_invoke_q&lt;Q, T&#8230;&#8203;&gt;</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>template&lt;class Q, class... T&gt; using mp_invoke_q = typename Q::template fn&lt;T...&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_invoke_q&lt;Q, T&#8230;&#8203;&gt;</code> evaluates the nested template <code>fn</code> of a quoted metafunction. <code>mp_invoke_q&lt;mp_quote&lt;F&gt;, T&#8230;&#8203;&gt;</code> returns <code>F&lt;T&#8230;&#8203;&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="title">Using mp_invoke_q to invoke a list of metafunctions, technique 1</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">using LQ = mp_list&lt;mp_quote&lt;std::is_const&gt;, mp_quote&lt;std::is_volatile&gt;&gt;;

template&lt;class T&gt; using is_const_and_volatile =
    mp_apply&lt;mp_all, mp_product&lt;mp_invoke_q, LQ, mp_list&lt;T&gt;&gt;&gt;;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Using mp_invoke_q to invoke a list of metafunctions, technique 2</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">template&lt;class T&gt; using is_const_and_volatile =
    mp_apply&lt;mp_all, mp_transform_q&lt;mp_bind_back&lt;mp_invoke_q, T&gt;, LQ&gt;&gt;;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Using mp_invoke_q to invoke a list of metafunctions, technique 3</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">template&lt;class T&gt; using is_const_and_volatile =
    mp_apply&lt;mp_all, mp_transform&lt;mp_invoke_q, LQ, mp_fill&lt;LQ, T&gt;&gt;&gt;;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mp_not_fnp"><a class="anchor" href="#mp_not_fnp"></a>mp_not_fn&lt;P&gt;</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>template&lt;template&lt;class...&gt; class P&gt; struct mp_not_fn
{
    template&lt;class... T&gt; using fn = mp_not&lt;P&lt;T...&gt;&gt;;
};</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_not_fn&lt;P&gt;</code> returns a quoted metafunction <code>Q</code> such that <code>Q::fn&lt;T&#8230;&#8203;&gt;</code> returns <code>mp_not&lt;P&lt;T&#8230;&#8203;&gt;&gt;</code>.</p>
</div>
<div class="paragraph">
<p>That is, it negates the result of <code>P</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mp_not_fn_qq"><a class="anchor" href="#mp_not_fn_qq"></a>mp_not_fn_q&lt;Q&gt;</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>template&lt;class Q&gt; using mp_not_fn_q = mp_not_fn&lt;Q::template fn&gt;;</pre>
</div>
</div>
<div class="paragraph">
<p>As <code>mp_not_fn</code>, but takes a quoted metafunction.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mp_composef"><a class="anchor" href="#mp_composef"></a>mp_compose&lt;F&#8230;&#8203;&gt;</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>template&lt;template&lt;class...&gt; class... F&gt; struct mp_compose;</pre>
</div>
</div>
<div class="paragraph">
<p><code>mp_compose&lt;F1, F2, &#8230;&#8203;, Fn&gt;</code> is a quoted metafunction that applies
<code>F1</code>, <code>F2</code>, &#8230;&#8203;, <code>Fn</code> to its argument, in sequence. That is,
<code>mp_compose&lt;F1, F2, &#8230;&#8203;, Fn&gt;::fn&lt;T&#8230;&#8203;&gt;</code> is <code>Fn&lt;&#8230;&#8203;F2&lt;F1&lt;T&#8230;&#8203;&gt;&gt;&#8230;&#8203;&gt;</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mp_compose_qq"><a class="anchor" href="#mp_compose_qq"></a>mp_compose_q&lt;Q&#8230;&#8203;&gt;</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>template&lt;class... Q&gt; struct mp_compose_q;</pre>
</div>
</div>
<div class="paragraph">
<p>As <code>mp_compose</code>, but takes quoted metafunctions.</p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script id="site-script" src="../../_/js/site.js" data-ui-root-path="../../_"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
  </body>
</html>
